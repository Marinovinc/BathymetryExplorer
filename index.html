<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bathymetry Explorer - Mappe Batimetriche Mondiali</title>

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0ea5e9">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="BathyExplorer">
    <link rel="apple-touch-icon" href="icons/icon-152.png">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: #0f172a;
            color: #e2e8f0;
        }

        #map {
            position: fixed;
            top: 60px;
            left: 320px;
            right: 0;
            bottom: 0;
            z-index: 1;
            transition: filter 0.3s;
        }

        /* Mirino centrale - linee sottilissime */
        #mapCrosshair {
            position: fixed;
            top: 50%;
            left: calc(320px + (100% - 320px) / 2);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 500;
            opacity: 0.08;
            transition: opacity 0.4s ease-out;
        }
        #mapCrosshair.active {
            opacity: 0.6;
        }
        #mapCrosshair .crosshair-h,
        #mapCrosshair .crosshair-v {
            position: absolute;
            background: rgba(30, 41, 59, 0.9);
        }
        #mapCrosshair .crosshair-h {
            width: 40px;
            height: 1px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #mapCrosshair .crosshair-v {
            width: 1px;
            height: 40px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #mapCrosshair .crosshair-dot {
            position: absolute;
            width: 3px;
            height: 3px;
            background: rgba(30, 41, 59, 0.9);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Rosa dei Venti - piccola */
        #compassRose {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 60px;
            height: 60px;
            z-index: 800;
            pointer-events: auto;
            cursor: pointer;
            opacity: 0.85;
            transition: opacity 0.2s, transform 0.2s;
        }
        #compassRose:hover {
            opacity: 1;
            transform: scale(1.1);
        }
        #compassRose svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(135deg, #1e3a5f 0%, #0c4a6e 100%);
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #7dd3fc;
            font-size: 1.4rem;
            font-weight: 700;
        }

        .logo i {
            font-size: 1.8rem;
        }

        /* Sidebar - All controls on left */
        .sidebar {
            position: fixed;
            top: 60px;
            left: 0;
            width: 320px;
            height: calc(100vh - 60px);
            background: rgba(15, 23, 42, 0.98);
            z-index: 1000;
            overflow-y: auto;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar-section {
            padding: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar-section h3 {
            color: #7dd3fc;
            margin-bottom: 12px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .search-group {
            margin-bottom: 12px;
        }

        .search-group label {
            display: block;
            font-size: 0.8rem;
            color: #94a3b8;
            margin-bottom: 5px;
        }

        .search-input-wrapper {
            position: relative;
        }

        .search-input-wrapper input {
            width: 100%;
            padding: 10px 40px 10px 12px;
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(100, 116, 139, 0.3);
            border-radius: 8px;
            color: #e2e8f0;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .search-input-wrapper input:focus {
            outline: none;
            border-color: #0ea5e9;
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.2);
        }

        .search-input-wrapper input::placeholder {
            color: #64748b;
        }

        .search-btn {
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            background: #0ea5e9;
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .search-btn:hover {
            background: #0284c7;
        }

        .coords-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .coords-row input {
            width: 100%;
            padding: 8px 10px;
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(100, 116, 139, 0.3);
            border-radius: 6px;
            color: #e2e8f0;
            font-size: 0.85rem;
            font-family: 'Consolas', monospace;
        }

        .coords-row input:focus {
            outline: none;
            border-color: #0ea5e9;
        }

        .go-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .go-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(14, 165, 233, 0.4);
        }

        .divider {
            text-align: center;
            color: #64748b;
            font-size: 0.75rem;
            margin: 12px 0;
            position: relative;
        }

        .divider::before,
        .divider::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 35%;
            height: 1px;
            background: rgba(100, 116, 139, 0.3);
        }

        .divider::before { left: 0; }
        .divider::after { right: 0; }

        /* Quick Links */
        .quick-links {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .quick-link-btn {
            padding: 5px 10px;
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(100, 116, 139, 0.3);
            border-radius: 15px;
            color: #cbd5e1;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quick-link-btn:hover {
            background: rgba(14, 165, 233, 0.2);
            border-color: #0ea5e9;
            color: #7dd3fc;
        }

        .quick-link-btn.saved {
            position: relative;
            padding-right: 24px;
        }

        .quick-link-btn .delete-btn {
            position: absolute;
            right: 3px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(239, 68, 68, 0.8);
            border: none;
            color: white;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .quick-link-btn.saved:hover .delete-btn {
            opacity: 1;
        }

        .quick-link-btn .delete-btn:hover {
            background: #dc2626;
        }

        /* Save to favorites button */
        .save-favorite-btn {
            display: none;
            width: 100%;
            padding: 8px;
            margin-top: 8px;
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            gap: 6px;
            align-items: center;
            justify-content: center;
        }

        .save-favorite-btn.show {
            display: flex;
        }

        .save-favorite-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
        }

        .save-favorite-btn.saved {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            pointer-events: none;
        }

        /* Competition Field Button */
        .competition-field-btn {
            width: 100%;
            padding: 10px;
            margin-top: 8px;
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .competition-field-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
        }

        /* Zone Select Dropdown */
        .zone-select {
            width: 100%;
            padding: 10px 12px;
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            color: #e2e8f0;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .zone-select:hover {
            border-color: #8b5cf6;
        }

        .zone-select:focus {
            outline: none;
            border-color: #8b5cf6;
            box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.2);
        }

        /* Ruler Tool Styles */
        .ruler-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .ruler-btn {
            flex: 1;
            padding: 10px 12px;
            border: none;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .ruler-btn.primary {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
        }

        .ruler-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
        }

        .ruler-btn.primary.active {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.3);
        }

        .ruler-btn.secondary {
            background: #334155;
            color: #94a3b8;
        }

        .ruler-btn.secondary:hover {
            background: #475569;
            color: #e2e8f0;
        }

        .ruler-result {
            background: linear-gradient(135deg, #1e3a5f 0%, #0c4a6e 100%);
            border-radius: 10px;
            padding: 12px;
            margin-top: 10px;
            display: none;
        }

        .ruler-result.visible {
            display: block;
        }

        .ruler-result-title {
            font-size: 0.75rem;
            color: #7dd3fc;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .ruler-distance {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ruler-value {
            text-align: center;
        }

        .ruler-value .number {
            font-size: 1.4rem;
            font-weight: 700;
            color: #fbbf24;
            font-family: 'Courier New', monospace;
        }

        .ruler-value .unit {
            font-size: 0.7rem;
            color: #94a3b8;
            display: block;
            margin-top: 2px;
        }

        .ruler-points {
            font-size: 0.75rem;
            color: #64748b;
            margin-top: 8px;
            text-align: center;
        }

        /* Competition Field Section */
        .competition-field-section {
            margin-top: 15px;
            padding-top: 12px;
            border-top: 1px solid rgba(139, 92, 246, 0.3);
        }

        .competition-field-section h4 {
            color: #a78bfa;
            font-size: 0.85rem;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .competition-field-info {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
        }

        .competition-field-info .field-name {
            font-weight: 600;
            color: #e2e8f0;
            margin-bottom: 4px;
        }

        .competition-field-info .field-coords {
            font-size: 0.8rem;
            color: #a78bfa;
            font-family: 'Consolas', monospace;
        }

        .competition-field-actions {
            display: flex;
            gap: 6px;
        }

        .competition-field-actions button {
            flex: 1;
            padding: 6px;
            border-radius: 6px;
            border: none;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .competition-field-actions .goto-btn {
            background: rgba(139, 92, 246, 0.3);
            color: #e2e8f0;
        }

        .competition-field-actions .goto-btn:hover {
            background: rgba(139, 92, 246, 0.5);
        }

        .competition-field-actions .clear-btn {
            background: rgba(239, 68, 68, 0.3);
            color: #fca5a5;
        }

        .competition-field-actions .clear-btn:hover {
            background: rgba(239, 68, 68, 0.5);
        }

        /* Competition marker icon */
        .competition-marker-icon {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            border-radius: 50%;
            width: 30px !important;
            height: 30px !important;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(139, 92, 246, 0.5);
            border: 2px solid white;
        }

        /* Layer Controls */
        .layer-item {
            display: flex;
            align-items: center;
            padding: 8px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 8px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .layer-item:hover {
            background: rgba(30, 41, 59, 0.8);
        }

        .layer-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin-right: 10px;
            accent-color: #0ea5e9;
        }

        .layer-item label {
            flex: 1;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .layer-item .layer-desc {
            font-size: 0.7rem;
            color: #64748b;
            margin-top: 1px;
        }

        .layer-item .layer-title {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .layer-item .info-link {
            color: #64748b;
            font-size: 0.7rem;
            transition: color 0.2s;
        }

        .layer-item .info-link:hover {
            color: #0ea5e9;
        }

        .layer-item .coverage-badge {
            font-size: 0.6rem;
            padding: 1px 5px;
            border-radius: 8px;
            margin-left: 4px;
        }

        .coverage-badge.europe {
            background: rgba(59, 130, 246, 0.3);
            color: #93c5fd;
        }

        .coverage-badge.global {
            background: rgba(34, 197, 94, 0.3);
            color: #86efac;
        }

        .coverage-badge.usa {
            background: rgba(59, 130, 246, 0.3);
            color: #93c5fd;
        }

        /* Toast notifications */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            position: relative;
            background: rgba(30, 41, 59, 0.95);
            border: 1px solid rgba(251, 191, 36, 0.5);
            border-radius: 8px;
            padding: 12px 16px;
            padding-right: 30px;
            max-width: 320px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            animation: slideIn 0.3s ease;
        }

        .toast.warning {
            border-color: rgba(251, 191, 36, 0.5);
        }

        .toast.warning .toast-icon {
            color: #fbbf24;
        }

        .toast.info {
            border-color: rgba(14, 165, 233, 0.5);
        }

        .toast.info .toast-icon {
            color: #0ea5e9;
        }

        .toast-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .toast-title {
            font-weight: 600;
            font-size: 0.85rem;
            color: #e2e8f0;
        }

        .toast-message {
            font-size: 0.75rem;
            color: #94a3b8;
            line-height: 1.4;
        }

        .toast-close {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: #64748b;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .toast-close:hover {
            color: #e2e8f0;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Sliders */
        .slider-control {
            margin-top: 10px;
            padding: 10px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 8px;
        }

        .slider-control label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #94a3b8;
            margin-bottom: 6px;
        }

        .slider-control input[type="range"] {
            width: 100%;
            height: 5px;
            border-radius: 3px;
            background: rgba(100, 116, 139, 0.3);
            outline: none;
            -webkit-appearance: none;
        }

        .slider-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #0ea5e9;
            cursor: pointer;
        }

        /* Legend */
        .legend-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.75rem;
            color: #cbd5e1;
        }

        .legend-color {
            width: 20px;
            height: 12px;
            margin-right: 6px;
            border-radius: 2px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Info Panel in sidebar */
        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            padding: 4px 0;
            border-bottom: 1px solid rgba(100, 116, 139, 0.2);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row .label {
            color: #94a3b8;
        }

        .info-row .value {
            color: #fbbf24;
            font-family: 'Consolas', monospace;
        }

        /* Loading Overlay */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 23, 42, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.5s;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading i {
            font-size: 3rem;
            color: #0ea5e9;
            animation: spin 1s linear infinite;
        }

        .loading p {
            margin-top: 15px;
            color: #94a3b8;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Search Results Dropdown */
        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(30, 41, 59, 0.98);
            border-radius: 8px;
            margin-top: 4px;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            display: none;
            z-index: 1001;
        }

        .search-results.show {
            display: block;
        }

        .search-result-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid rgba(100, 116, 139, 0.2);
            transition: background 0.2s;
        }

        .search-result-item:hover {
            background: rgba(14, 165, 233, 0.2);
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item .name {
            font-size: 0.85rem;
            color: #e2e8f0;
        }

        .search-result-item .type {
            font-size: 0.7rem;
            color: #64748b;
            margin-top: 2px;
        }

        /* Toggle sidebar button */
        .toggle-sidebar {
            position: fixed;
            top: 70px;
            left: 320px;
            width: 24px;
            height: 50px;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: none;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #7dd3fc;
            transition: all 0.3s;
        }

        .toggle-sidebar:hover {
            background: rgba(14, 165, 233, 0.3);
        }

        .sidebar.collapsed {
            transform: translateX(-320px);
        }

        .sidebar.collapsed + .toggle-sidebar {
            left: 0;
        }

        .sidebar.collapsed ~ #map {
            left: 0;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                width: 280px;
                transform: translateX(-280px);
                height: calc(100vh - 60px);
                overflow-y: auto;
                -webkit-overflow-scrolling: touch; /* Smooth scroll iOS */
            }

            .sidebar.open {
                transform: translateX(0);
            }

            #map {
                left: 0;
            }

            .toggle-sidebar {
                left: 0;
            }

            .sidebar.open + .toggle-sidebar {
                left: 280px;
            }

            /* Sezioni più compatte su mobile */
            .sidebar-section {
                margin-bottom: 4px;
            }

            .sidebar-section h3 {
                padding: 8px 10px;
                font-size: 0.8rem;
            }

            .sidebar-section .section-content {
                padding: 8px;
                font-size: 0.75rem;
            }

            .sidebar-section input,
            .sidebar-section select,
            .sidebar-section button {
                padding: 6px 8px;
                font-size: 0.75rem;
            }

            .sidebar-section .layer-item {
                padding: 4px 0;
            }
        }

        /* Darken Esri Ocean Base to balance with Satellite */
        .esri-ocean-tiles {
            filter: brightness(0.75) saturate(1.3) contrast(1.1);
        }

        /* GEBCO style - deeper blue tones */
        .gebco-tiles {
            filter: brightness(0.7) saturate(1.5) contrast(1.15) hue-rotate(-10deg);
        }

        /* === CATCH LOG STYLES === */

        /* Marker catture */
        .catch-marker-icon {
            border-radius: 50%;
            width: 28px !important;
            height: 28px !important;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            border: 2px solid white;
        }
        .catch-marker-icon.strike { background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); }
        .catch-marker-icon.release { background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); }
        .catch-marker-icon.sighting { background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); }
        .catch-marker-icon.weighed_catch { background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); }

        /* Statistiche catture */
        .catch-stats {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        .catch-stat-item {
            flex: 1;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }
        .catch-stat-item .stat-number {
            display: block;
            font-size: 1.4rem;
            font-weight: 700;
            color: #fbbf24;
        }
        .catch-stat-item .stat-label {
            font-size: 0.7rem;
            color: #94a3b8;
            text-transform: uppercase;
        }

        /* Lista catture scrollabile */
        .catch-list-container {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        .catch-list-empty {
            text-align: center;
            padding: 20px;
            color: #64748b;
        }
        .catch-list-empty i {
            font-size: 2rem;
            margin-bottom: 10px;
            opacity: 0.5;
        }
        .catch-list-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 8px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .catch-list-item:hover {
            background: rgba(14, 165, 233, 0.2);
        }
        .catch-list-item .catch-icon {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 11px;
        }
        .catch-list-item .catch-info {
            flex: 1;
        }
        .catch-list-item .catch-species {
            font-size: 0.85rem;
            color: #e2e8f0;
            font-weight: 500;
        }
        .catch-list-item .catch-meta {
            font-size: 0.7rem;
            color: #64748b;
        }
        .catch-list-item .catch-delete {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(239, 68, 68, 0.3);
            border: none;
            color: #fca5a5;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .catch-list-item:hover .catch-delete {
            opacity: 1;
        }
        .catch-list-item.incomplete {
            border-left: 3px solid #f59e0b;
            animation: pulse-incomplete 2s infinite;
        }
        @keyframes pulse-incomplete {
            0%, 100% { background: rgba(30, 41, 59, 0.7); }
            50% { background: rgba(245, 158, 11, 0.15); }
        }

        /* Dialog Nuova Cattura */
        .catch-dialog-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .catch-dialog {
            background: linear-gradient(135deg, #1e3a5f 0%, #0c4a6e 100%);
            border-radius: 16px;
            padding: 24px;
            max-width: 450px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        .catch-dialog h3 {
            color: #7dd3fc;
            margin: 0 0 16px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .catch-form-group {
            margin-bottom: 14px;
        }
        .catch-form-group label {
            display: block;
            color: #e2e8f0;
            font-size: 0.85rem;
            margin-bottom: 6px;
        }
        .catch-form-group input,
        .catch-form-group select,
        .catch-form-group textarea {
            width: 100%;
            padding: 10px 12px;
            border-radius: 8px;
            background: #1e293b;
            border: 1px solid #334155;
            color: #e2e8f0;
            font-size: 0.9rem;
            box-sizing: border-box;
        }
        .catch-form-group input:focus,
        .catch-form-group select:focus,
        .catch-form-group textarea:focus {
            outline: none;
            border-color: #0ea5e9;
            box-shadow: 0 0 0 2px rgba(14, 165, 233, 0.2);
        }
        .catch-type-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        .catch-type-btn {
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #334155;
            background: rgba(30, 41, 59, 0.5);
            color: #94a3b8;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }
        .catch-type-btn:hover {
            border-color: #64748b;
            color: #e2e8f0;
        }
        .catch-type-btn.selected {
            border-color: var(--type-color, #0ea5e9);
            background: rgba(14, 165, 233, 0.2);
            color: #e2e8f0;
        }
        .catch-type-btn i {
            display: block;
            font-size: 1.2rem;
            margin-bottom: 4px;
        }
        .catch-form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .photo-upload-area {
            border: 2px dashed #334155;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            color: #64748b;
        }
        .photo-upload-area:hover {
            border-color: #0ea5e9;
            background: rgba(14, 165, 233, 0.1);
        }
        .photo-upload-area.has-photo {
            padding: 10px;
        }
        .photo-upload-area img {
            max-width: 100%;
            max-height: 150px;
            border-radius: 4px;
        }
        .catch-dialog-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .catch-dialog-actions button {
            flex: 1;
            padding: 12px;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
        }
        .catch-dialog-actions .btn-cancel {
            background: #475569;
            color: #e2e8f0;
        }
        .catch-dialog-actions .btn-save {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            color: white;
        }

        /* Collapsible Sections */
        .sidebar-section.collapsible h3 {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .sidebar-section.collapsible h3 .section-title-text {
            flex: 1;
        }
        .sidebar-section.collapsible h3 .collapse-icon {
            transition: transform 0.3s ease;
            font-size: 0.7rem;
            color: #94a3b8;
        }
        .sidebar-section.collapsible.collapsed h3 .collapse-icon {
            transform: rotate(-90deg);
        }
        .sidebar-section.collapsible .section-content {
            transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
            max-height: 2000px;
            opacity: 1;
            overflow: hidden;
        }
        .sidebar-section.collapsible.collapsed .section-content {
            max-height: 0;
            opacity: 0;
            padding-top: 0;
            padding-bottom: 0;
        }

        /* Help Button */
        .help-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(59, 130, 246, 0.3);
            border: 1px solid #3b82f6;
            color: #3b82f6;
            font-size: 0.7rem;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        .help-btn:hover {
            background: #3b82f6;
            color: white;
            transform: scale(1.1);
        }
        /* Inline Help Button (next to function buttons) */
        .help-btn-inline {
            width: 18px;
            height: 18px;
            min-width: 18px;
            border-radius: 50%;
            background: rgba(59, 130, 246, 0.25);
            border: 1px solid rgba(59, 130, 246, 0.6);
            color: #60a5fa;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            margin-left: 6px;
            flex-shrink: 0;
        }
        .help-btn-inline:hover {
            background: #3b82f6;
            color: white;
            transform: scale(1.15);
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
        }

        /* Help Popup Modal */
        .help-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        .help-popup-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .help-popup {
            background: linear-gradient(145deg, #1e293b 0%, #0f172a 100%);
            border-radius: 16px;
            border: 1px solid rgba(59, 130, 246, 0.3);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            transform: scale(0.9) translateY(20px);
            transition: transform 0.3s ease;
        }
        .help-popup-overlay.show .help-popup {
            transform: scale(1) translateY(0);
        }
        .help-popup-header {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            padding: 16px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .help-popup-header h3 {
            margin: 0;
            color: white;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .help-popup-close {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        .help-popup-close:hover {
            background: rgba(255,255,255,0.3);
        }
        .help-popup-content {
            padding: 20px;
            color: #e2e8f0;
            overflow-y: auto;
            max-height: calc(80vh - 80px);
        }
        .help-popup-content h4 {
            color: #22d3ee;
            margin: 0 0 10px 0;
            font-size: 0.95rem;
        }
        .help-popup-content p {
            margin: 0 0 12px 0;
            line-height: 1.6;
            font-size: 0.9rem;
        }
        .help-popup-content ul {
            margin: 0 0 12px 0;
            padding-left: 20px;
        }
        .help-popup-content li {
            margin-bottom: 6px;
            line-height: 1.5;
            font-size: 0.9rem;
        }
        .help-popup-content .tip {
            background: rgba(34, 197, 94, 0.15);
            border-left: 3px solid #22c55e;
            padding: 10px 12px;
            border-radius: 0 8px 8px 0;
            margin: 12px 0;
        }
        .help-popup-content .tip-title {
            color: #22c55e;
            font-weight: 600;
            font-size: 0.85rem;
            margin-bottom: 4px;
        }
        .help-popup-content kbd {
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.85rem;
            border: 1px solid #475569;
        }

        /* GPS Tracking Switch */
        .tracking-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }
        .tracking-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .tracking-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #475569;
            transition: 0.4s;
            border-radius: 26px;
        }
        .tracking-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }
        .tracking-switch input:checked + .tracking-slider {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
        }
        .tracking-switch input:checked + .tracking-slider:before {
            transform: translateX(24px);
        }

        /* GPS Stats Display */
        .gps-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 10px 0;
        }
        .gps-stat-item {
            background: rgba(0,0,0,0.2);
            padding: 8px;
            border-radius: 8px;
            text-align: center;
        }
        .gps-stat-value {
            font-size: 1.1rem;
            font-weight: 700;
            color: #22d3ee;
        }
        .gps-stat-label {
            font-size: 0.7rem;
            color: #94a3b8;
            margin-top: 2px;
        }
        .gps-stat-item.full-width {
            grid-column: span 2;
        }

        /* Route List */
        .route-list {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
        }
        .route-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }
        .route-item:hover {
            background: rgba(0,0,0,0.3);
        }
        /* Route Tooltip & Popup Styles */
        .route-tooltip {
            background: linear-gradient(145deg, #1e293b 0%, #0f172a 100%) !important;
            border: 1px solid rgba(139, 92, 246, 0.5) !important;
            border-radius: 8px !important;
            padding: 8px 12px !important;
            font-family: 'Segoe UI', system-ui, sans-serif !important;
            color: #e2e8f0 !important;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4) !important;
        }
        .route-tooltip::before {
            border-top-color: rgba(139, 92, 246, 0.5) !important;
        }
        .route-popup .leaflet-popup-content-wrapper {
            background: linear-gradient(145deg, #1e293b 0%, #0f172a 100%) !important;
            border: 1px solid rgba(139, 92, 246, 0.4) !important;
            border-radius: 12px !important;
            color: #e2e8f0 !important;
        }
        .route-popup .leaflet-popup-tip {
            background: #1e293b !important;
            border: 1px solid rgba(139, 92, 246, 0.4) !important;
        }
        .route-popup table td {
            padding: 3px 8px;
        }
        .route-popup table td:first-child {
            color: #94a3b8;
        }
        .route-item-info {
            flex: 1;
            overflow: hidden;
        }
        .route-item-name {
            color: #e2e8f0;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .route-item-meta {
            color: #94a3b8;
            font-size: 0.75rem;
        }
        .route-item-actions {
            display: flex;
            gap: 4px;
        }
        .route-item-actions button {
            background: none;
            border: none;
            color: #94a3b8;
            cursor: pointer;
            padding: 4px;
            font-size: 0.9rem;
        }
        .route-item-actions button:hover {
            color: #22d3ee;
        }
        .route-item-actions button.delete:hover {
            color: #ef4444;
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading" id="loading">
        <i class="fas fa-water"></i>
        <p>Caricamento mappe batimetriche...</p>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="logo">
            <i class="fas fa-water"></i>
            <span>Bathymetry Explorer</span>
        </div>
    </header>

    <!-- Sidebar - All controls on left side -->
    <div class="sidebar" id="sidebar">
        <!-- Offline Section - PRIORITÀ per mobile -->
        <div class="sidebar-section collapsible collapsed" id="offlineSection">
            <h3 onclick="toggleSection('offlineSection')">
                <i class="fas fa-cloud-download-alt"></i>
                <span class="section-title-text">Offline</span>
                <button class="help-btn" onclick="event.stopPropagation(); showHelp('offline')" title="Guida">?</button>
                <span class="collapse-icon"><i class="fas fa-chevron-down"></i></span>
            </h3>
            <div class="section-content">
                <p style="font-size: 0.75rem; color: #94a3b8; margin-bottom: 10px;">
                    Scarica le mappe dal porto al campo di gara per navigare senza internet.
                </p>

                <!-- Selezione Campo di Gara -->
                <div class="form-group" style="margin-bottom: 10px;">
                    <label style="font-size: 0.75rem; color: #94a3b8; margin-bottom: 4px; display: block;">
                        <i class="fas fa-flag-checkered"></i> Campo di Gara
                    </label>
                    <select id="offlineZoneSelect" style="width: 100%; padding: 8px; background: #1e293b; border: 1px solid rgba(148,163,184,0.3); border-radius: 6px; color: #e2e8f0; font-size: 0.8rem;">
                        <option value="">-- Seleziona campo --</option>
                    </select>
                </div>

                <!-- Info area da scaricare -->
                <div id="offlineAreaInfo" style="display: none; background: rgba(14,165,233,0.1); border: 1px solid rgba(14,165,233,0.3); border-radius: 6px; padding: 8px; margin-bottom: 10px; font-size: 0.7rem;">
                    <div style="color: #0ea5e9; font-weight: 600; margin-bottom: 4px;">
                        <i class="fas fa-info-circle"></i> Area download:
                    </div>
                    <div id="offlineAreaDetails" style="color: #94a3b8;"></div>
                </div>

                <button id="downloadOfflineBtn" class="competition-field-btn" style="width: 100%; background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);" onclick="downloadZoneForOffline()" disabled>
                    <i class="fas fa-download"></i> Scarica Mappe Gara
                </button>

                <div id="offlineProgressContainer" style="display: none; margin-top: 10px;">
                    <div style="background: #1e293b; border-radius: 4px; height: 8px; overflow: hidden;">
                        <div id="offlineProgress" style="background: linear-gradient(90deg, #0ea5e9, #22c55e); height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div id="offlineProgressText" style="font-size: 0.7rem; color: #94a3b8; margin-top: 4px; text-align: center;">
                        Preparazione...
                    </div>
                </div>

                <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(148,163,184,0.2);">
                    <div class="info-row" style="margin-bottom: 8px;">
                        <span class="label">Cache salvata:</span>
                        <span class="value" id="cacheSize">0 MB</span>
                    </div>
                    <button class="competition-field-btn" style="width: 100%; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); font-size: 0.75rem; padding: 6px;" onclick="clearOfflineCache()">
                        <i class="fas fa-trash"></i> Pulisci Cache
                    </button>
                </div>

                <div style="margin-top: 10px; font-size: 0.65rem; color: #64748b;">
                    <i class="fas fa-info-circle"></i> Include: Porto partenza + Campo gara + 10nm buffer
                </div>
            </div><!-- /section-content -->
        </div>

        <!-- Search Section -->
        <div class="sidebar-section collapsible collapsed" id="searchSection">
            <h3 onclick="toggleSection('searchSection')">
                <i class="fas fa-search"></i>
                <span class="section-title-text">Cerca Posizione</span>
                <button class="help-btn" onclick="event.stopPropagation(); showHelp('search')" title="Guida">?</button>
                <span class="collapse-icon"><i class="fas fa-chevron-down"></i></span>
            </h3>
            <div class="section-content">
            <div class="search-group">
                <label>Nome luogo</label>
                <div class="search-input-wrapper">
                    <input type="text" id="searchInput" placeholder="es. Ischia, Italia">
                    <button class="search-btn" onclick="searchLocation()">
                        <i class="fas fa-search"></i>
                    </button>
                    <div class="search-results" id="searchResults"></div>
                </div>
            </div>
            <div class="divider">oppure</div>
            <div class="search-group">
                <label>Coordinate GPS</label>
                <div class="coords-row">
                    <input type="text" id="latInput" placeholder="Latitudine" value="">
                    <input type="text" id="lngInput" placeholder="Longitudine" value="">
                </div>
            </div>
            <button class="go-btn" onclick="goToCoordinates()">
                <i class="fas fa-location-crosshairs"></i>
                Vai alle coordinate
            </button>
            <button class="save-favorite-btn" id="saveFavoriteBtn" onclick="saveCurrentToFavorites()">
                <i class="fas fa-star"></i>
                Salva nei preferiti
            </button>
            </div><!-- /section-content -->
        </div>

        <!-- Quick Links Section -->
        <div class="sidebar-section collapsible collapsed" id="favoritesSection">
            <h3 onclick="toggleSection('favoritesSection')">
                <i class="fas fa-star"></i>
                <span class="section-title-text">Luoghi Interessanti</span>
                <button class="help-btn" onclick="event.stopPropagation(); showHelp('favorites')" title="Guida">?</button>
                <span class="collapse-icon"><i class="fas fa-chevron-down"></i></span>
            </h3>
            <div class="section-content">
            <div class="quick-links" id="quickLinksContainer">
                <!-- Rendered dynamically by JavaScript -->
            </div>
            </div><!-- /section-content -->
        </div>

        <!-- Bathymetry Layers Section -->
        <div class="sidebar-section collapsible collapsed" id="bathymetrySection">
            <h3 onclick="toggleSection('bathymetrySection')">
                <i class="fas fa-water"></i>
                <span class="section-title-text">Batimetria</span>
                <button class="help-btn" onclick="event.stopPropagation(); showHelp('bathymetry')" title="Guida">?</button>
                <span class="collapse-icon"><i class="fas fa-chevron-down"></i></span>
            </h3>
            <div class="section-content">
            <div class="layer-item" data-coverage="europe">
                <input type="checkbox" id="layerBathy" checked>
                <label for="layerBathy">
                    <div class="layer-title">
                        EMODnet Batimetria
                        <a href="https://emodnet.ec.europa.eu/en/bathymetry" target="_blank" class="info-link" title="Info EMODnet"><i class="fas fa-info-circle"></i></a>
                        <span class="coverage-badge europe">Europa</span>
                    </div>
                    <div class="layer-desc">Profondità con scala colori</div>
                </label>
            </div>
            <div class="layer-item" data-coverage="europe">
                <input type="checkbox" id="layerBathyHR">
                <label for="layerBathyHR">
                    <div class="layer-title">
                        Alta Risoluzione (HR)
                        <a href="https://emodnet.ec.europa.eu/en/bathymetry" target="_blank" class="info-link" title="Info EMODnet HR"><i class="fas fa-info-circle"></i></a>
                        <span class="coverage-badge europe">Europa</span>
                    </div>
                    <div class="layer-desc">Dettaglio maggiore dove disponibile</div>
                </label>
            </div>
            <div class="layer-item" data-coverage="global">
                <input type="checkbox" id="layerGEBCO">
                <label for="layerGEBCO">
                    <div class="layer-title">
                        GEBCO 2024 WMS
                        <a href="https://www.gebco.net/data-products/gebco-web-services/web-map-service" target="_blank" class="info-link" title="Info GEBCO WMS"><i class="fas fa-info-circle"></i></a>
                        <span class="coverage-badge global">Globale</span>
                    </div>
                    <div class="layer-desc">Griglia batimetrica ufficiale mondiale</div>
                </label>
            </div>
            <div class="layer-item" data-coverage="usa">
                <input type="checkbox" id="layerBlueTopo">
                <label for="layerBlueTopo">
                    <div class="layer-title">
                        NOAA BlueTopo
                        <a href="https://nauticalcharts.noaa.gov/data/bluetopo.html" target="_blank" class="info-link" title="Info BlueTopo"><i class="fas fa-info-circle"></i></a>
                        <span class="coverage-badge usa">USA</span>
                    </div>
                    <div class="layer-desc">Batimetria navale alta precisione</div>
                </label>
            </div>
            <div class="layer-item" data-coverage="global">
                <input type="checkbox" id="layerETOPO">
                <label for="layerETOPO">
                    <div class="layer-title">
                        Esri Ocean Base
                        <a href="https://www.arcgis.com/home/item.html?id=1e126e7520f9466c9ca28b8f28b5e500" target="_blank" class="info-link" title="Info Esri Ocean"><i class="fas fa-info-circle"></i></a>
                        <span class="coverage-badge global">Globale</span>
                    </div>
                    <div class="layer-desc">Batimetria mondiale (consigliato)</div>
                </label>
            </div>
            <div class="layer-item" data-coverage="global">
                <input type="checkbox" id="layerOceanRef">
                <label for="layerOceanRef">
                    <div class="layer-title">
                        Etichette Profondità
                        <a href="https://carto.com/basemaps/" target="_blank" class="info-link" title="Info CartoDB"><i class="fas fa-info-circle"></i></a>
                        <span class="coverage-badge global">Globale</span>
                    </div>
                    <div class="layer-desc">Nomi e annotazioni oceaniche</div>
                </label>
            </div>
            <div class="layer-item" data-coverage="europe">
                <input type="checkbox" id="layerContours">
                <label for="layerContours">
                    <div class="layer-title">
                        Isobate (linee profondità)
                        <a href="https://emodnet.ec.europa.eu/en/bathymetry" target="_blank" class="info-link" title="Info EMODnet"><i class="fas fa-info-circle"></i></a>
                        <span class="coverage-badge europe">Europa</span>
                    </div>
                    <div class="layer-desc">Linee ravvicinate = pendenza ripida</div>
                </label>
            </div>
            </div><!-- /section-content -->
        </div>

        <!-- Fishing Layers Section -->
        <div class="sidebar-section collapsible collapsed" id="fishingSection">
            <h3 onclick="toggleSection('fishingSection')">
                <i class="fas fa-fish"></i>
                <span class="section-title-text">Layer Pesca Sportiva</span>
                <button class="help-btn" onclick="event.stopPropagation(); showHelp('fishing')" title="Guida">?</button>
                <span class="collapse-icon"><i class="fas fa-chevron-down"></i></span>
            </h3>
            <div class="section-content">
            <div class="layer-item" data-coverage="global">
                <input type="checkbox" id="layerSST">
                <label for="layerSST">
                    <div class="layer-title">
                        Temperatura Mare (SST)
                        <a href="https://coralreefwatch.noaa.gov/product/5km/index.php" target="_blank" class="info-link" title="Info NOAA SST"><i class="fas fa-info-circle"></i></a>
                        <span class="coverage-badge global">Globale</span>
                    </div>
                    <div class="layer-desc">Fondamentale per pelagici</div>
                </label>
            </div>
            <div class="layer-item" data-coverage="global">
                <input type="checkbox" id="layerChlorophyll">
                <label for="layerChlorophyll">
                    <div class="layer-title">
                        Clorofilla
                        <a href="https://marine.copernicus.eu/" target="_blank" class="info-link" title="Info Copernicus Marine"><i class="fas fa-info-circle"></i></a>
                        <span class="coverage-badge global">Globale</span>
                    </div>
                    <div class="layer-desc">Produttività = pesce foraggio</div>
                </label>
            </div>
            <div class="layer-item" data-coverage="global">
                <input type="checkbox" id="layerCurrents">
                <label for="layerCurrents">
                    <div class="layer-title">
                        Correnti Marine
                        <a href="https://marine.copernicus.eu/" target="_blank" class="info-link" title="Info Copernicus Marine"><i class="fas fa-info-circle"></i></a>
                        <span class="coverage-badge global">Globale</span>
                    </div>
                    <div class="layer-desc">Direzione e intensità</div>
                </label>
            </div>
            <div class="layer-item" data-coverage="global">
                <input type="checkbox" id="layerWaves">
                <label for="layerWaves">
                    <div class="layer-title">
                        Altezza Onde
                        <a href="https://marine.copernicus.eu/" target="_blank" class="info-link" title="Info Copernicus Marine"><i class="fas fa-info-circle"></i></a>
                        <span class="coverage-badge global">Globale</span>
                    </div>
                    <div class="layer-desc">Condizioni meteo marine</div>
                </label>
            </div>
            <div class="layer-item" data-coverage="global">
                <input type="checkbox" id="layerWinds">
                <label for="layerWinds">
                    <div class="layer-title">
                        Vento
                        <a href="https://openweathermap.org/api/weathermaps" target="_blank" class="info-link" title="Info OpenWeatherMap"><i class="fas fa-info-circle"></i></a>
                        <span class="coverage-badge global">Globale</span>
                    </div>
                    <div class="layer-desc">Direzione e velocità</div>
                </label>
            </div>
            </div><!-- /section-content -->
        </div>

        <!-- Base Layers Section -->
        <div class="sidebar-section collapsible collapsed" id="baseLayersSection">
            <h3 onclick="toggleSection('baseLayersSection')">
                <i class="fas fa-layer-group"></i>
                <span class="section-title-text">Layer Base</span>
                <button class="help-btn" onclick="event.stopPropagation(); showHelp('baseLayers')" title="Guida">?</button>
                <span class="collapse-icon"><i class="fas fa-chevron-down"></i></span>
            </h3>
            <div class="section-content">
            <div class="layer-item" data-coverage="global">
                <input type="checkbox" id="layerSeamarks" checked>
                <label for="layerSeamarks">
                    <div class="layer-title">
                        Segnali nautici
                        <a href="https://wiki.openseamap.org/wiki/OpenSeaMap-dev:Portal" target="_blank" class="info-link" title="Info OpenSeaMap"><i class="fas fa-info-circle"></i></a>
                        <span class="coverage-badge global">Globale</span>
                    </div>
                    <div class="layer-desc">Boe, fari, rotte</div>
                </label>
            </div>
            <div class="layer-item" data-coverage="global">
                <input type="checkbox" id="layerHarbours">
                <label for="layerHarbours">
                    <div class="layer-title">
                        Porti e marine
                        <a href="https://wiki.openseamap.org/wiki/OpenSeaMap-dev:Portal" target="_blank" class="info-link" title="Info OpenSeaMap"><i class="fas fa-info-circle"></i></a>
                        <span class="coverage-badge global">Globale</span>
                    </div>
                    <div class="layer-desc">Approdi e servizi</div>
                </label>
            </div>
            <div class="layer-item" data-coverage="global">
                <input type="checkbox" id="layerSatellite">
                <label for="layerSatellite">
                    <div class="layer-title">
                        Satellite
                        <a href="https://www.arcgis.com/home/item.html?id=10df2279f9684e4a9f6a7f08febac2a9" target="_blank" class="info-link" title="Info Esri Satellite"><i class="fas fa-info-circle"></i></a>
                        <span class="coverage-badge global">Globale</span>
                    </div>
                    <div class="layer-desc">Immagini satellitari</div>
                </label>
            </div>
            <div class="layer-item" data-coverage="europe">
                <input type="checkbox" id="layerMPA">
                <label for="layerMPA">
                    <div class="layer-title">
                        Aree Marine Protette
                        <a href="https://emodnet.ec.europa.eu/en/human-activities" target="_blank" class="info-link" title="Info EMODnet Human Activities"><i class="fas fa-info-circle"></i></a>
                        <span class="coverage-badge europe">Europa</span>
                    </div>
                    <div class="layer-desc">Zone con restrizioni pesca</div>
                </label>
            </div>
            </div><!-- /section-content -->
        </div>

        <!-- Display Controls Section -->
        <div class="sidebar-section collapsible collapsed" id="displaySection">
            <h3 onclick="toggleSection('displaySection')">
                <i class="fas fa-sliders-h"></i>
                <span class="section-title-text">Controlli Display</span>
                <button class="help-btn" onclick="event.stopPropagation(); showHelp('display')" title="Guida">?</button>
                <span class="collapse-icon"><i class="fas fa-chevron-down"></i></span>
            </h3>
            <div class="section-content">
            <div class="slider-control">
                <label>Opacità batimetria: <span id="opacityValue">40%</span></label>
                <input type="range" id="opacitySlider" min="0" max="100" value="40">
            </div>
            <div class="slider-control">
                <label>Luminosità mappa: <span id="brightnessValue">100%</span></label>
                <input type="range" id="brightnessSlider" min="50" max="200" value="100">
            </div>
            </div><!-- /section-content -->
        </div>

        <!-- Ruler Tool Section -->
        <div class="sidebar-section collapsible collapsed" id="rulerSection">
            <h3 onclick="toggleSection('rulerSection')">
                <i class="fas fa-ruler"></i>
                <span class="section-title-text">Righello</span>
                <button class="help-btn" onclick="event.stopPropagation(); showHelp('ruler')" title="Guida">?</button>
                <span class="collapse-icon"><i class="fas fa-chevron-down"></i></span>
            </h3>
            <div class="section-content">
            <div class="ruler-controls">
                <button id="rulerToggleBtn" class="ruler-btn primary" onclick="toggleRuler()">
                    <i class="fas fa-ruler"></i> Misura
                </button>
                <button id="rulerEditBtn" class="ruler-btn secondary" onclick="toggleEditMode()" style="display:none;">
                    <i class="fas fa-edit"></i> Modifica
                </button>
                <button class="ruler-btn secondary" onclick="clearRuler()">
                    <i class="fas fa-trash"></i> Pulisci
                </button>
            </div>
            <div id="rulerResult" class="ruler-result">
                <!-- Sezione Distanza (visibile durante misurazione lineare) -->
                <div id="rulerDistanceSection">
                    <div class="ruler-result-title"><i class="fas fa-route"></i> Distanza Totale</div>
                    <div class="ruler-distance">
                        <div class="ruler-value">
                            <span id="rulerNm" class="number">0.00</span>
                            <span class="unit">Miglia Nautiche</span>
                        </div>
                        <div class="ruler-value">
                            <span id="rulerKm" class="number">0.00</span>
                            <span class="unit">Chilometri</span>
                        </div>
                    </div>
                </div>
                <!-- Sezione Superficie (visibile per poligoni chiusi) -->
                <div id="rulerAreaSection" style="display: none;">
                    <div class="ruler-result-title"><i class="fas fa-vector-square"></i> Superficie Campo</div>
                    <div class="ruler-distance">
                        <div class="ruler-value">
                            <span id="rulerAreaNmSq" class="number">0.00</span>
                            <span class="unit">nm<sup>2</sup></span>
                        </div>
                        <div class="ruler-value">
                            <span id="rulerAreaKmSq" class="number">0.00</span>
                            <span class="unit">km<sup>2</sup></span>
                        </div>
                    </div>
                </div>
                <div id="rulerPoints" class="ruler-points">Clicca sulla mappa per aggiungere punti</div>
            </div>
            </div><!-- /section-content -->
        </div>

        <!-- Competition Field Section -->
        <div class="sidebar-section collapsible collapsed" id="zonesSection">
            <h3 onclick="toggleSection('zonesSection')">
                <i class="fas fa-trophy"></i>
                <span class="section-title-text">Campi di Gara</span>
                <button class="help-btn" onclick="event.stopPropagation(); showHelp('zones')" title="Guida">?</button>
                <span class="collapse-icon"><i class="fas fa-chevron-down"></i></span>
            </h3>
            <div class="section-content">

            <!-- Dropdown selezione campo -->
            <div style="margin-bottom: 10px;">
                <select id="zoneSelect" class="zone-select" onchange="onZoneSelectChange()">
                    <option value="">-- Seleziona campo --</option>
                </select>
            </div>

            <!-- Checkbox per mostrare/nascondere zona -->
            <div class="layer-control" style="margin-bottom: 10px;">
                <input type="checkbox" id="showZoneCheckbox" onchange="toggleZoneVisibility()">
                <label for="showZoneCheckbox">
                    <i class="fas fa-draw-polygon"></i> Mostra Zona Gara
                </label>
            </div>

            <!-- Azioni campo -->
            <div class="zone-actions" style="display: flex; gap: 6px; flex-wrap: wrap;">
                <button class="competition-field-btn" style="flex: 1; min-width: 70px;" onclick="goToSelectedZone()">
                    <i class="fas fa-location-arrow"></i> Vai
                </button>
                <button class="competition-field-btn" style="flex: 1; min-width: 70px; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);" onclick="editSelectedZone()">
                    <i class="fas fa-edit"></i> Modifica
                </button>
                <button class="competition-field-btn" style="flex: 1; min-width: 70px; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);" onclick="deleteSelectedZone()">
                    <i class="fas fa-trash"></i> Elimina
                </button>
                <button class="competition-field-btn" style="flex: 1; min-width: 70px; background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);" onclick="exportZonesData()">
                    <i class="fas fa-download"></i> Esporta
                </button>
            </div>

            <!-- Sposta Centro (per campi creati con centro+raggio) -->
            <div style="margin-top: 8px; display: flex; align-items: center; gap: 4px;">
                <button class="competition-field-btn" style="flex: 1; background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);" onclick="showEditCenterDialog()">
                    <i class="fas fa-crosshairs"></i> Sposta Centro
                </button>
                <button class="help-btn-inline" onclick="showHelp('editCenter')" title="Guida Sposta Centro">?</button>
            </div>

            <!-- Creazione nuovo campo -->
            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; gap: 4px;">
                <button class="competition-field-btn" style="flex: 1; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);" onclick="showCreateZoneDialog()">
                    <i class="fas fa-plus-circle"></i> Nuovo Campo (Centro + Raggio)
                </button>
                <button class="help-btn-inline" onclick="showHelp('createZone')" title="Guida Nuovo Campo">?</button>
            </div>

            <div id="competitionFieldContainer" style="display: none; margin-top: 10px;">
                <!-- Rendered by JavaScript -->
            </div>
            </div><!-- /section-content -->
        </div>

        <!-- GARE Section - Tournament Mode -->
        <div class="sidebar-section collapsible collapsed" id="tournamentSection">
            <h3 onclick="toggleSection('tournamentSection')">
                <i class="fas fa-trophy"></i>
                <span class="section-title-text">Gare</span>
                <button class="help-btn" onclick="event.stopPropagation(); showHelp('tournament')" title="Guida">?</button>
                <span class="collapse-icon"><i class="fas fa-chevron-down"></i></span>
            </h3>
            <div class="section-content">

            <!-- Info iniziale -->
            <div id="tournamentInfo" style="margin-bottom: 12px; padding: 10px; background: rgba(239,68,68,0.08); border-radius: 8px; border: 1px dashed rgba(239,68,68,0.3);">
                <p style="color: #94a3b8; font-size: 0.8rem; margin: 0 0 8px 0;">
                    <i class="fas fa-info-circle" style="color: #60a5fa;"></i>
                    Modalita competizione per tornei di pesca sportiva con registrazione rapida strike e rilasci.
                </p>
                <ul style="color: #64748b; font-size: 0.75rem; margin: 0; padding-left: 16px;">
                    <li>Seleziona un campo di gara obbligatorio</li>
                    <li>Pulsante STRIKE per registrazione istantanea</li>
                    <li>Allarme prossimita confini zona</li>
                    <li>Timer e statistiche in tempo reale</li>
                </ul>
            </div>

            <!-- AVVIA GARA BUTTON -->
            <button id="startTournamentBtn" onclick="toggleTournamentMode(true)" style="width: 100%; padding: 14px; font-size: 1rem; font-weight: bold; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; border: none; border-radius: 10px; cursor: pointer; margin-bottom: 12px; box-shadow: 0 4px 15px rgba(239,68,68,0.3); display: flex; align-items: center; justify-content: center; gap: 8px;">
                <i class="fas fa-play-circle"></i> Avvia Gara
            </button>

            <!-- TOURNAMENT ACTIVE PANEL (nascosto di default) -->
            <div id="tournamentPanel" style="display: none; padding: 12px; background: linear-gradient(145deg, rgba(239,68,68,0.15) 0%, rgba(234,88,12,0.1) 100%); border-radius: 10px; border: 1px solid rgba(239,68,68,0.4);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                    <span id="tournamentName" style="color: #fbbf24; font-weight: 600; font-size: 0.9rem;">
                        <i class="fas fa-trophy"></i> Torneo Attivo
                    </span>
                    <span id="tournamentTimer" style="color: #94a3b8; font-size: 0.75rem;">00:00:00</span>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <span id="tournamentZoneName" style="color: #60a5fa; font-size: 0.75rem;">
                        <i class="fas fa-map-marker-alt"></i> Campo di Gara
                    </span>
                    <span id="proximityIndicator" style="font-size: 0.7rem; color: #94a3b8;">
                        <i class="fas fa-satellite-dish"></i> GPS...
                    </span>
                </div>

                <!-- PULSANTE STRIKE GRANDE -->
                <button id="strikeBtn" onclick="registerQuickStrike()" style="width: 100%; padding: 16px; font-size: 1.2rem; font-weight: bold; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; border: none; border-radius: 10px; cursor: pointer; margin-bottom: 10px; box-shadow: 0 4px 15px rgba(239,68,68,0.4); transition: transform 0.1s;">
                    <i class="fas fa-bolt"></i> STRIKE!
                </button>

                <!-- Strike counter -->
                <div style="display: flex; justify-content: space-around; text-align: center; margin-bottom: 10px;">
                    <div>
                        <div id="tournamentStrikes" style="font-size: 1.5rem; font-weight: bold; color: #f59e0b;">0</div>
                        <div style="font-size: 0.7rem; color: #94a3b8;">Strike</div>
                    </div>
                    <div>
                        <div id="tournamentReleases" style="font-size: 1.5rem; font-weight: bold; color: #22c55e;">0</div>
                        <div style="font-size: 0.7rem; color: #94a3b8;">Rilasci</div>
                    </div>
                </div>

                <!-- Lista strike torneo -->
                <div id="tournamentCatchList" style="max-height: 150px; overflow-y: auto; margin-bottom: 10px;">
                    <div style="color: #64748b; font-size: 0.8rem; text-align: center; padding: 10px;">
                        Premi STRIKE! per registrare
                    </div>
                </div>

                <!-- Termina torneo -->
                <button onclick="endTournament()" style="width: 100%; padding: 8px; font-size: 0.85rem; background: linear-gradient(135deg, #64748b 0%, #475569 100%); color: white; border: none; border-radius: 6px; cursor: pointer;">
                    <i class="fas fa-flag-checkered"></i> Termina Gara
                </button>
            </div>

            </div><!-- /section-content -->
        </div>

        <!-- Catch Log Section -->
        <div class="sidebar-section collapsible collapsed" id="catchLogSection">
            <h3 onclick="toggleSection('catchLogSection')">
                <i class="fas fa-fish"></i>
                <span class="section-title-text">Catch Log</span>
                <button class="help-btn" onclick="event.stopPropagation(); showHelp('catchLog')" title="Guida">?</button>
                <span class="collapse-icon"><i class="fas fa-chevron-down"></i></span>
            </h3>
            <div class="section-content">

            <!-- Pulsanti Segna Punto (modalita normale) -->
            <div id="normalCatchControls" class="catch-controls" style="display: flex; gap: 6px; margin-bottom: 10px; align-items: center;">
                <button id="catchModeBtn" class="ruler-btn primary" onclick="toggleCatchMode()" style="flex: 1;">
                    <i class="fas fa-map-marker-alt"></i> Segna
                </button>
                <button class="ruler-btn secondary" onclick="useCurrentGPS()" style="flex: 1;">
                    <i class="fas fa-location-arrow"></i> GPS
                </button>
                <button class="help-btn-inline" onclick="showHelp('catchMark')" title="Guida Segna Punto">?</button>
            </div>

            <!-- Statistiche giornata -->
            <div id="catchStats" class="catch-stats">
                <div class="catch-stat-item">
                    <span class="stat-number" id="todayCount">0</span>
                    <span class="stat-label">Oggi</span>
                </div>
                <div class="catch-stat-item">
                    <span class="stat-number" id="totalCount">0</span>
                    <span class="stat-label">Totale</span>
                </div>
            </div>

            <!-- Filtri -->
            <div class="catch-filters" style="margin-top: 10px;">
                <select id="catchFilterType" class="zone-select" onchange="applyCatchFilters()" style="margin-bottom: 6px;">
                    <option value="all">Tutti i tipi</option>
                    <option value="strike">Strike</option>
                    <option value="release">Rilascio</option>
                    <option value="sighting">Avvistamento</option>
                    <option value="weighed_catch">Cattura Pesata</option>
                </select>
                <select id="catchFilterSpecies" class="zone-select" onchange="applyCatchFilters()">
                    <option value="all">Tutte le specie</option>
                </select>
            </div>

            <!-- Lista catture scrollabile -->
            <div id="catchListContainer" class="catch-list-container">
                <div class="catch-list-empty">
                    <i class="fas fa-fish"></i>
                    <p>Nessuna cattura registrata</p>
                    <small>Clicca "Registra" e poi sulla mappa</small>
                </div>
            </div>

            <!-- Azioni Export -->
            <div class="catch-export-actions" style="margin-top: 10px; display: flex; gap: 6px;">
                <button class="competition-field-btn" style="flex: 1; background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);" onclick="exportCatchesJSON()">
                    <i class="fas fa-download"></i> JSON
                </button>
                <button class="competition-field-btn" style="flex: 1; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);" onclick="exportCatchesCSV()">
                    <i class="fas fa-file-csv"></i> CSV
                </button>
            </div>
            </div><!-- /section-content -->
        </div>

        <!-- GPS Tracking Section - Collapsible -->
        <div class="sidebar-section collapsible collapsed" id="gpsTrackingSection">
            <h3 onclick="toggleSection('gpsTrackingSection')">
                <i class="fas fa-ship"></i>
                <span class="section-title-text">GPS Tracking</span>
                <button class="help-btn" onclick="event.stopPropagation(); showHelp('gpsTracking')" title="Guida">?</button>
                <span class="collapse-icon"><i class="fas fa-chevron-down"></i></span>
            </h3>
            <div class="section-content">
                <!-- Switch Tracking On/Off -->
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                    <span style="color: #e2e8f0; font-size: 0.9rem;">
                        <i class="fas fa-satellite-dish"></i> Tracking Attivo
                    </span>
                    <label class="tracking-switch">
                        <input type="checkbox" id="gpsTrackingSwitch" onchange="toggleGpsTracking(this.checked)">
                        <span class="tracking-slider"></span>
                    </label>
                </div>

                <!-- Demo Navigation Button -->
                <div style="margin-bottom: 12px;">
                    <button id="demoNavigationBtn" class="competition-field-btn" style="width: 100%; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); font-size: 0.8rem; padding: 8px;" onclick="startDemoNavigation()">
                        <i class="fas fa-play-circle"></i> Demo Navigazione Live
                    </button>
                </div>

                <!-- Colore Traccia -->
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <span style="color: #94a3b8; font-size: 0.85rem;">
                        <i class="fas fa-palette"></i> Colore traccia
                    </span>
                    <input type="color" id="trackColorPicker" value="#22c55e"
                           onchange="changeTrackColor(this.value)"
                           style="width: 36px; height: 28px; border: none; border-radius: 4px; cursor: pointer; background: transparent;">
                </div>

                <!-- GPS Stats -->
                <div class="gps-stats" id="gpsStats" style="display: none;">
                    <div class="gps-stat-item">
                        <div class="gps-stat-value" id="gpsSpeed">0.0</div>
                        <div class="gps-stat-label">Velocità (kn)</div>
                    </div>
                    <div class="gps-stat-item">
                        <div class="gps-stat-value" id="gpsHeading">--</div>
                        <div class="gps-stat-label">Direzione</div>
                    </div>
                    <div class="gps-stat-item">
                        <div class="gps-stat-value" id="gpsDistance">0.00</div>
                        <div class="gps-stat-label">Distanza (nm)</div>
                    </div>
                    <div class="gps-stat-item">
                        <div class="gps-stat-value" id="gpsDuration">00:00</div>
                        <div class="gps-stat-label">Durata</div>
                    </div>
                    <div class="gps-stat-item full-width">
                        <div class="gps-stat-value" id="gpsCoords" style="font-size: 0.9rem;">--</div>
                        <div class="gps-stat-label">Coordinate Correnti</div>
                    </div>
                </div>

                <!-- Tracking Controls -->
                <div id="trackingControls" style="display: none; margin-top: 10px;">
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        <button id="pauseTrackingBtn" class="competition-field-btn" style="flex: 1; min-width: 80px; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);" onclick="togglePauseTracking()">
                            <i class="fas fa-pause"></i> Pausa
                        </button>
                        <button class="competition-field-btn" style="flex: 1; min-width: 80px; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);" onclick="stopAndClearTracking()">
                            <i class="fas fa-trash"></i> Cancella
                        </button>
                    </div>
                    <div style="display: flex; gap: 4px; margin-top: 6px; align-items: center;">
                        <button class="competition-field-btn" style="flex: 1; background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);" onclick="showSaveRouteDialog()">
                            <i class="fas fa-save"></i> Salva Rotta
                        </button>
                        <button class="help-btn-inline" onclick="showHelp('routeSave')" title="Guida Salvataggio Rotta">?</button>
                    </div>
                </div>

                <!-- Saved Routes -->
                <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                        <span style="color: #94a3b8; font-size: 0.85rem;"><i class="fas fa-route"></i> Rotte Salvate</span>
                        <span id="routeCount" style="color: #64748b; font-size: 0.75rem;">0 rotte</span>
                    </div>
                    <!-- Quick Actions -->
                    <div style="display: flex; gap: 6px; margin-bottom: 8px;">
                        <button class="competition-field-btn" style="flex: 1; background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); font-size: 0.75rem; padding: 6px;" onclick="showAllRoutes()">
                            <i class="fas fa-eye"></i> Mostra Tutte
                        </button>
                        <button class="competition-field-btn" style="flex: 1; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); font-size: 0.75rem; padding: 6px;" onclick="hideAllRoutes()">
                            <i class="fas fa-eye-slash"></i> Nascondi
                        </button>
                    </div>
                    <div class="route-list" id="routeList">
                        <div style="color: #64748b; font-size: 0.8rem; text-align: center; padding: 10px;">
                            Nessuna rotta salvata
                        </div>
                    </div>
                    <!-- Export All Routes -->
                    <div style="display: flex; gap: 6px; margin-top: 8px; align-items: center;">
                        <button class="competition-field-btn" style="flex: 1; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); font-size: 0.8rem; padding: 6px 8px;" onclick="exportAllRoutesGPX()">
                            <i class="fas fa-download"></i> GPX
                        </button>
                        <button class="competition-field-btn" style="flex: 1; background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%); font-size: 0.8rem; padding: 6px 8px;" onclick="exportAllRoutesGeoJSON()">
                            <i class="fas fa-download"></i> GeoJSON
                        </button>
                        <button class="help-btn-inline" onclick="showHelp('routeExport')" title="Guida Export Rotte">?</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Legend Section -->
        <div class="sidebar-section collapsible collapsed" id="legendSection">
            <h3 onclick="toggleSection('legendSection')">
                <i class="fas fa-palette"></i>
                <span class="section-title-text">Legende</span>
                <button class="help-btn" onclick="event.stopPropagation(); showHelp('legend')" title="Guida">?</button>
                <span class="collapse-icon"><i class="fas fa-chevron-down"></i></span>
            </h3>
            <div class="section-content">

            <!-- Depth Legend -->
            <div style="margin-bottom: 12px;">
                <div style="font-size: 0.8rem; color: #94a3b8; margin-bottom: 6px;"><i class="fas fa-water"></i> Profondità</div>
                <div class="legend-grid">
                    <div class="legend-item"><div class="legend-color" style="background: #f8e0e0;"></div> 0-50m</div>
                    <div class="legend-item"><div class="legend-color" style="background: #cef4f2;"></div> 50-100m</div>
                    <div class="legend-item"><div class="legend-color" style="background: #a3e0dc;"></div> 100-200m</div>
                    <div class="legend-item"><div class="legend-color" style="background: #7bc8c4;"></div> 200-500m</div>
                    <div class="legend-item"><div class="legend-color" style="background: #54a8a3;"></div> 500-1000m</div>
                    <div class="legend-item"><div class="legend-color" style="background: #3d8a85;"></div> 1000-2000m</div>
                    <div class="legend-item"><div class="legend-color" style="background: #286b67;"></div> 2000-4000m</div>
                    <div class="legend-item"><div class="legend-color" style="background: #1a4d4a;"></div> >4000m</div>
                </div>
            </div>

            <!-- SST Legend -->
            <div style="margin-bottom: 12px;">
                <div style="font-size: 0.8rem; color: #94a3b8; margin-bottom: 6px;"><i class="fas fa-thermometer-half"></i> Temperatura Mare (SST)</div>
                <div class="legend-grid">
                    <div class="legend-item"><div class="legend-color" style="background: #313695;"></div> &lt;18°C</div>
                    <div class="legend-item"><div class="legend-color" style="background: #4575b4;"></div> 18-20°C</div>
                    <div class="legend-item"><div class="legend-color" style="background: #74add1;"></div> 20-22°C</div>
                    <div class="legend-item"><div class="legend-color" style="background: #abd9e9;"></div> 22-24°C</div>
                    <div class="legend-item"><div class="legend-color" style="background: #fee090;"></div> 24-26°C</div>
                    <div class="legend-item"><div class="legend-color" style="background: #fdae61;"></div> 26-28°C</div>
                    <div class="legend-item"><div class="legend-color" style="background: #f46d43;"></div> 28-30°C</div>
                    <div class="legend-item"><div class="legend-color" style="background: #d73027;"></div> >30°C</div>
                </div>
            </div>

            <!-- Chlorophyll Legend -->
            <div>
                <div style="font-size: 0.8rem; color: #94a3b8; margin-bottom: 6px;"><i class="fas fa-leaf"></i> Clorofilla (produttività)</div>
                <div class="legend-grid">
                    <div class="legend-item"><div class="legend-color" style="background: #440154;"></div> Bassa</div>
                    <div class="legend-item"><div class="legend-color" style="background: #31688e;"></div> Media-Bassa</div>
                    <div class="legend-item"><div class="legend-color" style="background: #35b779;"></div> Media</div>
                    <div class="legend-item"><div class="legend-color" style="background: #fde725;"></div> Alta</div>
                </div>
            </div>
            </div><!-- /section-content -->
        </div>

        <!-- Info Section -->
        <div class="sidebar-section collapsible collapsed" id="positionSection">
            <h3 onclick="toggleSection('positionSection')">
                <i class="fas fa-info-circle"></i>
                <span class="section-title-text">Posizione Corrente</span>
                <button class="help-btn" onclick="event.stopPropagation(); showHelp('position')" title="Guida">?</button>
                <span class="collapse-icon"><i class="fas fa-chevron-down"></i></span>
            </h3>
            <div class="section-content">
            <div class="info-row">
                <span class="label">Centro:</span>
                <span class="value" id="currentCoords">-</span>
            </div>
            <div class="info-row">
                <span class="label">Zoom:</span>
                <span class="value" id="currentZoom">-</span>
            </div>
            <div class="info-row">
                <span class="label">Luogo:</span>
                <span class="value" id="currentPlace">-</span>
            </div>
            </div><!-- /section-content -->
        </div>

    </div>

    <!-- Toggle sidebar button -->
    <button class="toggle-sidebar" id="toggleSidebar" onclick="toggleSidebar()">
        <i class="fas fa-chevron-left" id="toggleIcon"></i>
    </button>

    <!-- Map -->
    <div id="map"></div>

    <!-- Mirino Centrale -->
    <div id="mapCrosshair">
        <div class="crosshair-h"></div>
        <div class="crosshair-v"></div>
        <div class="crosshair-dot"></div>
    </div>

    <!-- Rosa dei Venti -->
    <div id="compassRose" onclick="resetMapNorth()" title="Nord in alto (click per resettare)">
        <svg viewBox="0 0 100 100">
            <!-- Cerchio sfondo -->
            <circle cx="50" cy="50" r="48" fill="rgba(15,23,42,0.85)" stroke="rgba(125,211,252,0.5)" stroke-width="1"/>
            <!-- Punta Nord (rossa) -->
            <polygon points="50,8 56,45 50,40 44,45" fill="#ef4444"/>
            <!-- Punta Sud (bianca) -->
            <polygon points="50,92 56,55 50,60 44,55" fill="#e2e8f0"/>
            <!-- Punta Est -->
            <polygon points="92,50 55,44 60,50 55,56" fill="#94a3b8"/>
            <!-- Punta Ovest -->
            <polygon points="8,50 45,44 40,50 45,56" fill="#94a3b8"/>
            <!-- Cerchio centrale -->
            <circle cx="50" cy="50" r="6" fill="#1e293b" stroke="rgba(125,211,252,0.8)" stroke-width="1"/>
            <!-- Lettere cardinali -->
            <text x="50" y="22" text-anchor="middle" fill="#ef4444" font-size="10" font-weight="bold">N</text>
            <text x="50" y="84" text-anchor="middle" fill="#94a3b8" font-size="8">S</text>
            <text x="84" y="53" text-anchor="middle" fill="#94a3b8" font-size="8">E</text>
            <text x="16" y="53" text-anchor="middle" fill="#94a3b8" font-size="8">W</text>
        </svg>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Help Popup Overlay -->
    <div class="help-popup-overlay" id="helpPopupOverlay" onclick="if(event.target===this) closeHelp()">
        <div class="help-popup">
            <div class="help-popup-header">
                <h3><i class="fas fa-question-circle"></i> <span id="helpPopupTitle">Guida</span></h3>
                <button class="help-popup-close" onclick="closeHelp()"><i class="fas fa-times"></i></button>
            </div>
            <div class="help-popup-content" id="helpPopupContent">
                <!-- Content populated by JavaScript -->
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="zones_data.js"></script>
    <script>
        // Initialize map - default to Ischia, Italia
        const map = L.map('map', {
            center: [40.7300, 13.9000],
            zoom: 11,
            zoomControl: false
        });

        // Add zoom control to bottom right
        L.control.zoom({ position: 'bottomright' }).addTo(map);

        // Base layer - OpenStreetMap
        const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap'
        }).addTo(map);

        // Satellite layer (Esri)
        const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: '© Esri'
        });

        // ============================================
        // BATHYMETRY LAYERS
        // ============================================

        // EMODnet Bathymetry - Standard resolution (opacity ridotta per non coprire troppo)
        const bathyLayer = L.tileLayer.wms('https://ows.emodnet-bathymetry.eu/wms', {
            layers: 'emodnet:mean_multicolour',
            format: 'image/png',
            transparent: true,
            opacity: 0.4,
            attribution: '© EMODnet Bathymetry'
        }).addTo(map);

        // EMODnet High Resolution Bathymetry
        const bathyHRLayer = L.tileLayer.wms('https://ows.emodnet-bathymetry.eu/wms', {
            layers: 'emodnet:mean_rainbowcolour',
            format: 'image/png',
            transparent: true,
            opacity: 0.4,
            attribution: '© EMODnet HR'
        });

        // GEBCO Global Bathymetry WMS - Official GEBCO 2024 Grid (most authoritative global data)
        // WMS endpoint: https://wms.gebco.net/mapserv?
        // Available layers: gebco_latest (shaded relief), gebco_latest_2 (flat color-coded)
        const gebcoLayer = L.tileLayer.wms('https://wms.gebco.net/mapserv?', {
            layers: 'gebco_latest',
            format: 'image/png',
            transparent: true,
            opacity: 0.5,
            attribution: '© <a href="https://www.gebco.net">GEBCO</a> 2024 Grid'
        });

        // NOAA BlueTopo - High-precision US coastal/submarine bathymetry (navigational grade)
        // WMTS endpoint: https://nowcoast.noaa.gov/geoserver/gwc/service/wmts
        // Used by US Navy for submarine navigation - extremely accurate
        const blueTopo = L.tileLayer('https://nowcoast.noaa.gov/geoserver/gwc/service/wmts?layer=bluetopo:hillshade&style=&tilematrixset=EPSG:3857&Service=WMTS&Request=GetTile&Version=1.0.0&Format=image/png&TileMatrix=EPSG:3857:{z}&TileCol={x}&TileRow={y}', {
            attribution: '© <a href="https://nauticalcharts.noaa.gov/data/bluetopo.html">NOAA BlueTopo</a>',
            opacity: 0.6,
            maxZoom: 18
        });

        // CartoDB Voyager - Nice base map with ocean coloring (CORS-friendly)
        const cartoVoyagerLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
            attribution: '© CartoDB',
            subdomains: 'abcd',
            opacity: 0.9
        });

        // Esri World Ocean Base - Global bathymetry tiles
        // maxNativeZoom: 9 means zoom 9 tiles will be scaled up for higher zoom levels
        const esriOceanLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}', {
            attribution: '© Esri, GEBCO, NOAA',
            opacity: 0.5,
            maxNativeZoom: 9,
            maxZoom: 18,
            className: 'esri-ocean-tiles'
        });

        // Ocean Reference overlay - CartoDB labels (no auth required)
        const oceanRefLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_only_labels/{z}/{x}/{y}{r}.png', {
            attribution: '© CartoDB',
            subdomains: 'abcd',
            opacity: 1
        });

        // Depth contours (isobaths)
        const contoursLayer = L.tileLayer.wms('https://ows.emodnet-bathymetry.eu/wms', {
            layers: 'emodnet:contours',
            format: 'image/png',
            transparent: true,
            opacity: 0.8
        });


        // ============================================
        // FISHING / OCEANOGRAPHIC LAYERS
        // ============================================

        // Sea Surface Temperature (SST) - NOAA Coral Reef Watch
        const sstLayer = L.tileLayer.wms('https://pae-paha.pacioos.hawaii.edu/thredds/wms/dhw_5km', {
            layers: 'CRW_SST',
            format: 'image/png',
            transparent: true,
            opacity: 0.6,
            attribution: '© NOAA Coral Reef Watch',
            styles: 'boxfill/sst_36'
        });

        // Chlorophyll concentration (phytoplankton = baitfish presence)
        const chlorophyllLayer = L.tileLayer.wms('https://nrt.cmems-du.eu/thredds/wms/dataset-oc-glo-bio-multi-l4-chl_4km_monthly-rep', {
            layers: 'CHL',
            format: 'image/png',
            transparent: true,
            opacity: 0.5,
            attribution: '© Copernicus Marine'
        });

        // Ocean currents direction and speed
        const currentsLayer = L.tileLayer.wms('https://nrt.cmems-du.eu/thredds/wms/cmems_mod_glo_phy_anfc_0.083deg_PT1H-m', {
            layers: 'uo',
            format: 'image/png',
            transparent: true,
            opacity: 0.5,
            attribution: '© Copernicus Marine'
        });

        // Wave height
        const wavesLayer = L.tileLayer.wms('https://nrt.cmems-du.eu/thredds/wms/cmems_mod_glo_wav_anfc_0.083deg_PT3H-i', {
            layers: 'VHM0',
            format: 'image/png',
            transparent: true,
            opacity: 0.5,
            attribution: '© Copernicus Marine'
        });

        // Wind layer (OpenWeatherMap style)
        const windsLayer = L.tileLayer('https://tile.openweathermap.org/map/wind_new/{z}/{x}/{y}.png?appid=9de243494c0b295cca9337e1e96b00e2', {
            attribution: '© OpenWeatherMap',
            opacity: 0.6
        });

        // ============================================
        // BASE / NAVIGATION LAYERS
        // ============================================

        // OpenSeaMap seamark layer
        const seamarkLayer = L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
            attribution: '© OpenSeaMap',
            opacity: 0.9
        }).addTo(map);

        // OpenSeaMap harbours layer
        const harboursLayer = L.tileLayer('https://tiles.openseamap.org/harbours/{z}/{x}/{y}.png', {
            attribution: '© OpenSeaMap',
            opacity: 0.9
        });

        // Marine Protected Areas (EMODnet Human Activities) - Europe only
        const mpaLayer = L.tileLayer.wms('https://ows.emodnet-humanactivities.eu/wms', {
            layers: 'emodnet:natura2000areas',
            format: 'image/png',
            transparent: true,
            opacity: 0.5,
            attribution: '© EMODnet Human Activities'
        });

        // Marine Protected Areas Global (WDPA via Protected Planet)
        // Note: WDPA doesn't allow direct WMS redistribution, so we use a reference link
        // For actual data, users should visit protectedplanet.net
        const mpaGlobalLayer = null; // Placeholder - redirect to Protected Planet

        // ============================================
        // LAYER TOGGLE HANDLERS
        // ============================================

        // Helper function for simple layer toggle
        function setupLayerToggle(checkboxId, layer) {
            const checkbox = document.getElementById(checkboxId);
            if (checkbox) {
                checkbox.addEventListener('change', (e) => {
                    if (e.target.checked) map.addLayer(layer);
                    else map.removeLayer(layer);
                });
            }
        }

        // Bathymetry layers
        setupLayerToggle('layerBathy', bathyLayer);
        setupLayerToggle('layerBathyHR', bathyHRLayer);
        setupLayerToggle('layerGEBCO', gebcoLayer);
        setupLayerToggle('layerBlueTopo', blueTopo);
        setupLayerToggle('layerETOPO', esriOceanLayer);
        setupLayerToggle('layerOceanRef', oceanRefLayer);
        setupLayerToggle('layerContours', contoursLayer);

        // Fishing/oceanographic layers
        setupLayerToggle('layerSST', sstLayer);
        setupLayerToggle('layerChlorophyll', chlorophyllLayer);
        setupLayerToggle('layerCurrents', currentsLayer);
        setupLayerToggle('layerWaves', wavesLayer);
        setupLayerToggle('layerWinds', windsLayer);

        // Base/navigation layers
        setupLayerToggle('layerSeamarks', seamarkLayer);
        setupLayerToggle('layerHarbours', harboursLayer);
        setupLayerToggle('layerMPA', mpaLayer);

        // Satellite layer (special handling - replaces base layer)
        document.getElementById('layerSatellite').addEventListener('change', (e) => {
            if (e.target.checked) {
                map.removeLayer(osmLayer);
                map.addLayer(satelliteLayer);
            } else {
                map.removeLayer(satelliteLayer);
                map.addLayer(osmLayer);
            }
        });

        // ============================================
        // COVERAGE DETECTION & TOAST NOTIFICATIONS
        // ============================================

        // Europe bounding box (approximate)
        const EUROPE_BOUNDS = {
            north: 72,   // Iceland/Norway
            south: 27,   // North Africa coast
            west: -32,   // Azores
            east: 45     // Urals
        };

        // Check if current map center is in Europe
        function isInEurope() {
            const center = map.getCenter();
            return center.lat >= EUROPE_BOUNDS.south &&
                   center.lat <= EUROPE_BOUNDS.north &&
                   center.lng >= EUROPE_BOUNDS.west &&
                   center.lng <= EUROPE_BOUNDS.east;
        }

        // Show toast notification
        function showToast(title, message, type = 'warning', duration = 5000) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <button class="toast-close" onclick="this.parentElement.remove()">&times;</button>
                <div class="toast-header">
                    <i class="fas ${type === 'warning' ? 'fa-exclamation-triangle' : 'fa-info-circle'} toast-icon"></i>
                    <span class="toast-title">${title}</span>
                </div>
                <div class="toast-message">${message}</div>
            `;
            container.appendChild(toast);

            // Auto-remove after duration
            setTimeout(() => {
                if (toast.parentElement) {
                    toast.style.animation = 'slideIn 0.3s ease reverse';
                    setTimeout(() => toast.remove(), 300);
                }
            }, duration);
        }

        // Layer names for toast messages
        const layerNames = {
            'layerBathy': 'EMODnet Batimetria',
            'layerBathyHR': 'Alta Risoluzione (HR)',
            'layerContours': 'Isobate',
            'layerMPA': 'Aree Marine Protette',
            'layerBlueTopo': 'NOAA BlueTopo'
        };

        // USA bounding box (continental + Hawaii + Alaska coasts)
        const USA_BOUNDS = {
            continental: { north: 49, south: 24, west: -125, east: -66 },
            alaska: { north: 72, south: 51, west: -180, east: -129 },
            hawaii: { north: 23, south: 18, west: -162, east: -154 }
        };

        function isInUSA() {
            const center = map.getCenter();
            const lat = center.lat;
            const lng = center.lng;

            // Check continental USA
            if (lat >= USA_BOUNDS.continental.south && lat <= USA_BOUNDS.continental.north &&
                lng >= USA_BOUNDS.continental.west && lng <= USA_BOUNDS.continental.east) {
                return true;
            }
            // Check Alaska
            if (lat >= USA_BOUNDS.alaska.south && lat <= USA_BOUNDS.alaska.north &&
                lng >= USA_BOUNDS.alaska.west && lng <= USA_BOUNDS.alaska.east) {
                return true;
            }
            // Check Hawaii
            if (lat >= USA_BOUNDS.hawaii.south && lat <= USA_BOUNDS.hawaii.north &&
                lng >= USA_BOUNDS.hawaii.west && lng <= USA_BOUNDS.hawaii.east) {
                return true;
            }
            return false;
        }

        // Enhanced layer toggle with coverage check
        function setupLayerToggleWithCoverage(checkboxId, layer) {
            const checkbox = document.getElementById(checkboxId);
            const layerItem = checkbox.closest('.layer-item');
            const coverage = layerItem?.dataset.coverage;

            if (checkbox) {
                checkbox.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        map.addLayer(layer);

                        // Check coverage for Europe-only layers
                        if (coverage === 'europe' && !isInEurope()) {
                            const layerName = layerNames[checkboxId] || checkboxId;
                            showToast(
                                'Copertura limitata',
                                `<strong>${layerName}</strong> copre solo l'Europa.<br><br>Per copertura globale usa:<br>• <strong>GEBCO 2024 WMS</strong> o <strong>Esri Ocean Base</strong>`,
                                'warning',
                                6000
                            );
                        }

                        // Check coverage for USA-only layers
                        if (coverage === 'usa' && !isInUSA()) {
                            const layerName = layerNames[checkboxId] || checkboxId;
                            showToast(
                                'Copertura USA',
                                `<strong>${layerName}</strong> copre solo le coste USA (continentale, Alaska, Hawaii).<br><br>Per precisione navale, questa è la fonte più accurata per acque USA.`,
                                'info',
                                6000
                            );
                        }
                    } else {
                        map.removeLayer(layer);
                    }
                });
            }
        }

        // Re-setup coverage-limited layers with coverage check
        // (Override the simple toggles set earlier)
        setupLayerToggleWithCoverage('layerBathy', bathyLayer);
        setupLayerToggleWithCoverage('layerBathyHR', bathyHRLayer);
        setupLayerToggleWithCoverage('layerContours', contoursLayer);
        setupLayerToggleWithCoverage('layerMPA', mpaLayer);
        setupLayerToggleWithCoverage('layerBlueTopo', blueTopo);

        // Check coverage when map moves (debounced)
        let coverageCheckTimeout;
        map.on('moveend', () => {
            clearTimeout(coverageCheckTimeout);
            coverageCheckTimeout = setTimeout(checkActiveLayers, 500);
        });

        // Check active Europe-only layers when moving out of Europe
        let lastInEurope = isInEurope();
        function checkActiveLayers() {
            const currentInEurope = isInEurope();

            // When leaving Europe, auto-switch to global layers
            if (lastInEurope && !currentInEurope) {
                let switched = false;

                // Check if EMODnet Batimetria is active
                const bathyCheckbox = document.getElementById('layerBathy');
                if (bathyCheckbox && bathyCheckbox.checked) {
                    // Disable EMODnet
                    bathyCheckbox.checked = false;
                    map.removeLayer(bathyLayer);

                    // Enable Esri Ocean Base
                    const esriCheckbox = document.getElementById('layerETOPO');
                    if (esriCheckbox && !esriCheckbox.checked) {
                        esriCheckbox.checked = true;
                        map.addLayer(esriOceanLayer);
                    }
                    switched = true;
                }

                // Check if EMODnet HR is active
                const hrCheckbox = document.getElementById('layerBathyHR');
                if (hrCheckbox && hrCheckbox.checked) {
                    hrCheckbox.checked = false;
                    map.removeLayer(bathyHRLayer);
                    switched = true;
                }

                // Check if Isobate is active
                const contoursCheckbox = document.getElementById('layerContours');
                if (contoursCheckbox && contoursCheckbox.checked) {
                    contoursCheckbox.checked = false;
                    map.removeLayer(contoursLayer);
                    switched = true;
                }

                // Check if MPA is active
                const mpaCheckbox = document.getElementById('layerMPA');
                if (mpaCheckbox && mpaCheckbox.checked) {
                    mpaCheckbox.checked = false;
                    map.removeLayer(mpaLayer);
                    switched = true;
                }

                if (switched) {
                    showToast(
                        'Layer adattati alla zona',
                        `Passato automaticamente a <strong>Esri Ocean Base</strong> (copertura globale).<br><br>Layer non disponibili fuori Europa:<br>• Isobate (usa GEBCO Global come alternativa)<br>• Aree Marine Protette → <a href="https://www.protectedplanet.net/en/thematic-areas/marine-protected-areas" target="_blank" style="color:#7dd3fc">Protected Planet</a>`,
                        'info',
                        8000
                    );
                }
            }

            // When entering Europe, could optionally switch back to EMODnet (higher quality)
            if (!lastInEurope && currentInEurope) {
                const esriCheckbox = document.getElementById('layerETOPO');
                const bathyCheckbox = document.getElementById('layerBathy');

                // If Esri is active and EMODnet is not, suggest switching
                if (esriCheckbox?.checked && !bathyCheckbox?.checked) {
                    showToast(
                        'Zona Europa rilevata',
                        `Puoi attivare <strong>EMODnet Batimetria</strong> per maggiore dettaglio in Europa.`,
                        'info',
                        5000
                    );
                }
            }

            lastInEurope = currentInEurope;
        }

        // Opacity slider - applies to bathymetry color layers (not slope/contours)
        document.getElementById('opacitySlider').addEventListener('input', (e) => {
            const opacity = e.target.value / 100;
            bathyLayer.setOpacity(opacity);
            bathyHRLayer.setOpacity(opacity);
            gebcoLayer.setOpacity(opacity);
            esriOceanLayer.setOpacity(opacity);
            document.getElementById('opacityValue').textContent = e.target.value + '%';
        });

        // Brightness slider
        document.getElementById('brightnessSlider').addEventListener('input', (e) => {
            const brightness = e.target.value / 100;
            document.getElementById('map').style.filter = `brightness(${brightness})`;
            document.getElementById('brightnessValue').textContent = e.target.value + '%';
        });

        // Toggle sidebar function
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const toggleBtn = document.getElementById('toggleSidebar');
            const toggleIcon = document.getElementById('toggleIcon');
            const mapEl = document.getElementById('map');
            const isMobile = window.innerWidth <= 768;

            // Toggle both classes for desktop/mobile compatibility
            sidebar.classList.toggle('collapsed');
            sidebar.classList.toggle('open');

            const isHidden = sidebar.classList.contains('collapsed');

            if (isHidden) {
                toggleBtn.style.left = '0';
                if (!isMobile) mapEl.style.left = '0';
                toggleIcon.classList.remove('fa-chevron-left');
                toggleIcon.classList.add('fa-chevron-right');
            } else {
                toggleBtn.style.left = isMobile ? '280px' : '320px';
                if (!isMobile) mapEl.style.left = '320px';
                toggleIcon.classList.remove('fa-chevron-right');
                toggleIcon.classList.add('fa-chevron-left');
            }

            // Invalidate map size to fix tile rendering
            setTimeout(() => map.invalidateSize(), 300);
        }

        // Update info panel on map move
        map.on('moveend', updateInfoPanel);
        map.on('zoomend', updateInfoPanel);

        function updateInfoPanel() {
            const center = map.getCenter();
            document.getElementById('currentCoords').textContent =
                `${center.lat.toFixed(4)}, ${center.lng.toFixed(4)}`;
            document.getElementById('currentZoom').textContent = map.getZoom();
        }

        // Search location using Nominatim
        let searchTimeout;
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');

        searchInput.addEventListener('input', () => {
            clearTimeout(searchTimeout);
            const query = searchInput.value.trim();

            if (query.length < 3) {
                searchResults.classList.remove('show');
                return;
            }

            searchTimeout = setTimeout(() => {
                fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5`)
                    .then(res => res.json())
                    .then(data => {
                        if (data.length > 0) {
                            searchResults.innerHTML = data.map(item => `
                                <div class="search-result-item" onclick="selectSearchResult(${item.lat}, ${item.lon}, '${item.display_name.replace(/'/g, "\\'")}')">
                                    <div class="name">${item.display_name.split(',').slice(0, 2).join(', ')}</div>
                                    <div class="type">${item.type} - ${item.display_name.split(',').slice(2, 4).join(', ')}</div>
                                </div>
                            `).join('');
                            searchResults.classList.add('show');
                        } else {
                            searchResults.classList.remove('show');
                        }
                    })
                    .catch(err => console.error('Search error:', err));
            }, 300);
        });

        // Close search results when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-input-wrapper')) {
                searchResults.classList.remove('show');
            }
        });

        function selectSearchResult(lat, lng, name) {
            searchInput.value = name.split(',')[0];
            searchResults.classList.remove('show');
            goToPlace(lat, lng, name);
        }

        function searchLocation() {
            const query = searchInput.value.trim();
            if (!query) return;

            fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`)
                .then(res => res.json())
                .then(data => {
                    if (data.length > 0) {
                        goToPlace(parseFloat(data[0].lat), parseFloat(data[0].lon), data[0].display_name);
                    } else {
                        alert('Luogo non trovato. Prova con un nome diverso.');
                    }
                })
                .catch(err => {
                    console.error('Search error:', err);
                    alert('Errore nella ricerca. Riprova.');
                });
        }

        // Enter key to search
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchResults.classList.remove('show');
                searchLocation();
            }
        });

        function goToCoordinates() {
            const lat = parseFloat(document.getElementById('latInput').value);
            const lng = parseFloat(document.getElementById('lngInput').value);

            if (isNaN(lat) || isNaN(lng)) {
                alert('Inserisci coordinate valide (es. Lat: 40.7300, Lng: 13.9000)');
                return;
            }

            if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                alert('Coordinate fuori range. Lat: -90 a 90, Lng: -180 a 180');
                return;
            }

            map.flyTo([lat, lng], 12, { duration: 2 });
            addMarker(lat, lng, `Coordinate: ${lat.toFixed(4)}, ${lng.toFixed(4)}`);
        }

        function goToPlace(lat, lng, name) {
            map.flyTo([lat, lng], 11, { duration: 2 });
            document.getElementById('currentPlace').textContent = name.split(',').slice(0, 2).join(', ');
            document.getElementById('latInput').value = lat.toFixed(6);
            document.getElementById('lngInput').value = lng.toFixed(6);
            addMarker(lat, lng, name);
        }

        let currentMarker = null;

        function addMarker(lat, lng, name) {
            if (currentMarker) {
                map.removeLayer(currentMarker);
            }

            currentMarker = L.marker([lat, lng])
                .addTo(map)
                .bindPopup(`<strong>${name.split(',')[0]}</strong><br>
                           Lat: ${lat.toFixed(4)}<br>
                           Lng: ${lng.toFixed(4)}`)
                .openPopup();
        }

        // Hide loading overlay
        window.addEventListener('load', () => {
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 1000);
        });

        // Initial info panel update
        updateInfoPanel();

        // Set initial place name
        document.getElementById('currentPlace').textContent = 'Ischia, Italia';
        document.getElementById('latInput').value = '40.730000';
        document.getElementById('lngInput').value = '13.900000';

        // Add initial marker for Ischia
        addMarker(40.7300, 13.9000, 'Ischia, Italia');

        // ============================================
        // FAVORITE PLACES MANAGEMENT
        // ============================================

        // Default places (cannot be deleted)
        const defaultPlaces = [
            { id: 'quepos', name: 'Quepos', fullName: 'Quepos, Costa Rica', lat: 9.4318, lng: -84.1621, icon: 'fa-fish' },
            { id: 'ischia', name: 'Ischia', fullName: 'Ischia, Italia', lat: 40.7300, lng: 13.9000, icon: 'fa-anchor' },
            { id: 'forio-biggame', name: 'Big Game Forio', fullName: 'Punto Raduno Big Game Forio 2026', lat: 40.72481667, lng: 13.69851667, icon: 'fa-trophy' }
        ];

        // Current searched place (for saving)
        let currentSearchedPlace = null;

        // Load saved places from localStorage
        function getSavedPlaces() {
            const saved = localStorage.getItem('bathyExplorerFavorites');
            return saved ? JSON.parse(saved) : [];
        }

        // Save places to localStorage
        function savePlacesToStorage(places) {
            localStorage.setItem('bathyExplorerFavorites', JSON.stringify(places));
        }

        // Render all places (default + saved)
        function renderFavoritePlaces() {
            const container = document.getElementById('quickLinksContainer');
            const savedPlaces = getSavedPlaces();

            let html = '';

            // Render default places (no delete button)
            defaultPlaces.forEach(place => {
                html += `
                    <button class="quick-link-btn" onclick="goToPlace(${place.lat}, ${place.lng}, '${place.fullName}')">
                        <i class="fas ${place.icon}"></i> ${place.name}
                    </button>
                `;
            });

            // Render saved places (with delete button)
            savedPlaces.forEach((place, index) => {
                html += `
                    <button class="quick-link-btn saved" onclick="goToPlace(${place.lat}, ${place.lng}, '${place.fullName.replace(/'/g, "\\'")}')">
                        <i class="fas fa-map-marker-alt"></i> ${place.name}
                        <span class="delete-btn" onclick="event.stopPropagation(); deleteFavoritePlace(${index})" title="Elimina">
                            <i class="fas fa-times"></i>
                        </span>
                    </button>
                `;
            });

            container.innerHTML = html;
        }

        // Save current searched place to favorites
        function saveCurrentToFavorites() {
            if (!currentSearchedPlace) return;

            const savedPlaces = getSavedPlaces();

            // Check if already exists
            const exists = savedPlaces.some(p =>
                p.lat === currentSearchedPlace.lat && p.lng === currentSearchedPlace.lng
            ) || defaultPlaces.some(p =>
                p.lat === currentSearchedPlace.lat && p.lng === currentSearchedPlace.lng
            );

            if (exists) {
                alert('Questo luogo e gia nei preferiti!');
                return;
            }

            // Add to saved places
            savedPlaces.push(currentSearchedPlace);
            savePlacesToStorage(savedPlaces);

            // Update UI
            renderFavoritePlaces();

            // Update button state
            const btn = document.getElementById('saveFavoriteBtn');
            btn.classList.add('saved');
            btn.innerHTML = '<i class="fas fa-check"></i> Salvato!';

            // Reset button after 2 seconds
            setTimeout(() => {
                btn.classList.remove('saved', 'show');
                btn.innerHTML = '<i class="fas fa-star"></i> Salva nei preferiti';
                currentSearchedPlace = null;
            }, 2000);
        }

        // Delete a saved place
        function deleteFavoritePlace(index) {
            if (!confirm('Eliminare questo luogo dai preferiti?')) return;

            const savedPlaces = getSavedPlaces();
            savedPlaces.splice(index, 1);
            savePlacesToStorage(savedPlaces);
            renderFavoritePlaces();
        }

        // Update goToPlace to track current place for saving
        const originalGoToPlace = goToPlace;
        goToPlace = function(lat, lng, name) {
            originalGoToPlace(lat, lng, name);

            // Set current searched place
            const shortName = name.split(',')[0].trim();
            currentSearchedPlace = {
                name: shortName,
                fullName: name,
                lat: parseFloat(lat),
                lng: parseFloat(lng)
            };

            // Check if already in favorites
            const savedPlaces = getSavedPlaces();
            const alreadySaved = savedPlaces.some(p =>
                Math.abs(p.lat - lat) < 0.001 && Math.abs(p.lng - lng) < 0.001
            ) || defaultPlaces.some(p =>
                Math.abs(p.lat - lat) < 0.001 && Math.abs(p.lng - lng) < 0.001
            );

            // Show or hide save button
            const btn = document.getElementById('saveFavoriteBtn');
            if (alreadySaved) {
                btn.classList.remove('show');
            } else {
                btn.classList.remove('saved');
                btn.innerHTML = '<i class="fas fa-star"></i> Salva nei preferiti';
                btn.classList.add('show');
            }
        };

        // Initial render of favorite places
        renderFavoritePlaces();

        // ============================================
        // COMPETITION FIELD MANAGEMENT
        // ============================================

        let competitionFieldMarker = null;

        // Load competition field from localStorage
        function getCompetitionField() {
            const saved = localStorage.getItem('bathyExplorerCompetitionField');
            return saved ? JSON.parse(saved) : null;
        }

        // Save competition field to localStorage
        function saveCompetitionFieldToStorage(field) {
            localStorage.setItem('bathyExplorerCompetitionField', JSON.stringify(field));
        }

        // Clear competition field from localStorage
        function clearCompetitionFieldFromStorage() {
            localStorage.removeItem('bathyExplorerCompetitionField');
        }

        // Set competition field from current map center or input coordinates
        function setCompetitionField() {
            const lat = parseFloat(document.getElementById('latInput').value);
            const lng = parseFloat(document.getElementById('lngInput').value);

            if (isNaN(lat) || isNaN(lng)) {
                alert('Inserisci prima le coordinate GPS o cerca un luogo.');
                return;
            }

            // Prompt for field name
            const fieldName = prompt('Nome del campo di gara:', 'Campo di Gara');
            if (!fieldName) return;

            const field = {
                name: fieldName,
                lat: lat,
                lng: lng,
                setAt: new Date().toISOString()
            };

            saveCompetitionFieldToStorage(field);
            renderCompetitionField();
            addCompetitionFieldMarker(field);

            showToast(
                'Campo di Gara impostato',
                `<strong>${fieldName}</strong> salvato alle coordinate ${lat.toFixed(4)}, ${lng.toFixed(4)}`,
                'info',
                4000
            );
        }

        // Render competition field in sidebar
        function renderCompetitionField() {
            const container = document.getElementById('competitionFieldContainer');
            const field = getCompetitionField();

            if (!field) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';
            container.innerHTML = `
                <div class="competition-field-info">
                    <div class="field-name"><i class="fas fa-trophy"></i> ${field.name}</div>
                    <div class="field-coords">${field.lat.toFixed(6)}, ${field.lng.toFixed(6)}</div>
                </div>
                <div class="competition-field-actions">
                    <button class="goto-btn" onclick="goToCompetitionField()">
                        <i class="fas fa-location-arrow"></i> Vai
                    </button>
                    <button class="clear-btn" onclick="clearCompetitionField()">
                        <i class="fas fa-trash"></i> Rimuovi
                    </button>
                </div>
            `;

            // Add marker if not already on map
            addCompetitionFieldMarker(field);
        }

        // Go to competition field
        function goToCompetitionField() {
            const field = getCompetitionField();
            if (!field) return;

            map.flyTo([field.lat, field.lng], 13, { duration: 2 });
        }

        // Clear competition field
        function clearCompetitionField() {
            if (!confirm('Rimuovere il campo di gara?')) return;

            if (competitionFieldMarker) {
                map.removeLayer(competitionFieldMarker);
                competitionFieldMarker = null;
            }

            clearCompetitionFieldFromStorage();
            renderCompetitionField();

            showToast(
                'Campo di Gara rimosso',
                'Il campo di gara e stato rimosso dalla mappa.',
                'info',
                3000
            );
        }

        // Add competition field marker to map
        function addCompetitionFieldMarker(field) {
            // Remove existing marker
            if (competitionFieldMarker) {
                map.removeLayer(competitionFieldMarker);
            }

            // Create custom icon
            const competitionIcon = L.divIcon({
                className: 'competition-marker-wrapper',
                html: '<div class="competition-marker-icon"><i class="fas fa-trophy"></i></div>',
                iconSize: [30, 30],
                iconAnchor: [15, 15],
                popupAnchor: [0, -15]
            });

            // Add marker
            competitionFieldMarker = L.marker([field.lat, field.lng], { icon: competitionIcon })
                .addTo(map)
                .bindPopup(`
                    <strong><i class="fas fa-trophy"></i> ${field.name}</strong><br>
                    <span style="font-family: monospace;">Lat: ${field.lat.toFixed(6)}</span><br>
                    <span style="font-family: monospace;">Lng: ${field.lng.toFixed(6)}</span>
                `);
        }

        // Initial render of competition field (if saved)
        renderCompetitionField();

        // ============================================
        // CAMPI DI GARA - Gestione Zone Tornei
        // Dati caricati da zones_data.js (portabile)
        // ============================================

        let zonePolygon = null;
        let gatheringMarker = null;
        let zoneCenterMarker = null;  // Marker centro geometrico (cliccabile per editing)
        let selectedZoneId = null;

        // Converte ZONES_DATA array in oggetto per lookup veloce
        function getZonesMap() {
            const zonesMap = {};
            if (typeof ZONES_DATA !== 'undefined') {
                ZONES_DATA.forEach(zone => {
                    zonesMap[zone.id] = zone;
                });
            }
            return zonesMap;
        }

        // ============================================
        // PERSISTENZA ZONE UTENTE (localStorage)
        // ============================================

        // Carica zone utente dal localStorage
        function loadUserZones() {
            const saved = localStorage.getItem('bathyExplorerUserZones');
            if (saved) {
                const userZones = JSON.parse(saved);
                userZones.forEach(zone => {
                    if (!ZONES_DATA.find(z => z.id === zone.id)) {
                        ZONES_DATA.push(zone);
                    }
                });
            }
        }

        // Salva zone utente nel localStorage
        function saveUserZones() {
            const userZones = ZONES_DATA.filter(z => z.isUserCreated === true);
            localStorage.setItem('bathyExplorerUserZones', JSON.stringify(userZones));
        }

        // Elimina zona selezionata
        function deleteSelectedZone() {
            const select = document.getElementById('zoneSelect');
            const zoneId = select.value;

            if (!zoneId) {
                showToast('Errore', 'Seleziona un campo da eliminare', 'warning', 2000);
                return;
            }

            const zone = ZONES_DATA.find(z => z.id === zoneId);
            if (!zone) {
                showToast('Errore', 'Campo non trovato', 'danger', 2000);
                return;
            }

            if (!confirm(`Vuoi eliminare il campo "${zone.name}"?

Questa azione non puo essere annullata.`)) {
                return;
            }

            // Se siamo in editing su questa zona, esci dall'editing
            if (editingCenterZoneId === zoneId) {
                clearCenterEditMarker(true);
                if (directEditPanel) {
                    directEditPanel.remove();
                    directEditPanel = null;
                }
            }

            // Rimuovi tutti i marker dalla mappa
            clearTournamentZone();

            const index = ZONES_DATA.findIndex(z => z.id === zoneId);
            if (index > -1) {
                ZONES_DATA.splice(index, 1);
            }

            saveUserZones();
            populateZoneSelect();
            select.value = '';

            showToast('Eliminato', `Campo "${zone.name}" rimosso`, 'success', 2000);
        }

        // Popola il dropdown con i campi di gara
        function populateZoneSelect() {
            const select = document.getElementById('zoneSelect');
            if (!select) return;

            // Rimuovi opzioni esistenti tranne la prima
            while (select.options.length > 1) {
                select.remove(1);
            }

            // Aggiungi zone dal file esterno
            if (typeof ZONES_DATA !== 'undefined') {
                ZONES_DATA.forEach(zone => {
                    const option = document.createElement('option');
                    option.value = zone.id;
                    option.textContent = `${zone.tournament} ${zone.year}`;
                    select.appendChild(option);
                });
            }
        }

        // Quando cambia la selezione nel dropdown
        function onZoneSelectChange() {
            const select = document.getElementById('zoneSelect');
            const checkbox = document.getElementById('showZoneCheckbox');

            selectedZoneId = select.value;

            if (selectedZoneId && checkbox.checked) {
                drawTournamentZone(selectedZoneId);
            }
        }

        // Draw tournament zone on map
        function drawTournamentZone(zoneId) {
            const zonesMap = getZonesMap();
            const zone = zonesMap[zoneId];
            if (!zone) return;

            // Remove existing zone
            clearTournamentZone();

            // Draw polygon
            const latlngs = zone.vertices.map(v => [v.lat, v.lng]);
            zonePolygon = L.polygon(latlngs, {
                color: zone.color,
                weight: 3,
                opacity: 0.8,
                fillColor: zone.color,
                fillOpacity: 0,
                dashArray: '10, 5'
            }).addTo(map);

            zonePolygon.bindPopup(`
                <strong><i class="fas fa-trophy"></i> ${zone.name}</strong><br>
                <em>${zone.tournament} ${zone.year}</em><br>
                <small>Clicca sui vertici per le coordinate</small>
            `);

            // Passa click alla mappa se catchLogActive
            zonePolygon.on('click', function(e) {
                if (catchLogActive) {
                    L.DomEvent.stopPropagation(e);
                    quickSaveCatch(e.latlng.lat, e.latlng.lng, 'manual');
                    showToast('Punto segnato!', 'Clicca nella lista per completare i dati', 'info', 3000);
                }
                // Altrimenti comportamento normale (popup)
            });

            // Add gathering point marker (solo se esiste)
            if (zone.gatheringPoint) {
                const gatherIcon = L.divIcon({
                    className: 'gathering-marker-wrapper',
                    html: '<div class="competition-marker-icon" style="background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);"><i class="fas fa-flag"></i></div>',
                    iconSize: [30, 30],
                    iconAnchor: [15, 15],
                    popupAnchor: [0, -15]
                });

                gatheringMarker = L.marker([zone.gatheringPoint.lat, zone.gatheringPoint.lng], { icon: gatherIcon })
                    .addTo(map)
                    .bindPopup(`
                        <strong><i class="fas fa-flag"></i> ${zone.gatheringPoint.name}</strong><br>
                        <span style="font-family: monospace;">${zone.gatheringPoint.lat.toFixed(6)}, ${zone.gatheringPoint.lng.toFixed(6)}</span>
                    `);
            }

            // Se la zona ha centerMeta, aggiungi marker centro geometrico cliccabile
            if (zone.centerMeta) {
                const centerIcon = L.divIcon({
                    className: 'zone-center-marker',
                    html: `<div style="
                        background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
                        width: 28px;
                        height: 28px;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        box-shadow: 0 3px 10px rgba(139, 92, 246, 0.5);
                        border: 2px solid white;
                        cursor: pointer;
                    "><i class="fas fa-crosshairs" style="color: white; font-size: 12px;"></i></div>`,
                    iconSize: [28, 28],
                    iconAnchor: [14, 14]
                });

                zoneCenterMarker = L.marker([zone.centerMeta.lat, zone.centerMeta.lng], { icon: centerIcon })
                    .addTo(map)
                    .bindTooltip('Clicca per modificare il campo', {
                        permanent: false,
                        direction: 'top',
                        offset: [0, -15]
                    });

                // Click sul centro per abilitare editing
                zoneCenterMarker.on('click', function(e) {
                    L.DomEvent.stopPropagation(e);
                    enableDirectCenterDrag(zone);
                });
            }

            // Update selected zone
            selectedZoneId = zoneId;

            // Mostra superficie della zona
            showZoneArea(zone);

            showToast(
                'Zona di Gara caricata',
                `<strong>${zone.name}</strong><br>${zone.tournament} ${zone.year}`,
                'info',
                4000
            );
        }

        // Clear tournament zone from map
        function clearTournamentZone() {
            if (zonePolygon) {
                map.removeLayer(zonePolygon);
                zonePolygon = null;
            }
            if (gatheringMarker) {
                map.removeLayer(gatheringMarker);
                gatheringMarker = null;
            }
            if (zoneCenterMarker) {
                map.removeLayer(zoneCenterMarker);
                zoneCenterMarker = null;
            }
        }

        // Toggle zone visibility via checkbox
        function toggleZoneVisibility() {
            const checkbox = document.getElementById('showZoneCheckbox');
            const select = document.getElementById('zoneSelect');

            if (checkbox.checked) {
                // Usa zona selezionata o la prima disponibile
                const zoneId = select.value || (ZONES_DATA && ZONES_DATA[0] ? ZONES_DATA[0].id : null);
                if (zoneId) {
                    select.value = zoneId;
                    drawTournamentZone(zoneId);
                    // Fit to zone
                    if (zonePolygon) {
                        map.fitBounds(zonePolygon.getBounds(), { padding: [50, 50] });
                    }
                } else {
                    showToast('Nessun campo', 'Nessun campo di gara disponibile', 'warning', 3000);
                    checkbox.checked = false;
                }
            } else {
                clearTournamentZone();
            }
        }

        // Vai al campo selezionato
        function goToSelectedZone() {
            const select = document.getElementById('zoneSelect');
            const checkbox = document.getElementById('showZoneCheckbox');
            const zoneId = select.value;

            if (!zoneId) {
                showToast('Seleziona campo', 'Seleziona un campo di gara dal menu', 'warning', 3000);
                return;
            }

            const zonesMap = getZonesMap();
            const zone = zonesMap[zoneId];

            if (zone) {
                // Attiva checkbox se non attivo
                if (!checkbox.checked) {
                    checkbox.checked = true;
                }
                drawTournamentZone(zoneId);
                map.fitBounds(zonePolygon.getBounds(), { padding: [50, 50] });
            }
        }

        // Esporta dati zone in JSON
        function exportZonesData() {
            if (typeof ZONES_DATA === 'undefined' || ZONES_DATA.length === 0) {
                showToast('Nessun dato', 'Nessun campo di gara da esportare', 'warning', 3000);
                return;
            }

            const dataStr = JSON.stringify(ZONES_DATA, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'zones_data_export.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showToast('Export completato', `${ZONES_DATA.length} campi esportati`, 'success', 3000);
        }

        // ============================================
        // UTILITY: DIALOG SPOSTABILI (DRAGGABLE)
        // ============================================

        // Rende un dialog spostabile trascinando l'header
        function makeDraggable(dialogElement, headerElement) {
            let isDragging = false;
            let offsetX = 0;
            let offsetY = 0;
            let dragInitialized = false;

            headerElement.style.cursor = 'move';
            headerElement.style.userSelect = 'none';

            headerElement.addEventListener('mousedown', function(e) {
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;

                isDragging = true;
                const rect = dialogElement.getBoundingClientRect();

                // Prima volta: configura posizionamento fisso
                if (!dragInitialized) {
                    // Disabilita flex centering dell'overlay parent
                    const parent = dialogElement.parentElement;
                    if (parent) {
                        parent.style.display = 'block';
                    }
                    dialogElement.style.position = 'fixed';
                    dialogElement.style.margin = '0';
                    dragInitialized = true;
                }

                dialogElement.style.left = rect.left + 'px';
                dialogElement.style.top = rect.top + 'px';

                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;

                e.preventDefault();
            });

            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;

                let newX = e.clientX - offsetX;
                let newY = e.clientY - offsetY;

                // Limita ai bordi dello schermo
                const rect = dialogElement.getBoundingClientRect();
                newX = Math.max(0, Math.min(newX, window.innerWidth - rect.width));
                newY = Math.max(0, Math.min(newY, window.innerHeight - rect.height));

                dialogElement.style.left = newX + 'px';
                dialogElement.style.top = newY + 'px';
            });

            document.addEventListener('mouseup', function() {
                isDragging = false;
            });
        }

        // ============================================
        // CREAZIONE CAMPO DA CENTRO + RAGGIO
        // Genera poligono circolare da coordinate e raggio
        // ============================================

        // Mostra dialog per creare nuovo campo da centro + raggio
        function showCreateZoneDialog() {
            // Usa centro mappa come default
            const center = map.getCenter();

            // Crea overlay
            const overlay = document.createElement('div');
            overlay.id = 'createZoneOverlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); z-index: 10000;
                display: flex; align-items: center; justify-content: center;
            `;

            overlay.innerHTML = `
                <div id="createZoneDialog" style="background: #1e293b; border-radius: 12px; padding: 25px; max-width: 400px; width: 90%; color: white; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
                    <h3 id="createZoneDialogHeader" style="margin: 0 0 20px 0; color: #8b5cf6; display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-arrows-alt" style="font-size: 0.8em; opacity: 0.6;"></i>
                        <i class="fas fa-plus-circle"></i> Nuovo Campo di Gara
                    </h3>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #94a3b8; font-size: 0.9em;">Nome Campo *</label>
                        <input type="text" id="newZoneName" placeholder="es. Offshore Championship 2026"
                               style="width: 100%; padding: 10px; border: 1px solid #475569; border-radius: 6px; background: #0f172a; color: white; font-size: 1em;">
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #94a3b8; font-size: 0.9em;">Torneo</label>
                        <input type="text" id="newZoneTournament" placeholder="es. Bisbee's Costa Rica"
                               style="width: 100%; padding: 10px; border: 1px solid #475569; border-radius: 6px; background: #0f172a; color: white; font-size: 1em;">
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #94a3b8; font-size: 0.9em;">Latitudine Centro</label>
                            <input type="number" id="newZoneLat" value="${center.lat.toFixed(6)}" step="0.000001"
                                   style="width: 100%; padding: 10px; border: 1px solid #475569; border-radius: 6px; background: #0f172a; color: white; font-size: 1em;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #94a3b8; font-size: 0.9em;">Longitudine Centro</label>
                            <input type="number" id="newZoneLng" value="${center.lng.toFixed(6)}" step="0.000001"
                                   style="width: 100%; padding: 10px; border: 1px solid #475569; border-radius: 6px; background: #0f172a; color: white; font-size: 1em;">
                        </div>
                    </div>
                    <button onclick="selectCenterFromMap()" style="
                        width: 100%; padding: 10px; margin-bottom: 15px;
                        background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
                        color: white; border: none; border-radius: 6px;
                        cursor: pointer; font-size: 0.9em; font-weight: 600;
                        display: flex; align-items: center; justify-content: center; gap: 8px;
                    ">
                        <i class="fas fa-map-marker-alt"></i> Seleziona sulla mappa
                    </button>

                    <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 10px; margin-bottom: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #94a3b8; font-size: 0.9em;">Raggio</label>
                            <input type="number" id="newZoneRadius" value="50" min="1" max="500" step="1"
                                   style="width: 100%; padding: 10px; border: 1px solid #475569; border-radius: 6px; background: #0f172a; color: white; font-size: 1em;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #94a3b8; font-size: 0.9em;">Unita</label>
                            <select id="newZoneUnit" style="width: 100%; padding: 10px; border: 1px solid #475569; border-radius: 6px; background: #0f172a; color: white; font-size: 1em;">
                                <option value="nm" selected>Miglia (nm)</option>
                                <option value="km">Km</option>
                            </select>
                        </div>
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #94a3b8; font-size: 0.9em;">Tipo Zona</label>
                        <select id="newZoneType" style="width: 100%; padding: 10px; border: 1px solid #475569; border-radius: 6px; background: #0f172a; color: white; font-size: 1em;">
                            <option value="circle" selected>Cerchio completo (360°)</option>
                            <option value="semicircle_north">Semicerchio nord (180°)</option>
                            <option value="semicircle_south">Semicerchio sud (180°)</option>
                            <option value="semicircle_east">Semicerchio est (180°)</option>
                            <option value="semicircle_west">Semicerchio ovest (180°)</option>
                            <option value="square">Quadrato</option>
                            <option value="rectangle_ns">Rettangolo (N-S allungato)</option>
                            <option value="rectangle_ew">Rettangolo (E-O allungato)</option>
                            <option value="triangle_north">Triangolo (punta a nord)</option>
                            <option value="triangle_south">Triangolo (punta a sud)</option>
                        </select>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; color: #94a3b8; font-size: 0.9em;">Colore</label>
                        <input type="color" id="newZoneColor" value="#8b5cf6"
                               style="width: 60px; height: 36px; border: none; border-radius: 6px; cursor: pointer;">
                    </div>

                    <div style="display: flex; gap: 10px;">
                        <button onclick="createZoneFromDialog()" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">
                            <i class="fas fa-check"></i> Crea Campo
                        </button>
                        <button onclick="document.getElementById('createZoneOverlay').remove()" style="flex: 1; padding: 12px; background: #475569; color: white; border: none; border-radius: 8px; cursor: pointer;">
                            Annulla
                        </button>
                    </div>

                    <p style="margin-top: 15px; font-size: 0.85em; color: #64748b; text-align: center;">
                        <i class="fas fa-info-circle"></i> Scegli la forma che meglio si adatta alla zona di gara
                    </p>
                </div>
            `;

            document.body.appendChild(overlay);

            // Rendi il dialog spostabile
            const dialog = document.getElementById('createZoneDialog');
            const header = document.getElementById('createZoneDialogHeader');
            if (dialog && header) {
                makeDraggable(dialog, header);
            }

            document.getElementById('newZoneName').focus();
        }

        // Genera poligono dato centro, raggio e tipo
        function generateCirclePolygon(centerLat, centerLng, radiusNm, type = 'circle', numPoints = 36) {
            const vertices = [];
            const radiusKm = radiusNm * 1.852; // Converti nm in km
            const latOffset = radiusKm / 111.32;
            const lngOffset = radiusKm / (111.32 * Math.cos(centerLat * Math.PI / 180));

            // Gestisci forme geometriche
            switch(type) {
                case 'square':
                    // Quadrato: 4 vertici
                    vertices.push({ lat: centerLat + latOffset, lng: centerLng - lngOffset }); // NW
                    vertices.push({ lat: centerLat + latOffset, lng: centerLng + lngOffset }); // NE
                    vertices.push({ lat: centerLat - latOffset, lng: centerLng + lngOffset }); // SE
                    vertices.push({ lat: centerLat - latOffset, lng: centerLng - lngOffset }); // SW
                    break;

                case 'rectangle_ns':
                    // Rettangolo allungato Nord-Sud (2x altezza)
                    vertices.push({ lat: centerLat + latOffset * 1.5, lng: centerLng - lngOffset * 0.75 }); // NW
                    vertices.push({ lat: centerLat + latOffset * 1.5, lng: centerLng + lngOffset * 0.75 }); // NE
                    vertices.push({ lat: centerLat - latOffset * 1.5, lng: centerLng + lngOffset * 0.75 }); // SE
                    vertices.push({ lat: centerLat - latOffset * 1.5, lng: centerLng - lngOffset * 0.75 }); // SW
                    break;

                case 'rectangle_ew':
                    // Rettangolo allungato Est-Ovest (2x larghezza)
                    vertices.push({ lat: centerLat + latOffset * 0.75, lng: centerLng - lngOffset * 1.5 }); // NW
                    vertices.push({ lat: centerLat + latOffset * 0.75, lng: centerLng + lngOffset * 1.5 }); // NE
                    vertices.push({ lat: centerLat - latOffset * 0.75, lng: centerLng + lngOffset * 1.5 }); // SE
                    vertices.push({ lat: centerLat - latOffset * 0.75, lng: centerLng - lngOffset * 1.5 }); // SW
                    break;

                case 'triangle_north':
                    // Triangolo con punta a nord
                    vertices.push({ lat: centerLat + latOffset, lng: centerLng }); // Punta N
                    vertices.push({ lat: centerLat - latOffset, lng: centerLng + lngOffset }); // SE
                    vertices.push({ lat: centerLat - latOffset, lng: centerLng - lngOffset }); // SW
                    break;

                case 'triangle_south':
                    // Triangolo con punta a sud
                    vertices.push({ lat: centerLat + latOffset, lng: centerLng - lngOffset }); // NW
                    vertices.push({ lat: centerLat + latOffset, lng: centerLng + lngOffset }); // NE
                    vertices.push({ lat: centerLat - latOffset, lng: centerLng }); // Punta S
                    break;

                case 'semicircle_north':
                    // Semicerchio verso nord (da ovest a est passando per nord)
                    for (let i = 0; i <= 18; i++) {
                        const angle = 180 + (180 * i / 18); // 180° -> 360°
                        const angleRad = angle * Math.PI / 180;
                        const lat = centerLat + latOffset * Math.cos(angleRad);
                        const lng = centerLng + lngOffset * Math.sin(angleRad);
                        vertices.push({ lat: parseFloat(lat.toFixed(6)), lng: parseFloat(lng.toFixed(6)) });
                    }
                    vertices.push({ lat: centerLat, lng: centerLng }); // Centro per chiudere
                    break;

                case 'semicircle_south':
                    // Semicerchio verso sud (da est a ovest passando per sud)
                    for (let i = 0; i <= 18; i++) {
                        const angle = 0 + (180 * i / 18); // 0° -> 180°
                        const angleRad = angle * Math.PI / 180;
                        const lat = centerLat + latOffset * Math.cos(angleRad);
                        const lng = centerLng + lngOffset * Math.sin(angleRad);
                        vertices.push({ lat: parseFloat(lat.toFixed(6)), lng: parseFloat(lng.toFixed(6)) });
                    }
                    vertices.push({ lat: centerLat, lng: centerLng }); // Centro per chiudere
                    break;

                case 'semicircle_east':
                    // Semicerchio verso est (da nord a sud passando per est)
                    for (let i = 0; i <= 18; i++) {
                        const angle = 270 + (180 * i / 18); // 270° -> 450° (90°)
                        const angleRad = angle * Math.PI / 180;
                        const lat = centerLat + latOffset * Math.cos(angleRad);
                        const lng = centerLng + lngOffset * Math.sin(angleRad);
                        vertices.push({ lat: parseFloat(lat.toFixed(6)), lng: parseFloat(lng.toFixed(6)) });
                    }
                    vertices.push({ lat: centerLat, lng: centerLng }); // Centro per chiudere
                    break;

                case 'semicircle_west':
                case 'semicircle_ocean':
                    // Semicerchio verso ovest (da sud a nord passando per ovest)
                    for (let i = 0; i <= 18; i++) {
                        const angle = 90 + (180 * i / 18); // 90° -> 270°
                        const angleRad = angle * Math.PI / 180;
                        const lat = centerLat + latOffset * Math.cos(angleRad);
                        const lng = centerLng + lngOffset * Math.sin(angleRad);
                        vertices.push({ lat: parseFloat(lat.toFixed(6)), lng: parseFloat(lng.toFixed(6)) });
                    }
                    vertices.push({ lat: centerLat, lng: centerLng }); // Centro per chiudere
                    break;

                default:
                    // Cerchio completo
                    for (let i = 0; i < numPoints; i++) {
                        const angle = (360 * i / numPoints);
                        const angleRad = angle * Math.PI / 180;
                        const lat = centerLat + latOffset * Math.cos(angleRad);
                        const lng = centerLng + lngOffset * Math.sin(angleRad);
                        vertices.push({ lat: parseFloat(lat.toFixed(6)), lng: parseFloat(lng.toFixed(6)) });
                    }
            }

            // Arrotonda coordinate per forme geometriche
            return vertices.map(v => ({
                lat: parseFloat(v.lat.toFixed(6)),
                lng: parseFloat(v.lng.toFixed(6))
            }));
        }

        // Variabile per salvare dati form durante selezione mappa
        var pendingZoneFormData = null;

        // Seleziona centro cliccando sulla mappa
        function selectCenterFromMap() {
            // Salva valori correnti del form
            pendingZoneFormData = {
                name: document.getElementById('newZoneName').value,
                tournament: document.getElementById('newZoneTournament').value,
                radius: document.getElementById('newZoneRadius').value,
                unit: document.getElementById('newZoneUnit').value,
                type: document.getElementById('newZoneType').value,
                color: document.getElementById('newZoneColor').value
            };

            // Chiudi dialog
            const overlay = document.getElementById('createZoneOverlay');
            if (overlay) overlay.remove();

            // Mostra istruzioni
            showToast('Seleziona centro', 'Clicca sulla mappa per posizionare il centro del campo', 'info', 5000);

            // Cambia cursore
            document.getElementById('map').style.cursor = 'crosshair';

            // Handler click sulla mappa (one-shot)
            function handleMapClick(e) {
                // Rimuovi handler
                map.off('click', handleMapClick);
                document.getElementById('map').style.cursor = '';

                // Riapri dialog con coordinate selezionate
                reopenCreateZoneDialog(e.latlng.lat, e.latlng.lng);
            }

            map.on('click', handleMapClick);
        }

        // Riapre dialog creazione zona con coordinate precompilate
        function reopenCreateZoneDialog(lat, lng) {
            // Apri dialog standard
            showCreateZoneDialog();

            // Piccolo ritardo per assicurarsi che il DOM sia pronto
            setTimeout(() => {
                // Popola con dati salvati
                if (pendingZoneFormData) {
                    const nameEl = document.getElementById('newZoneName');
                    const tournamentEl = document.getElementById('newZoneTournament');
                    const radiusEl = document.getElementById('newZoneRadius');
                    const unitEl = document.getElementById('newZoneUnit');
                    const typeEl = document.getElementById('newZoneType');
                    const colorEl = document.getElementById('newZoneColor');

                    if (nameEl) nameEl.value = pendingZoneFormData.name;
                    if (tournamentEl) tournamentEl.value = pendingZoneFormData.tournament;
                    if (radiusEl) radiusEl.value = pendingZoneFormData.radius;
                    if (unitEl) unitEl.value = pendingZoneFormData.unit;
                    if (typeEl) typeEl.value = pendingZoneFormData.type;
                    if (colorEl) colorEl.value = pendingZoneFormData.color;
                }

                // Imposta coordinate selezionate
                const latEl = document.getElementById('newZoneLat');
                const lngEl = document.getElementById('newZoneLng');
                if (latEl) latEl.value = lat.toFixed(6);
                if (lngEl) lngEl.value = lng.toFixed(6);

                pendingZoneFormData = null;

                showToast('Centro selezionato', `Coordinate: ${lat.toFixed(4)}, ${lng.toFixed(4)}`, 'success', 2000);
            }, 50);
        }

        // Crea zona dal dialog
        function createZoneFromDialog() {
            const name = document.getElementById('newZoneName').value.trim();
            const tournament = document.getElementById('newZoneTournament').value.trim() || name;
            const lat = parseFloat(document.getElementById('newZoneLat').value);
            const lng = parseFloat(document.getElementById('newZoneLng').value);
            const radius = parseFloat(document.getElementById('newZoneRadius').value);
            const unit = document.getElementById('newZoneUnit').value;
            const type = document.getElementById('newZoneType').value;
            const color = document.getElementById('newZoneColor').value;

            // Validazione con messaggi specifici
            const campiMancanti = [];
            if (!name) campiMancanti.push('Nome campo');
            if (isNaN(lat) || document.getElementById('newZoneLat').value.trim() === '') campiMancanti.push('Latitudine');
            if (isNaN(lng) || document.getElementById('newZoneLng').value.trim() === '') campiMancanti.push('Longitudine');
            if (isNaN(radius) || document.getElementById('newZoneRadius').value.trim() === '') campiMancanti.push('Raggio');

            if (campiMancanti.length > 0) {
                showToast('Campi mancanti', 'Compila: ' + campiMancanti.join(', '), 'warning', 4000);
                return;
            }
            if (radius < 1 || radius > 500) {
                showToast('Raggio non valido', 'Il raggio deve essere tra 1 e 500 ' + unit, 'warning', 3000);
                return;
            }
            if (lat < -90 || lat > 90) {
                showToast('Latitudine non valida', 'La latitudine deve essere tra -90 e 90', 'warning', 3000);
                return;
            }
            if (lng < -180 || lng > 180) {
                showToast('Longitudine non valida', 'La longitudine deve essere tra -180 e 180', 'warning', 3000);
                return;
            }

            // Converti in nm se necessario
            const radiusNm = unit === 'km' ? radius / 1.852 : radius;

            // Genera vertici
            const vertices = generateCirclePolygon(lat, lng, radiusNm, type);

            // Crea ID univoco
            const id = name.toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-|-$/g, '') + '-' + Date.now().toString(36);

            // Crea zona con metadati per editing
            const newZone = {
                id: id,
                name: name,
                tournament: tournament,
                year: new Date().getFullYear(),
                description: `${radius} ${unit} radius from center`,
                gatheringPoint: {
                    lat: lat,
                    lng: lng,
                    name: 'Centro / Punto Raduno'
                },
                vertices: vertices,
                color: color,
                // Metadati per editing centro + raggio
                centerMeta: {
                    lat: lat,
                    lng: lng,
                    radiusNm: radiusNm,
                    type: type,
                    unit: unit
                },
                isUserCreated: true
            };

            // Aggiungi a ZONES_DATA
            if (typeof ZONES_DATA !== 'undefined') {
                ZONES_DATA.push(newZone);
            }

            // Salva nel localStorage
            saveUserZones();

            // Aggiorna dropdown
            populateZoneSelect();

            // Seleziona nuova zona
            document.getElementById('zoneSelect').value = id;
            document.getElementById('showZoneCheckbox').checked = true;
            drawTournamentZone(id);

            // Centra mappa sulla nuova zona
            map.setView([lat, lng], 8);

            // Chiudi dialog
            document.getElementById('createZoneOverlay').remove();

            showToast('Campo creato', `"${name}" con ${vertices.length} vertici`, 'success', 3000);
        }

        // ============================================
        // EDITING CENTRO CAMPO DI GARA
        // Marker draggabile + dialog coordinate
        // ============================================

        var centerEditMarker = null;      // Marker centro draggabile (var per scope globale)
        var editingCenterZoneId = null;   // ID zona in editing (var per scope globale)
        var vertexEditMarkers = [];       // Array marker vertici draggabili
        var directEditPanel = null;       // Pannello salva/annulla per editing diretto
        var gatheringEditMarker = null;   // Marker punto di raduno draggabile

        // Abilita drag diretto del centro (click sul marker)
        function enableDirectCenterDrag(zone) {
            if (!zone || !zone.centerMeta) return;

            // Se gia in editing, esci
            if (editingCenterZoneId) {
                cancelDirectEdit();
                return;
            }

            editingCenterZoneId = zone.id;
            const meta = zone.centerMeta;

            // Aggiungi marker centro draggabile e vertici
            addCenterEditMarker(meta.lat, meta.lng);

            // Aggiungi marker punto di raduno trascinabile
            if (zone.gatheringPoint) {
                addGatheringEditMarker(zone.gatheringPoint.lat, zone.gatheringPoint.lng, zone.gatheringPoint.name);
            }

            // Mostra pannello salva/annulla
            showDirectEditPanel();

            // Mostra misure iniziali nel pannello
            showZoneArea(zone);

            showToast('Editing attivo', 'Trascina vertici o punto di raduno', 'info', 3000);
        }

        // Mostra pannello floating per salva/annulla
        function showDirectEditPanel() {
            if (directEditPanel) directEditPanel.remove();

            directEditPanel = document.createElement('div');
            directEditPanel.id = 'directEditPanel';
            directEditPanel.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
                padding: 12px 20px;
                border-radius: 12px;
                display: flex;
                gap: 10px;
                align-items: center;
                z-index: 9999;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
                border: 1px solid rgba(255,255,255,0.1);
            `;

            // Verifica se la zona ha gatheringPoint
            const currentZone = ZONES_DATA.find(z => z.id === editingCenterZoneId);
            const hasGatheringPoint = currentZone && currentZone.gatheringPoint;

            directEditPanel.innerHTML = `
                <span style="color: white; font-size: 14px; margin-right: 10px;">
                    <i class="fas fa-edit" style="color: #8b5cf6;"></i> Editing campo
                </span>
                <span id="editPanelArea" style="color: #22d3ee; font-size: 14px; margin-right: 15px; font-weight: 600;">
                    <i class="fas fa-vector-square"></i> <span id="editAreaNm">--</span> nm² | <span id="editAreaKm">--</span> km²
                </span>
                <label style="display: flex; align-items: center; gap: 6px; color: white; font-size: 13px; cursor: pointer; margin-right: 10px;">
                    <input type="checkbox" id="deleteVertexMode" style="width: 16px; height: 16px; cursor: pointer;" onchange="toggleDeleteMode(this.checked)">
                    <i class="fas fa-trash" style="color: #ef4444;"></i> Elimina vertici
                </label>
                ${!hasGatheringPoint ? `
                <button id="addGatheringBtn" onclick="addNewGatheringPoint()" style="
                    background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
                    color: white;
                    border: none;
                    padding: 8px 12px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 12px;
                    margin-right: 5px;
                "><i class="fas fa-flag"></i> Aggiungi Raduno</button>
                ` : ''}
                <button onclick="saveDirectEdit()" style="
                    background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 600;
                "><i class="fas fa-check"></i> Salva</button>
                <button onclick="cancelDirectEdit()" style="
                    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 600;
                "><i class="fas fa-times"></i> Annulla</button>
            `;

            document.body.appendChild(directEditPanel);
        }

        // Salva modifiche editing diretto
        function saveDirectEdit() {
            if (!editingCenterZoneId) return;

            const zone = ZONES_DATA.find(z => z.id === editingCenterZoneId);
            if (zone) {
                // Salva posizione punto di raduno (se marker esiste)
                if (gatheringEditMarker) {
                    const gatheringLatLng = gatheringEditMarker.getLatLng();
                    zone.gatheringPoint.lat = gatheringLatLng.lat;
                    zone.gatheringPoint.lng = gatheringLatLng.lng;
                }
                // Salva posizione centro (se marker esiste)
                if (centerEditMarker && zone.centerMeta) {
                    const centerLatLng = centerEditMarker.getLatLng();
                    zone.centerMeta.lat = centerLatLng.lat;
                    zone.centerMeta.lng = centerLatLng.lng;
                }
            }

            // Salva su localStorage
            saveUserZones();

            // Ridisegna zona
            const zoneId = editingCenterZoneId;
            clearCenterEditMarker(true);
            if (directEditPanel) {
                directEditPanel.remove();
                directEditPanel = null;
            }
            drawTournamentZone(zoneId);

            showToast('Salvato', 'Campo aggiornato con successo', 'success', 2000);
        }

        // Annulla editing diretto
        function cancelDirectEdit() {
            if (!editingCenterZoneId) return;

            const zoneId = editingCenterZoneId;
            clearCenterEditMarker(true);
            if (directEditPanel) {
                directEditPanel.remove();
                directEditPanel = null;
            }

            // Ridisegna zona originale
            drawTournamentZone(zoneId);

            showToast('Annullato', 'Modifiche annullate', 'info', 2000);
        }

        // Mostra dialog per editing centro campo
        function showEditCenterDialog() {
            const select = document.getElementById('zoneSelect');
            const zoneId = select.value;

            if (!zoneId) {
                showToast('Seleziona campo', 'Scegli prima un campo di gara', 'warning', 2000);
                return;
            }

            const zone = ZONES_DATA.find(z => z.id === zoneId);
            if (!zone) {
                showToast('Errore', 'Campo non trovato', 'danger', 2000);
                return;
            }

            // Verifica se ha metadati centro
            if (!zone.centerMeta) {
                showToast('Non supportato', 'Questo campo non supporta editing centro.<br>Usa "Modifica" per editing vertici.', 'warning', 4000);
                return;
            }

            editingCenterZoneId = zoneId;
            const meta = zone.centerMeta;

            // Crea overlay dialog
            const overlay = document.createElement('div');
            overlay.id = 'editCenterOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;

            overlay.innerHTML = `
                <div id="editCenterDialog" style="
                    background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
                    border-radius: 16px;
                    padding: 24px;
                    max-width: 400px;
                    width: 90%;
                    color: white;
                    box-shadow: 0 25px 50px rgba(0,0,0,0.5);
                ">
                    <h3 id="editCenterDialogHeader" style="margin: 0 0 20px 0; display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-arrows-alt" style="font-size: 0.8em; opacity: 0.6;"></i>
                        <i class="fas fa-crosshairs" style="color: #8b5cf6;"></i>
                        Modifica Centro Campo
                    </h3>

                    <div style="background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 8px; padding: 12px; margin-bottom: 16px;">
                        <strong>${zone.name}</strong><br>
                        <small style="color: #94a3b8;">${zone.tournament} ${zone.year}</small>
                    </div>

                    <div style="display: flex; gap: 10px; margin-bottom: 16px;">
                        <div style="flex: 1;">
                            <label style="display: block; margin-bottom: 4px; font-size: 12px; color: #94a3b8;">Latitudine</label>
                            <input type="number" id="editCenterLat" value="${meta.lat}" step="0.0001"
                                style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #334155; background: #1e293b; color: white;">
                        </div>
                        <div style="flex: 1;">
                            <label style="display: block; margin-bottom: 4px; font-size: 12px; color: #94a3b8;">Longitudine</label>
                            <input type="number" id="editCenterLng" value="${meta.lng}" step="0.0001"
                                style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #334155; background: #1e293b; color: white;">
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px; margin-bottom: 16px;">
                        <div style="flex: 1;">
                            <label style="display: block; margin-bottom: 4px; font-size: 12px; color: #94a3b8;">Raggio</label>
                            <input type="number" id="editCenterRadius" value="${meta.unit === 'km' ? (meta.radiusNm * 1.852).toFixed(1) : meta.radiusNm.toFixed(1)}" step="1" min="1" max="500"
                                style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #334155; background: #1e293b; color: white;">
                        </div>
                        <div style="flex: 1;">
                            <label style="display: block; margin-bottom: 4px; font-size: 12px; color: #94a3b8;">Unita</label>
                            <select id="editCenterUnit" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #334155; background: #1e293b; color: white;">
                                <option value="nm" ${meta.unit === 'nm' ? 'selected' : ''}>Miglia nautiche (nm)</option>
                                <option value="km" ${meta.unit === 'km' ? 'selected' : ''}>Chilometri (km)</option>
                            </select>
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 4px; font-size: 12px; color: #94a3b8;">Tipo Zona</label>
                        <select id="editCenterType" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #334155; background: #1e293b; color: white;">
                            <option value="circle" ${meta.type === 'circle' ? 'selected' : ''}>Cerchio completo</option>
                            <option value="semicircle_ocean" ${meta.type === 'semicircle_ocean' ? 'selected' : ''}>Semicerchio oceano (ovest)</option>
                            <option value="semicircle_south" ${meta.type === 'semicircle_south' ? 'selected' : ''}>Semicerchio sud</option>
                        </select>
                    </div>

                    <div style="background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.3); border-radius: 8px; padding: 10px; margin-bottom: 20px;">
                        <i class="fas fa-hand-pointer" style="color: #22c55e;"></i>
                        <small style="color: #94a3b8;">Puoi anche trascinare il marker <span style="color: #8b5cf6;">viola</span> sulla mappa!</small>
                    </div>

                    <div style="display: flex; gap: 10px;">
                        <button onclick="document.getElementById('editCenterOverlay').remove(); clearCenterEditMarker(true);"
                            style="flex: 1; padding: 12px; border-radius: 8px; border: 1px solid #475569; background: transparent; color: white; cursor: pointer;">
                            Annulla
                        </button>
                        <button onclick="applyCenterEdit()"
                            style="flex: 1; padding: 12px; border-radius: 8px; border: none; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white; cursor: pointer; font-weight: bold;">
                            <i class="fas fa-check"></i> Applica
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(overlay);

            // Rendi il dialog spostabile
            const dialogEC = document.getElementById('editCenterDialog');
            const headerEC = document.getElementById('editCenterDialogHeader');
            if (dialogEC && headerEC) {
                makeDraggable(dialogEC, headerEC);
            }

            // Chiudi con click su sfondo
            overlay.addEventListener('click', function(e) {
                if (e.target === overlay) {
                    overlay.remove();
                    clearCenterEditMarker(true);
                }
            });

            // Aggiungi marker centrale draggabile sulla mappa
            addCenterEditMarker(meta.lat, meta.lng);
        }

        // Aggiungi marker punto di raduno draggabile (verde con bandiera)
        function addGatheringEditMarker(lat, lng, name) {
            // Rimuovi marker esistente
            if (gatheringEditMarker) {
                map.removeLayer(gatheringEditMarker);
                gatheringEditMarker = null;
            }

            const gatherIcon = L.divIcon({
                className: 'gathering-edit-marker',
                html: `<div style="
                    background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
                    width: 32px;
                    height: 32px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    box-shadow: 0 4px 15px rgba(34, 197, 94, 0.5);
                    border: 3px solid white;
                    cursor: grab;
                    pointer-events: none;
                "><i class="fas fa-flag" style="color: white; font-size: 14px; pointer-events: none;"></i></div>`,
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });

            gatheringEditMarker = L.marker([lat, lng], {
                icon: gatherIcon,
                draggable: true,
                zIndexOffset: 900
            }).addTo(map);

            gatheringEditMarker.bindTooltip(`Trascina: ${name || 'Punto di Raduno'}`, {
                permanent: false,
                direction: 'top',
                offset: [0, -18]
            });

            // Aggiorna coordinate durante il drag
            gatheringEditMarker.on('drag', function(e) {
                const latlng = e.target.getLatLng();
                // Aggiorna coordinate zona in tempo reale
                const zone = ZONES_DATA.find(z => z.id === editingCenterZoneId);
                if (zone && zone.gatheringPoint) {
                    zone.gatheringPoint.lat = latlng.lat;
                    zone.gatheringPoint.lng = latlng.lng;
                }
            });

            gatheringEditMarker.on('dragend', function(e) {
                const latlng = e.target.getLatLng();
                showToast('Raduno spostato', `Nuove coordinate: ${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`, 'success', 2000);
            });
        }

        // Aggiunge un nuovo punto di raduno alla zona corrente
        function addNewGatheringPoint() {
            if (!editingCenterZoneId) return;

            const zone = ZONES_DATA.find(z => z.id === editingCenterZoneId);
            if (!zone) return;

            // Se ha gia gatheringPoint, esci
            if (zone.gatheringPoint) {
                showToast('Gia presente', 'Questa zona ha gia un punto di raduno', 'info', 2000);
                return;
            }

            // Calcola posizione: usa centro se disponibile, altrimenti centroide dei vertici
            let lat, lng;
            if (zone.centerMeta) {
                lat = zone.centerMeta.lat;
                lng = zone.centerMeta.lng;
            } else if (zone.vertices && zone.vertices.length > 0) {
                // Centroide dei vertici
                lat = zone.vertices.reduce((sum, v) => sum + v.lat, 0) / zone.vertices.length;
                lng = zone.vertices.reduce((sum, v) => sum + v.lng, 0) / zone.vertices.length;
            } else {
                showToast('Errore', 'Impossibile determinare posizione', 'danger', 2000);
                return;
            }

            // Crea gatheringPoint
            zone.gatheringPoint = {
                lat: lat,
                lng: lng,
                name: 'Punto di Raduno'
            };

            // Aggiungi marker draggabile
            addGatheringEditMarker(lat, lng, 'Punto di Raduno');

            // Nascondi bottone "Aggiungi Raduno"
            const addBtn = document.getElementById('addGatheringBtn');
            if (addBtn) {
                addBtn.style.display = 'none';
            }

            showToast('Raduno aggiunto', 'Trascina il marker verde per posizionarlo', 'success', 3000);
        }

        // Aggiungi marker centrale draggabile
        function addCenterEditMarker(lat, lng) {
            clearCenterEditMarker();

            const centerIcon = L.divIcon({
                className: 'center-edit-marker',
                html: `<div style="
                    background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
                    width: 36px;
                    height: 36px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    box-shadow: 0 4px 15px rgba(139, 92, 246, 0.5);
                    border: 3px solid white;
                    cursor: grab;
                    pointer-events: none;
                "><i class="fas fa-crosshairs" style="color: white; font-size: 16px; pointer-events: none;"></i></div>`,
                iconSize: [36, 36],
                iconAnchor: [18, 18]
            });

            centerEditMarker = L.marker([lat, lng], {
                icon: centerIcon,
                draggable: true,
                zIndexOffset: 1000
            }).addTo(map);

            centerEditMarker.bindTooltip('Trascina per spostare il centro', {
                permanent: false,
                direction: 'top',
                offset: [0, -20]
            });

            // Aggiorna coordinate nel dialog durante il drag
            centerEditMarker.on('drag', function(e) {
                const latlng = e.target.getLatLng();
                const latInput = document.getElementById('editCenterLat');
                const lngInput = document.getElementById('editCenterLng');
                if (latInput) latInput.value = latlng.lat.toFixed(6);
                if (lngInput) lngInput.value = latlng.lng.toFixed(6);

                // Preview del nuovo poligono durante il drag
                updateZonePreview(latlng.lat, latlng.lng);
            });

            centerEditMarker.on('dragend', function(e) {
                const latlng = e.target.getLatLng();
                showToast('Centro spostato', `Nuove coordinate: ${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`, 'info', 2000);
            });

            // Aggiungi anche i marker vertici sulla circonferenza
            addVertexEditMarkers();
        }

        // Aggiungi marker draggabili sui vertici della zona
        function addVertexEditMarkers() {
            if (!editingCenterZoneId) return;

            const zone = ZONES_DATA.find(z => z.id === editingCenterZoneId);
            if (!zone || !zone.vertices) return;

            // Rimuovi marker esistenti
            vertexEditMarkers.forEach(m => {
                if (m) map.removeLayer(m);
            });
            vertexEditMarkers = [];

            // Controlla se siamo in modalita eliminazione
            const deleteMode = document.getElementById('deleteVertexMode');
            const isDeleteMode = deleteMode && deleteMode.checked;

            // Crea marker per ogni vertice
            zone.vertices.forEach((vertex, index) => {
                const vertexIcon = L.divIcon({
                    className: 'vertex-edit-marker',
                    html: `<div style="
                        background: ${zone.color || '#06b6d4'};
                        width: 16px;
                        height: 16px;
                        border-radius: 50%;
                        border: 3px solid ${isDeleteMode ? '#ef4444' : '#8b5cf6'};
                        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
                        cursor: ${isDeleteMode ? 'crosshair' : 'grab'};
                    "></div>`,
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                });

                const marker = L.marker([vertex.lat, vertex.lng], {
                    icon: vertexIcon,
                    draggable: true,
                    zIndexOffset: 500
                }).addTo(map);

                // Blocca propagazione click/dblclick alla mappa (previene zoom)
                L.DomEvent.disableClickPropagation(marker.getElement());

                // Tooltip con numero vertice
                marker.bindTooltip(`Vertice ${index + 1}<br><small>Click per eliminare (se checkbox attivo)</small>`, {
                    permanent: false,
                    direction: 'top',
                    offset: [0, -10]
                });

                // Aggiorna posizione vertice durante drag
                marker.on('drag', function(e) {
                    const latlng = e.target.getLatLng();
                    handleVertexDrag(index, latlng.lat, latlng.lng);
                });

                marker.on('dragend', function(e) {
                    showToast('Vertice spostato', `Vertice ${index + 1} aggiornato`, 'info', 1500);
                });

                // Click per eliminare vertice - usa evento DOM diretto
                const markerElement = marker.getElement();
                if (markerElement) {
                    // Click singolo: elimina solo se checkbox "Elimina vertici" è attivo
                    markerElement.addEventListener('click', function(e) {
                        const deleteMode = document.getElementById('deleteVertexMode');
                        if (deleteMode && deleteMode.checked) {
                            e.stopPropagation();
                            e.preventDefault();
                            handleVertexDelete(index);
                        }
                    });
                }

                vertexEditMarkers.push(marker);
            });
        }

        // Gestisce drag di un vertice - aggiorna poligono in tempo reale
        function handleVertexDrag(index, newLat, newLng) {
            if (!editingCenterZoneId) return;

            const zone = ZONES_DATA.find(z => z.id === editingCenterZoneId);
            if (!zone || !zone.vertices || index >= zone.vertices.length) return;

            // Aggiorna vertice
            zone.vertices[index] = { lat: newLat, lng: newLng };

            // Aggiorna poligono sulla mappa
            if (zonePolygon) {
                const latlngs = zone.vertices.map(v => [v.lat, v.lng]);
                zonePolygon.setLatLngs(latlngs);
            }

            // Aggiorna superficie in tempo reale
            showZoneArea(zone);

            // Invalida centerMeta perche ora e' un poligono personalizzato
            if (zone.centerMeta) {
                zone.centerMeta.customized = true;
            }
        }

        // Toggle modalita eliminazione vertici
        function toggleDeleteMode(enabled) {
            // Seleziona il div INTERNO dei marker (quello con lo stile visibile)
            const markers = document.querySelectorAll('.vertex-edit-marker div');
            markers.forEach(m => {
                if (enabled) {
                    m.style.border = '3px solid #ef4444';
                    m.style.cursor = 'crosshair';
                } else {
                    m.style.border = '3px solid #8b5cf6';
                    m.style.cursor = 'grab';
                }
            });
            if (enabled) {
                showToast('Modalità eliminazione', 'Clicca su un vertice per eliminarlo', 'warning', 2000);
            } else {
                showToast('Modalità normale', 'Trascina i vertici per modificare il campo', 'info', 1500);
            }
        }

        // Gestisce eliminazione di un vertice con click
        function handleVertexDelete(index) {
            if (!editingCenterZoneId) return;

            const zone = ZONES_DATA.find(z => z.id === editingCenterZoneId);
            if (!zone || !zone.vertices) return;

            // Minimo 3 vertici per un poligono valido
            if (zone.vertices.length <= 3) {
                showToast('Impossibile', 'Un poligono deve avere almeno 3 vertici', 'warning', 2000);
                return;
            }

            // Rimuovi vertice
            zone.vertices.splice(index, 1);

            // Aggiorna poligono sulla mappa
            if (zonePolygon) {
                const latlngs = zone.vertices.map(v => [v.lat, v.lng]);
                zonePolygon.setLatLngs(latlngs);
            }

            // Rimuovi marker dalla mappa e dall'array
            if (vertexEditMarkers[index]) {
                map.removeLayer(vertexEditMarkers[index]);
            }

            // Ricrea tutti i marker per aggiornare gli indici
            addVertexEditMarkers();

            // Aggiorna superficie dopo eliminazione
            showZoneArea(zone);

            // Invalida centerMeta
            if (zone.centerMeta) {
                zone.centerMeta.customized = true;
            }

            showToast('Vertice eliminato', `Rimangono ${zone.vertices.length} vertici`, 'info', 2000);
        }

        // Rimuovi marker centrale editing e marker vertici
        // clearZoneId = true solo quando si chiude veramente il dialog (Annulla/click sfondo)
        function clearCenterEditMarker(clearZoneId = false) {
            if (centerEditMarker) {
                map.removeLayer(centerEditMarker);
                centerEditMarker = null;
            }
            // Rimuovi marker punto di raduno
            if (gatheringEditMarker) {
                map.removeLayer(gatheringEditMarker);
                gatheringEditMarker = null;
            }
            // Rimuovi anche tutti i marker vertici
            vertexEditMarkers.forEach(m => {
                if (m) map.removeLayer(m);
            });
            vertexEditMarkers = [];

            if (clearZoneId) {
                editingCenterZoneId = null;
            }
        }

        // Preview aggiornata durante drag
        function updateZonePreview(newLat, newLng) {
            if (!editingCenterZoneId) return;

            const zone = ZONES_DATA.find(z => z.id === editingCenterZoneId);
            if (!zone || !zone.centerMeta) return;

            const meta = zone.centerMeta;

            // Leggi valori correnti dal dialog
            const radiusInput = document.getElementById('editCenterRadius');
            const unitSelect = document.getElementById('editCenterUnit');
            const typeSelect = document.getElementById('editCenterType');

            const radius = parseFloat(radiusInput?.value || meta.radiusNm);
            const unit = unitSelect?.value || meta.unit;
            const type = typeSelect?.value || meta.type;

            const radiusNm = unit === 'km' ? radius / 1.852 : radius;

            // Genera nuovo poligono
            const newVertices = generateCirclePolygon(newLat, newLng, radiusNm, type);

            // Aggiorna poligono sulla mappa
            if (zonePolygon) {
                const latlngs = newVertices.map(v => [v.lat, v.lng]);
                zonePolygon.setLatLngs(latlngs);
            }
        }

        // Applica le modifiche al centro
        function applyCenterEdit() {
            if (!editingCenterZoneId) {
                showToast('Errore', 'Nessuna zona in editing', 'danger', 2000);
                return;
            }

            const zoneIndex = ZONES_DATA.findIndex(z => z.id === editingCenterZoneId);
            if (zoneIndex === -1) {
                showToast('Errore', 'Zona non trovata', 'danger', 2000);
                return;
            }

            const zone = ZONES_DATA[zoneIndex];

            // Leggi valori dal dialog
            const newLat = parseFloat(document.getElementById('editCenterLat').value);
            const newLng = parseFloat(document.getElementById('editCenterLng').value);
            const newRadius = parseFloat(document.getElementById('editCenterRadius').value);
            const newUnit = document.getElementById('editCenterUnit').value;
            const newType = document.getElementById('editCenterType').value;

            // Validazione
            if (isNaN(newLat) || isNaN(newLng) || isNaN(newRadius)) {
                showToast('Errore', 'Valori non validi', 'danger', 2000);
                return;
            }

            const radiusNm = newUnit === 'km' ? newRadius / 1.852 : newRadius;

            // Genera nuovi vertici
            const newVertices = generateCirclePolygon(newLat, newLng, radiusNm, newType);

            // Aggiorna zona
            zone.vertices = newVertices;
            zone.gatheringPoint.lat = newLat;
            zone.gatheringPoint.lng = newLng;
            zone.centerMeta = {
                lat: newLat,
                lng: newLng,
                radiusNm: radiusNm,
                type: newType,
                unit: newUnit
            };
            zone.description = `${newRadius} ${newUnit} radius from center`;

            // Ridisegna zona
            drawTournamentZone(editingCenterZoneId);

            // Centra mappa
            map.setView([newLat, newLng], map.getZoom());

            // Chiudi dialog e pulisci
            document.getElementById('editCenterOverlay')?.remove();
            clearCenterEditMarker(true);

            showToast('Campo aggiornato', `Centro spostato a ${newLat.toFixed(4)}, ${newLng.toFixed(4)}`, 'success', 3000);
        }

        // Inizializza dropdown al caricamento
        document.addEventListener('DOMContentLoaded', function() {
            loadUserZones();  // Carica zone salvate dall'utente
            populateZoneSelect();
            initCrosshair();  // Inizializza mirino centrale
        });

        // Fallback se DOMContentLoaded già passato
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(function() {
                loadUserZones();
                populateZoneSelect();
                initCrosshair();  // Inizializza mirino centrale
            }, 100);
        }

        // ============================================
        // RIGHELLO - Strumento di Misurazione
        // Misura distanze in miglia nautiche e km
        // Supporta chiusura poligono e salvataggio campo gara
        // ============================================

        let rulerActive = false;
        let editMode = false;        // Modalita editing punti
        let rulerPoints = [];
        let rulerMarkers = [];
        let rulerLines = [];
        let previewLine = null;      // Linea di anteprima che segue il mouse
        let previewLabel = null;     // Label distanza anteprima
        const CLOSE_THRESHOLD = 20;  // Pixel per chiudere il poligono
        let currentZonePolygon = null;    // Poligono zona corrente (per editing)
        let currentGatheringMarker = null; // Marker punto raduno (per editing)

        // ============================================
        // CATCH LOG - Sistema Registrazione Catture
        // Supporta GPS smartphone e click mappa
        // ============================================

        let catches = [];                    // Array catture caricate da localStorage
        let catchMarkers = [];               // Marker Leaflet sulla mappa
        let catchLogActive = false;          // Modalita registrazione cattura attiva
        let pendingCatchLocation = null;     // Coordinate in attesa conferma dialog

        // === TOURNAMENT MODE ===
        let tournamentMode = false;          // Modalita gara attiva
        let activeTournament = null;         // Torneo attivo {id, name, zone, startDate, catches[]}
        let tournaments = [];                // Storico tornei salvati

        // Converte coordinate decimali in formato gradi/minuti decimali (es. N 40° 29.700')
        function formatCoordDDM(lat, lng) {
            const latDir = lat >= 0 ? 'N' : 'S';
            const lngDir = lng >= 0 ? 'E' : 'W';
            const latAbs = Math.abs(lat);
            const lngAbs = Math.abs(lng);
            const latDeg = Math.floor(latAbs);
            const lngDeg = Math.floor(lngAbs);
            const latMin = ((latAbs - latDeg) * 60).toFixed(3);
            const lngMin = ((lngAbs - lngDeg) * 60).toFixed(3);
            return `${latDir} ${latDeg}° ${latMin}'  ${lngDir} ${lngDeg}° ${lngMin}'`;
        }

        const CATCH_TYPES = {
            strike: { label: 'Strike', icon: 'fa-bolt', color: '#f59e0b' },
            release: { label: 'Rilascio', icon: 'fa-fish', color: '#22c55e' },
            sighting: { label: 'Avvistamento', icon: 'fa-eye', color: '#3b82f6' },
            weighed_catch: { label: 'Cattura Pesata', icon: 'fa-weight-hanging', color: '#ef4444' }
        };

        const SPECIES_LIST = [
            // Grandi pelagici
            { id: 'tonno_rosso', label: 'Tonno Rosso' },
            { id: 'tonno_pinna_gialla', label: 'Tonno Pinna Gialla' },
            { id: 'alalunga', label: 'Alalunga' },
            { id: 'marlin_blu', label: 'Marlin Blu' },
            { id: 'marlin_bianco', label: 'Marlin Bianco' },
            { id: 'pesce_spada', label: 'Pesce Spada' },
            { id: 'aguglia_imperiale', label: 'Aguglia Imperiale' },
            // Pelagici medi
            { id: 'lampuga', label: 'Lampuga' },
            { id: 'ricciola', label: 'Ricciola' },
            { id: 'leccia', label: 'Leccia' },
            { id: 'leccia_stella', label: 'Leccia Stella' },
            { id: 'palamita', label: 'Palamita' },
            { id: 'tombarello', label: 'Tombarello' },
            // Predatori
            { id: 'dentice', label: 'Dentice' },
            { id: 'cernia', label: 'Cernia' },
            { id: 'spigola', label: 'Spigola' },
            { id: 'barracuda', label: 'Barracuda' },
            // Opzione custom
            { id: '_custom_', label: '➕ Altra specie...' }
        ];

        // Specie personalizzate aggiunte dall'utente (persistenti in localStorage)
        let customSpecies = JSON.parse(localStorage.getItem('bathyExplorerCustomSpecies') || '[]');

        // Restituisce lista completa specie (base + custom)
        function getAllSpecies() {
            const customOptions = customSpecies.map(s => ({ id: 'custom_' + s.toLowerCase().replace(/\s+/g, '_'), label: s }));
            // Inserisci custom prima dell'opzione "Altra specie..."
            const baseWithoutCustom = SPECIES_LIST.filter(s => s.id !== '_custom_');
            return [...baseWithoutCustom, ...customOptions, { id: '_custom_', label: '➕ Altra specie...' }];
        }

        // Aggiunge nuova specie personalizzata
        function addCustomSpecies(name) {
            if (!name || customSpecies.includes(name)) return;
            customSpecies.push(name);
            localStorage.setItem('bathyExplorerCustomSpecies', JSON.stringify(customSpecies));
        }

        // Ottiene il label di una specie dato il suo ID
        function getSpeciesLabel(speciesId) {
            if (!speciesId) return null;
            const allSpecies = getAllSpecies();
            const found = allSpecies.find(s => s.id === speciesId);
            if (found) return found.label;
            // Per specie custom non ancora in lista, estrai nome dall'ID
            if (speciesId.startsWith('custom_')) {
                return speciesId.replace('custom_', '').replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
            return speciesId;
        }

        const BAIT_TYPES = [
            { id: 'live', label: 'Esca Viva' },
            { id: 'artificial', label: 'Artificiale' },
            { id: 'trolling_lure', label: 'Trolling Lure' },
            { id: 'jig', label: 'Jig' }
        ];

        const WEATHER_OPTIONS = [
            { id: 'sunny', label: 'Sole', icon: 'fa-sun' },
            { id: 'cloudy', label: 'Nuvoloso', icon: 'fa-cloud' },
            { id: 'rain', label: 'Pioggia', icon: 'fa-cloud-rain' },
            { id: 'windy', label: 'Vento Forte', icon: 'fa-wind' }
        ];

        // Calcola distanza tra due punti usando formula di Haversine
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Raggio Terra in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; // Distanza in km
        }

        // Calcola area poligono usando formula di Shoelace con proiezione locale
        // Ritorna area in km quadrati
        function calculatePolygonArea(points) {
            if (!points || points.length < 3) return 0;

            // Converti coordinate geografiche in coordinate proiettate (metri)
            // Usa proiezione equirettangolare centrata sul centroide
            const centLat = points.reduce((sum, p) => sum + p.lat, 0) / points.length;
            const cosLat = Math.cos(centLat * Math.PI / 180);

            // Converti in metri (111320 m per grado di latitudine)
            const toMeters = (p) => ({
                x: p.lng * 111320 * cosLat,
                y: p.lat * 111320
            });

            const projected = points.map(toMeters);

            // Formula Shoelace per area poligono
            let area = 0;
            const n = projected.length;
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                area += projected[i].x * projected[j].y;
                area -= projected[j].x * projected[i].y;
            }
            area = Math.abs(area) / 2;

            // Converti da m^2 a km^2
            return area / 1000000;
        }

        // Converti km^2 in miglia nautiche quadrate
        function kmSqToNauticalMilesSq(kmSq) {
            // 1 nm = 1.852 km, quindi 1 nm^2 = 1.852^2 km^2 = 3.429904 km^2
            return kmSq / 3.429904;
        }

        // Converti km in miglia nautiche (1 nm = 1.852 km)
        function kmToNauticalMiles(km) {
            return km / 1.852;
        }

        // Calcola distanza totale del percorso (opzionalmente includendo chiusura)
        function calculateTotalDistance(includeClosing = false) {
            let totalKm = 0;
            for (let i = 1; i < rulerPoints.length; i++) {
                totalKm += haversineDistance(
                    rulerPoints[i-1].lat, rulerPoints[i-1].lng,
                    rulerPoints[i].lat, rulerPoints[i].lng
                );
            }
            // Se chiusura, aggiungi distanza ultimo-primo
            if (includeClosing && rulerPoints.length > 2) {
                totalKm += haversineDistance(
                    rulerPoints[rulerPoints.length-1].lat, rulerPoints[rulerPoints.length-1].lng,
                    rulerPoints[0].lat, rulerPoints[0].lng
                );
            }
            return totalKm;
        }

        // Aggiorna display distanza e area
        function updateRulerDisplay(previewKm = 0, showAreaMode = false) {
            const resultDiv = document.getElementById('rulerResult');
            const distanceSection = document.getElementById('rulerDistanceSection');
            const areaSection = document.getElementById('rulerAreaSection');
            const nmSpan = document.getElementById('rulerNm');
            const kmSpan = document.getElementById('rulerKm');
            const areaNmSqSpan = document.getElementById('rulerAreaNmSq');
            const areaKmSqSpan = document.getElementById('rulerAreaKmSq');
            const pointsDiv = document.getElementById('rulerPoints');

            if (rulerPoints.length === 0 && previewKm === 0 && !showAreaMode) {
                resultDiv.classList.remove('visible');
                return;
            }

            resultDiv.classList.add('visible');

            const totalKm = calculateTotalDistance() + previewKm;
            const totalNm = kmToNauticalMiles(totalKm);

            nmSpan.textContent = totalNm.toFixed(2);
            kmSpan.textContent = totalKm.toFixed(2);

            // Se abbiamo >= 3 punti, calcola e mostra anche l'area
            if (rulerPoints.length >= 3) {
                const areaKmSq = calculatePolygonArea(rulerPoints);
                const areaNmSq = kmSqToNauticalMilesSq(areaKmSq);

                areaNmSqSpan.textContent = areaNmSq.toFixed(2);
                areaKmSqSpan.textContent = areaKmSq.toFixed(2);

                // Mostra sezione area, nascondi distanza
                distanceSection.style.display = 'none';
                areaSection.style.display = 'block';

                pointsDiv.innerHTML = `${rulerPoints.length} vertici<br><small style="color:#22c55e;">Clicca sul punto 1 per chiudere</small>`;
            } else {
                // Mostra distanza, nascondi area
                distanceSection.style.display = 'block';
                areaSection.style.display = 'none';

                pointsDiv.textContent = `${rulerPoints.length} punti - ${Math.max(0, rulerPoints.length - 1)} segmenti`;
            }
        }

        // Mostra superficie di una zona esistente
        function showZoneArea(zone) {
            if (!zone || !zone.vertices || zone.vertices.length < 3) return;

            const resultDiv = document.getElementById('rulerResult');
            const distanceSection = document.getElementById('rulerDistanceSection');
            const areaSection = document.getElementById('rulerAreaSection');
            const areaNmSqSpan = document.getElementById('rulerAreaNmSq');
            const areaKmSqSpan = document.getElementById('rulerAreaKmSq');
            const pointsDiv = document.getElementById('rulerPoints');

            resultDiv.classList.add('visible');

            const areaKmSq = calculatePolygonArea(zone.vertices);
            const areaNmSq = kmSqToNauticalMilesSq(areaKmSq);

            areaNmSqSpan.textContent = areaNmSq.toFixed(2);
            areaKmSqSpan.textContent = areaKmSq.toFixed(2);

            // Mostra solo sezione area
            distanceSection.style.display = 'none';
            areaSection.style.display = 'block';

            pointsDiv.innerHTML = `<strong>${zone.name}</strong><br><small>${zone.vertices.length} vertici</small>`;

            // Aggiorna anche il pannello di editing se visibile
            const editAreaNm = document.getElementById('editAreaNm');
            const editAreaKm = document.getElementById('editAreaKm');
            if (editAreaNm) editAreaNm.textContent = areaNmSq.toFixed(2);
            if (editAreaKm) editAreaKm.textContent = areaKmSq.toFixed(2);
        }

        // Calcola centroide del poligono
        function calculateCentroid(points) {
            let latSum = 0, lngSum = 0;
            points.forEach(p => {
                latSum += p.lat;
                lngSum += p.lng;
            });
            return {
                lat: latSum / points.length,
                lng: lngSum / points.length
            };
        }

        // Reverse geocoding per ottenere nome luogo
        async function getLocationName(lat, lng) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=10`);
                const data = await response.json();
                if (data.address) {
                    return data.address.city || data.address.town || data.address.municipality ||
                           data.address.county || data.address.state || data.address.country || 'Zona Sconosciuta';
                }
            } catch (e) {
                console.log('Geocoding fallito:', e);
            }
            return `Lat ${lat.toFixed(2)}, Lng ${lng.toFixed(2)}`;
        }

        // Chiudi poligono e chiedi se salvare come campo gara
        async function closePolygonAndSave() {
            if (rulerPoints.length < 3) return;

            // Disegna linea di chiusura
            const lastPoint = rulerPoints[rulerPoints.length - 1];
            const firstPoint = rulerPoints[0];

            const closingLine = L.polyline([
                [lastPoint.lat, lastPoint.lng],
                [firstPoint.lat, firstPoint.lng]
            ], {
                color: '#22c55e',
                weight: 3,
                opacity: 0.8
            }).addTo(map);
            rulerLines.push({ line: closingLine, label: null });

            // Disattiva righello
            if (rulerActive) toggleRuler();

            // Calcola dati del campo
            const centroid = calculateCentroid(rulerPoints);
            const perimeterKm = calculateTotalDistance(true);
            const perimeterNm = kmToNauticalMiles(perimeterKm);

            // Ottieni nome luogo
            const locationName = await getLocationName(centroid.lat, centroid.lng);

            // Mostra dialog di salvataggio
            showSaveZoneDialog(centroid, locationName, perimeterNm);
        }

        // Mostra dialog per salvare il campo di gara
        function showSaveZoneDialog(centroid, locationName, perimeterNm) {
            // Crea overlay
            const overlay = document.createElement('div');
            overlay.id = 'saveZoneOverlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.7); z-index: 2000;
                display: flex; align-items: center; justify-content: center;
            `;

            const currentYear = new Date().getFullYear();

            overlay.innerHTML = `
                <div id="saveZoneDialog" style="
                    background: linear-gradient(135deg, #1e3a5f 0%, #0c4a6e 100%);
                    border-radius: 16px; padding: 24px; max-width: 400px; width: 90%;
                    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
                ">
                    <h3 id="saveZoneDialogHeader" style="color: #7dd3fc; margin: 0 0 8px 0; display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-arrows-alt" style="font-size: 0.8em; opacity: 0.6;"></i>
                        <i class="fas fa-trophy"></i> Salva Campo di Gara
                    </h3>
                    <p style="color: #94a3b8; font-size: 0.85rem; margin: 0 0 20px 0;">
                        Poligono con ${rulerPoints.length} vertici - Perimetro: ${perimeterNm.toFixed(1)} nm
                    </p>

                    <div style="margin-bottom: 16px;">
                        <label style="color: #e2e8f0; font-size: 0.85rem; display: block; margin-bottom: 6px;">
                            Nome del Campo di Gara *
                        </label>
                        <input type="text" id="zoneNameInput" placeholder="es. Big Game Forio 2026" style="
                            width: 100%; padding: 12px; border-radius: 8px;
                            background: #1e293b; border: 1px solid #334155;
                            color: #e2e8f0; font-size: 1rem;
                        ">
                    </div>

                    <div style="background: rgba(0,0,0,0.2); border-radius: 8px; padding: 12px; margin-bottom: 20px;">
                        <div style="color: #94a3b8; font-size: 0.75rem; text-transform: uppercase; margin-bottom: 8px;">
                            <i class="fas fa-map-marker-alt"></i> Rilevato automaticamente
                        </div>
                        <div style="color: #e2e8f0; font-size: 0.9rem;">
                            <strong>Luogo:</strong> ${locationName}<br>
                            <strong>Centro:</strong> ${centroid.lat.toFixed(4)}, ${centroid.lng.toFixed(4)}<br>
                            <strong>Vertici:</strong> ${rulerPoints.length}
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px;">
                        <button onclick="cancelSaveZone()" style="
                            flex: 1; padding: 12px; border-radius: 8px; border: none;
                            background: #475569; color: #e2e8f0; font-weight: 600;
                            cursor: pointer;
                        ">Annulla</button>
                        <button onclick="confirmSaveZone('${locationName}', ${centroid.lat}, ${centroid.lng}, ${currentYear})" style="
                            flex: 1; padding: 12px; border-radius: 8px; border: none;
                            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
                            color: white; font-weight: 600; cursor: pointer;
                        "><i class="fas fa-save"></i> Salva</button>
                    </div>
                </div>
            `;

            document.body.appendChild(overlay);

            // Rendi il dialog spostabile
            const dialogSZ = document.getElementById('saveZoneDialog');
            const headerSZ = document.getElementById('saveZoneDialogHeader');
            if (dialogSZ && headerSZ) {
                makeDraggable(dialogSZ, headerSZ);
            }

            document.getElementById('zoneNameInput').focus();
        }

        // Annulla salvataggio
        function cancelSaveZone() {
            const overlay = document.getElementById('saveZoneOverlay');
            if (overlay) overlay.remove();
        }

        // Conferma salvataggio campo di gara
        function confirmSaveZone(locationName, centerLat, centerLng, year) {
            const nameInput = document.getElementById('zoneNameInput');
            const name = nameInput.value.trim();

            if (!name) {
                nameInput.style.borderColor = '#ef4444';
                nameInput.focus();
                return;
            }

            // Genera ID univoco
            const id = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');

            // Crea nuovo campo di gara
            const newZone = {
                id: id + '-' + Date.now(),
                name: name,
                tournament: name,
                year: year,
                description: `Campo creato con righello - ${rulerPoints.length} vertici`,
                gatheringPoint: {
                    lat: centerLat,
                    lng: centerLng,
                    name: 'Punto di Raduno'
                },
                vertices: rulerPoints.map(p => ({ lat: p.lat, lng: p.lng })),
                color: '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'),
                isUserCreated: true
            };

            // Aggiungi a ZONES_DATA
            if (typeof ZONES_DATA !== 'undefined') {
                ZONES_DATA.push(newZone);
            }

            // Salva nel localStorage
            saveUserZones();

            // Aggiorna dropdown
            populateZoneSelect();

            // Seleziona il nuovo campo
            const select = document.getElementById('zoneSelect');
            select.value = newZone.id;

            // Chiudi dialog
            cancelSaveZone();

            // Pulisci righello
            clearRuler();

            // Mostra il nuovo campo
            document.getElementById('showZoneCheckbox').checked = true;
            drawTournamentZone(newZone.id);

            showToast(
                'Campo di Gara salvato!',
                `<strong>${name}</strong><br>Aggiunto al menu Campi di Gara`,
                'success',
                5000
            );
        }

        // Rimuovi anteprima linea
        function clearPreview() {
            if (previewLine) {
                map.removeLayer(previewLine);
                previewLine = null;
            }
            if (previewLabel) {
                map.removeLayer(previewLabel);
                previewLabel = null;
            }
        }

        // Verifica se il click è vicino al primo punto
        function isNearFirstPoint(latlng) {
            if (rulerPoints.length < 3) return false;
            const firstPoint = rulerPoints[0];
            const firstPixel = map.latLngToContainerPoint(L.latLng(firstPoint.lat, firstPoint.lng));
            const clickPixel = map.latLngToContainerPoint(latlng);
            const distance = Math.sqrt(
                Math.pow(firstPixel.x - clickPixel.x, 2) +
                Math.pow(firstPixel.y - clickPixel.y, 2)
            );
            return distance < CLOSE_THRESHOLD;
        }

        // Aggiungi punto al righello
        function addRulerPoint(latlng) {
            // Verifica chiusura poligono
            if (isNearFirstPoint(latlng)) {
                closePolygonAndSave();
                return;
            }

            rulerPoints.push(latlng);
            clearPreview();

            // Crea marker per il punto
            const pointNumber = rulerPoints.length;
            const isFirst = pointNumber === 1;
            const markerIcon = L.divIcon({
                className: 'ruler-marker',
                html: `<div style="
                    background: ${isFirst ? 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)' : 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)'};
                    color: white;
                    width: ${isFirst ? '28px' : '24px'};
                    height: ${isFirst ? '28px' : '24px'};
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: ${isFirst ? '14px' : '12px'};
                    font-weight: bold;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                    border: 2px solid white;
                    ${isFirst ? 'animation: pulse 2s infinite;' : ''}
                ">${pointNumber}</div>`,
                iconSize: [isFirst ? 28 : 24, isFirst ? 28 : 24],
                iconAnchor: [isFirst ? 14 : 12, isFirst ? 14 : 12]
            });

            const marker = L.marker(latlng, { icon: markerIcon, draggable: true }).addTo(map);

            // Salva indice del punto nel marker per riferimento
            marker.pointIndex = rulerPoints.length - 1;

            // Il primo marker usa tooltip (non popup) per permettere click di chiusura
            if (isFirst) {
                marker.bindTooltip(`Punto 1 - Clicca per chiudere`, {
                    permanent: false,
                    direction: 'top',
                    offset: [0, -15]
                });

                // Click handler per chiudere il poligono
                marker.on('click', function(e) {
                    if (rulerPoints.length >= 3 && rulerActive && !editMode) {
                        L.DomEvent.stopPropagation(e);
                        closePolygonAndSave();
                    }
                });
            } else {
                // Altri marker usano popup normale
                marker.bindPopup(`
                    <strong>Punto ${pointNumber}</strong><br>
                    <span style="font-family: monospace;">
                        ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}
                    </span>
                `);
            }

            // Drag handler per aggiornare posizione
            marker.on('drag', function(e) {
                if (editMode) {
                    const idx = marker.pointIndex;
                    const newLatLng = e.target.getLatLng();
                    rulerPoints[idx] = newLatLng;
                    updateAllLines();
                    updateRulerDisplay();
                }
            });

            marker.on('dragend', function(e) {
                if (editMode) {
                    const idx = marker.pointIndex;
                    // Aggiorna popup con nuove coordinate
                    if (idx > 0) {
                        marker.setPopupContent(`
                            <strong>Punto ${idx + 1}</strong><br>
                            <span style="font-family: monospace;">
                                ${rulerPoints[idx].lat.toFixed(6)}, ${rulerPoints[idx].lng.toFixed(6)}
                            </span>
                        `);
                    }
                }
            });

            rulerMarkers.push(marker);

            // Mostra pulsante modifica se ci sono abbastanza punti
            showEditButton();

            // Disegna linea dal punto precedente
            if (rulerPoints.length > 1) {
                const prevPoint = rulerPoints[rulerPoints.length - 2];
                const line = L.polyline([
                    [prevPoint.lat, prevPoint.lng],
                    [latlng.lat, latlng.lng]
                ], {
                    color: '#f59e0b',
                    weight: 3,
                    opacity: 0.8,
                    dashArray: '10, 5'
                }).addTo(map);

                // Label distanza segmento
                const segmentKm = haversineDistance(prevPoint.lat, prevPoint.lng, latlng.lat, latlng.lng);
                const segmentNm = kmToNauticalMiles(segmentKm);
                const midLat = (prevPoint.lat + latlng.lat) / 2;
                const midLng = (prevPoint.lng + latlng.lng) / 2;

                const labelIcon = L.divIcon({
                    className: 'ruler-label',
                    html: `<div style="
                        color: #1e293b;
                        font-size: 10px;
                        font-weight: 500;
                        white-space: nowrap;
                        text-shadow: 1px 1px 0 white, -1px -1px 0 white, 1px -1px 0 white, -1px 1px 0 white;
                    ">${segmentNm.toFixed(1)} nm | ${segmentKm.toFixed(1)} km</div>`,
                    iconSize: [100, 20],
                    iconAnchor: [50, 10]
                });

                const label = L.marker([midLat, midLng], { icon: labelIcon, interactive: false }).addTo(map);
                rulerLines.push({ line, label });
            }

            updateRulerDisplay();
        }

        // Toggle righello attivo/disattivo
        function toggleRuler() {
            rulerActive = !rulerActive;
            const btn = document.getElementById('rulerToggleBtn');

            if (rulerActive) {
                btn.classList.add('active');
                btn.innerHTML = '<i class="fas fa-stop"></i> Stop';
                map.getContainer().style.cursor = 'crosshair';
                showToast('Righello attivo', 'Clicca per aggiungere punti. Chiudi sul punto 1 per creare un campo di gara.', 'info', 4000);
            } else {
                btn.classList.remove('active');
                btn.innerHTML = '<i class="fas fa-ruler"></i> Misura';
                map.getContainer().style.cursor = '';
                clearPreview();
            }
        }

        // Pulisci righello
        function clearRuler() {
            rulerMarkers.forEach(m => map.removeLayer(m));
            rulerMarkers = [];
            rulerLines.forEach(item => {
                map.removeLayer(item.line);
                if (item.label) map.removeLayer(item.label);
            });
            rulerLines = [];
            rulerPoints = [];
            clearPreview();
            updateRulerDisplay();
            if (rulerActive) toggleRuler();
            if (editMode) toggleEditMode();

            // Nascondi pulsante modifica
            document.getElementById('rulerEditBtn').style.display = 'none';

            // Rimuovi pulsante salva modifiche se presente
            const saveBtn = document.getElementById('saveChangesBtn');
            if (saveBtn) saveBtn.remove();

            // Reset editing zone ID
            editingZoneId = null;
        }

        // Aggiorna tutte le linee dopo drag
        function updateAllLines() {
            // Rimuovi linee e label esistenti
            rulerLines.forEach(item => {
                map.removeLayer(item.line);
                if (item.label) map.removeLayer(item.label);
            });
            rulerLines = [];

            // Ridisegna tutte le linee
            for (let i = 1; i < rulerPoints.length; i++) {
                const prevPoint = rulerPoints[i - 1];
                const currPoint = rulerPoints[i];

                const line = L.polyline([
                    [prevPoint.lat, prevPoint.lng],
                    [currPoint.lat, currPoint.lng]
                ], {
                    color: '#f59e0b',
                    weight: 3,
                    opacity: 0.8,
                    dashArray: '10, 5'
                }).addTo(map);

                // Calcola distanza segmento
                const segmentKm = haversineDistance(prevPoint.lat, prevPoint.lng, currPoint.lat, currPoint.lng);
                const segmentNm = kmToNauticalMiles(segmentKm);
                const midLat = (prevPoint.lat + currPoint.lat) / 2;
                const midLng = (prevPoint.lng + currPoint.lng) / 2;

                const labelIcon = L.divIcon({
                    className: 'ruler-label',
                    html: `<div style="
                        color: #1e293b;
                        font-size: 10px;
                        font-weight: 500;
                        white-space: nowrap;
                        text-shadow: 1px 1px 0 white, -1px -1px 0 white, 1px -1px 0 white, -1px 1px 0 white;
                    ">${segmentNm.toFixed(1)} nm | ${segmentKm.toFixed(1)} km</div>`,
                    iconSize: [100, 20],
                    iconAnchor: [50, 10]
                });

                const label = L.marker([midLat, midLng], { icon: labelIcon, interactive: false }).addTo(map);
                rulerLines.push({ line, label });
            }
        }

        // Toggle modalita editing
        function toggleEditMode() {
            editMode = !editMode;
            const btn = document.getElementById('rulerEditBtn');

            if (editMode) {
                btn.classList.add('active');
                btn.innerHTML = '<i class="fas fa-check"></i> Fine';
                btn.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)';

                // Disattiva righello se attivo
                if (rulerActive) toggleRuler();

                // Mostra cursore move sui marker
                rulerMarkers.forEach(m => {
                    m.getElement().style.cursor = 'move';
                });

                showToast('Modalita Modifica', 'Trascina i punti per modificare il poligono', 'info', 3000);
            } else {
                btn.classList.remove('active');
                btn.innerHTML = '<i class="fas fa-edit"></i> Modifica';
                btn.style.background = '';

                // Ripristina cursore normale
                rulerMarkers.forEach(m => {
                    m.getElement().style.cursor = '';
                });
            }
        }

        // Mostra pulsante modifica quando ci sono abbastanza punti
        function showEditButton() {
            const btn = document.getElementById('rulerEditBtn');
            if (rulerPoints.length >= 2) {
                btn.style.display = '';
            }
        }

        // ID della zona in fase di editing
        let editingZoneId = null;

        // Carica una zona salvata per l'editing
        function editSelectedZone() {
            const select = document.getElementById('zoneSelect');
            const zoneId = select.value;

            if (!zoneId) {
                showToast('Seleziona un campo', 'Scegli un campo di gara dal menu', 'warning', 2000);
                return;
            }

            // Trova la zona
            const zone = ZONES_DATA.find(z => z.id === zoneId);
            if (!zone || !zone.vertices || zone.vertices.length < 3) {
                showToast('Errore', 'Campo non trovato o senza vertici', 'danger', 2000);
                return;
            }

            // Pulisci righello attuale
            clearRuler();

            // Nascondi zona disegnata se presente
            if (currentZonePolygon) {
                map.removeLayer(currentZonePolygon);
                currentZonePolygon = null;
            }
            if (currentGatheringMarker) {
                map.removeLayer(currentGatheringMarker);
                currentGatheringMarker = null;
            }

            // Salva ID zona in editing
            editingZoneId = zoneId;

            // Carica i vertici nel righello
            zone.vertices.forEach((vertex, index) => {
                const latlng = L.latLng(vertex.lat, vertex.lng);
                rulerPoints.push(latlng);

                // Crea marker
                const isFirst = index === 0;
                const pointNumber = index + 1;
                const markerIcon = L.divIcon({
                    className: 'ruler-marker',
                    html: `<div style="
                        background: ${isFirst ? 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)' : 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)'};
                        color: white;
                        width: ${isFirst ? '28px' : '24px'};
                        height: ${isFirst ? '28px' : '24px'};
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: ${isFirst ? '14px' : '12px'};
                        font-weight: bold;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                        border: 2px solid white;
                    ">${pointNumber}</div>`,
                    iconSize: [isFirst ? 28 : 24, isFirst ? 28 : 24],
                    iconAnchor: [isFirst ? 14 : 12, isFirst ? 14 : 12]
                });

                const marker = L.marker(latlng, { icon: markerIcon, draggable: true }).addTo(map);
                marker.pointIndex = index;

                if (isFirst) {
                    marker.bindTooltip(`Punto 1`, { permanent: false, direction: 'top', offset: [0, -15] });
                } else {
                    marker.bindPopup(`<strong>Punto ${pointNumber}</strong><br>
                        <span style="font-family: monospace;">${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}</span>`);
                }

                // Drag handlers
                marker.on('drag', function(e) {
                    if (editMode) {
                        const idx = marker.pointIndex;
                        rulerPoints[idx] = e.target.getLatLng();
                        updateAllLines();
                        updateRulerDisplay();
                    }
                });

                marker.on('dragend', function(e) {
                    if (editMode && marker.pointIndex > 0) {
                        marker.setPopupContent(`<strong>Punto ${marker.pointIndex + 1}</strong><br>
                            <span style="font-family: monospace;">${rulerPoints[marker.pointIndex].lat.toFixed(6)}, ${rulerPoints[marker.pointIndex].lng.toFixed(6)}</span>`);
                    }
                });

                rulerMarkers.push(marker);
            });

            // Disegna le linee
            updateAllLines();

            // Mostra pulsante modifica
            showEditButton();

            // Zoom sulla zona
            const bounds = L.latLngBounds(rulerPoints);
            map.fitBounds(bounds, { padding: [50, 50] });

            // Attiva edit mode
            setTimeout(() => {
                if (!editMode) toggleEditMode();
            }, 500);

            // Aggiorna display
            updateRulerDisplay();

            showToast(
                `Modifica: ${zone.name}`,
                'Trascina i punti per modificare. Clicca "Salva Modifiche" quando finito.',
                'info',
                4000
            );

            // Mostra pulsante "Salva Modifiche"
            showSaveChangesButton(zone.name);
        }

        // Mostra pulsante per salvare le modifiche
        function showSaveChangesButton(zoneName) {
            // Rimuovi pulsante esistente se presente
            const existing = document.getElementById('saveChangesBtn');
            if (existing) existing.remove();

            // Trova la sezione righello tramite il pulsante toggle
            const rulerBtn = document.getElementById('rulerToggleBtn');
            const rulerSection = rulerBtn ? rulerBtn.closest('.sidebar-section') : null;
            if (!rulerSection) return;

            const btn = document.createElement('button');
            btn.id = 'saveChangesBtn';
            btn.className = 'ruler-btn primary';
            btn.style.cssText = 'width: 100%; margin-top: 10px; background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);';
            btn.innerHTML = '<i class="fas fa-save"></i> Salva Modifiche';
            btn.onclick = () => saveZoneChanges(zoneName);

            rulerSection.appendChild(btn);
        }

        // Salva le modifiche alla zona
        function saveZoneChanges(zoneName) {
            if (!editingZoneId || rulerPoints.length < 3) {
                showToast('Errore', 'Nessuna zona in modifica', 'danger', 2000);
                return;
            }

            // Trova e aggiorna la zona
            const zoneIndex = ZONES_DATA.findIndex(z => z.id === editingZoneId);
            if (zoneIndex === -1) {
                showToast('Errore', 'Zona non trovata', 'danger', 2000);
                return;
            }

            // Aggiorna vertici
            ZONES_DATA[zoneIndex].vertices = rulerPoints.map(p => ({ lat: p.lat, lng: p.lng }));

            // Aggiorna gathering point al centroide
            const centroid = calculateCentroid(rulerPoints);
            ZONES_DATA[zoneIndex].gatheringPoint.lat = centroid.lat;
            ZONES_DATA[zoneIndex].gatheringPoint.lng = centroid.lng;

            // Esci da edit mode
            if (editMode) toggleEditMode();

            // Pulisci
            clearRuler();
            editingZoneId = null;

            // Rimuovi pulsante salva
            const saveBtn = document.getElementById('saveChangesBtn');
            if (saveBtn) saveBtn.remove();

            // Ridisegna zona
            document.getElementById('showZoneCheckbox').checked = true;
            drawTournamentZone(ZONES_DATA[zoneIndex].id);

            showToast(
                'Modifiche Salvate!',
                `<strong>${zoneName}</strong> aggiornato con successo`,
                'success',
                3000
            );
        }

        // Handler movimento mouse per anteprima
        map.on('mousemove', function(e) {
            if (!rulerActive || rulerPoints.length === 0) return;

            const lastPoint = rulerPoints[rulerPoints.length - 1];
            clearPreview();

            // Verifica vicinanza al primo punto
            const nearFirst = isNearFirstPoint(e.latlng);
            const targetPoint = nearFirst ? rulerPoints[0] : e.latlng;
            const lineColor = nearFirst ? '#22c55e' : '#f59e0b';

            // Linea di anteprima
            previewLine = L.polyline([
                [lastPoint.lat, lastPoint.lng],
                [targetPoint.lat, targetPoint.lng]
            ], {
                color: lineColor,
                weight: 2,
                opacity: 0.6,
                dashArray: '5, 10'
            }).addTo(map);

            // Calcola distanza anteprima
            const previewKm = haversineDistance(lastPoint.lat, lastPoint.lng, targetPoint.lat, targetPoint.lng);
            const previewNm = kmToNauticalMiles(previewKm);

            // Label anteprima
            const midLat = (lastPoint.lat + targetPoint.lat) / 2;
            const midLng = (lastPoint.lng + targetPoint.lng) / 2;

            const labelHtml = nearFirst
                ? `<div style="background:#22c55e;color:white;padding:4px 10px;border-radius:4px;font-size:12px;font-weight:bold;">
                     <i class="fas fa-check-circle"></i> CHIUDI
                   </div>`
                : `<div style="color:#1e293b;font-size:10px;font-weight:500;text-shadow:1px 1px 0 white,-1px -1px 0 white,1px -1px 0 white,-1px 1px 0 white;">
                     ${previewNm.toFixed(1)} nm | ${previewKm.toFixed(1)} km
                   </div>`;

            const labelIcon = L.divIcon({
                className: 'ruler-preview-label',
                html: labelHtml,
                iconSize: [120, 24],
                iconAnchor: [60, 12]
            });

            previewLabel = L.marker([midLat, midLng], { icon: labelIcon, interactive: false }).addTo(map);

            // Aggiorna display con anteprima
            updateRulerDisplay(previewKm);
        });

        // Handler click mappa per righello e catch log
        map.on('click', function(e) {
            if (rulerActive) {
                addRulerPoint(e.latlng);
            } else if (catchLogActive) {
                // SALVATAGGIO IMMEDIATO - solo coordinate
                quickSaveCatch(e.latlng.lat, e.latlng.lng, 'manual');
                showToast('Punto segnato!', 'Clicca nella lista per completare i dati', 'info', 3000);
            }
        });

        // ============================================
        // CATCH LOG - Funzioni
        // ============================================

        // Storage: Carica catture da localStorage
        function getCatches() {
            const saved = localStorage.getItem('bathyExplorerCatches');
            return saved ? JSON.parse(saved) : [];
        }

        // Storage: Salva catture in localStorage
        function saveCatchesToStorage() {
            localStorage.setItem('bathyExplorerCatches', JSON.stringify(catches));
        }

        // Inizializza Catch Log all'avvio
        function initCatchLog() {
            catches = getCatches();
            populateSpeciesFilter();
            renderCatchList();
            renderCatchMarkers();
            updateCatchStats();
        }

        // Popola dropdown specie (include custom, esclude opzione "Altra specie...")
        function populateSpeciesFilter() {
            const select = document.getElementById('catchFilterSpecies');
            if (!select) return;
            select.innerHTML = '<option value="all">Tutte le specie</option>';
            getAllSpecies().forEach(s => {
                if (s.id !== '_custom_') {
                    select.innerHTML += `<option value="${s.id}">${s.label}</option>`;
                }
            });
        }

        // Toggle modalita registrazione
        function toggleCatchMode() {
            catchLogActive = !catchLogActive;
            const btn = document.getElementById('catchModeBtn');
            if (catchLogActive) {
                btn.innerHTML = '<i class="fas fa-times"></i> Annulla';
                btn.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
                showToast('Segna Punto', 'Clicca sulla mappa per segnare la posizione', 'info', 3000);
                // Disattiva righello se attivo
                if (rulerActive) {
                    rulerActive = false;
                    document.getElementById('rulerToggleBtn').innerHTML = '<i class="fas fa-ruler"></i> Misura';
                }
            } else {
                btn.innerHTML = '<i class="fas fa-map-marker-alt"></i> Segna';
                btn.style.background = '';
            }
        }

        // Geolocation: Usa GPS corrente - SALVATAGGIO IMMEDIATO
        function useCurrentGPS() {
            if (!navigator.geolocation) {
                showToast('GPS non disponibile', 'Il browser non supporta la geolocalizzazione', 'warning', 4000);
                return;
            }
            showToast('Acquisizione GPS...', 'Attendere posizione...', 'info', 2000);
            navigator.geolocation.getCurrentPosition(
                function(position) {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    const accuracy = position.coords.accuracy;
                    // SALVA SUBITO il punto
                    quickSaveCatch(lat, lng, 'gps');
                    map.setView([lat, lng], 14);
                    showToast('Punto salvato!', `GPS (precisione ${accuracy.toFixed(0)}m) - Clicca per modificare`, 'info', 3000);
                },
                function(error) {
                    let msg = 'Errore sconosciuto';
                    if (error.code === 1) msg = 'Permesso GPS negato';
                    if (error.code === 2) msg = 'Posizione non disponibile';
                    if (error.code === 3) msg = 'Timeout GPS';
                    showToast('Errore GPS', msg, 'warning', 4000);
                },
                { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
            );
        }

        // SALVATAGGIO RAPIDO - Solo coordinate e timestamp
        function quickSaveCatch(lat, lng, source) {
            const catchData = {
                id: 'catch_' + Date.now(),
                type: null,           // Da compilare dopo
                timestamp: new Date().toISOString(),
                location: { lat, lng, source },
                species: null,        // Da compilare dopo
                weight: null,
                depth: null,
                bait: null,
                weather: null,
                notes: '',
                photo: null
            };

            catches.push(catchData);
            saveCatchesToStorage();
            renderCatchList();
            renderCatchMarkers();
            updateCatchStats();

            // Disattiva modalita registrazione
            catchLogActive = false;
            const btn = document.getElementById('catchModeBtn');
            btn.innerHTML = '<i class="fas fa-map-marker-alt"></i> Segna';
            btn.style.background = '';

            return catchData.id;
        }

        // Variabile per editing
        let editingCatchId = null;
        let pendingCatchPhoto = null;

        // MODIFICA CATTURA - Apre dialog per aggiungere/modificare dettagli
        function editCatch(catchId) {
            const catchData = catches.find(c => c.id === catchId);
            if (!catchData) return;

            editingCatchId = catchId;

            const overlay = document.createElement('div');
            overlay.className = 'catch-dialog-overlay';
            overlay.id = 'catchDialogOverlay';
            overlay.innerHTML = `
                <div id="catchDialog" class="catch-dialog">
                    <h3 id="catchDialogHeader"><i class="fas fa-arrows-alt" style="font-size: 0.8em; opacity: 0.6; margin-right: 8px;"></i><i class="fas fa-edit"></i> ${catchData.type ? 'Modifica' : 'Completa'} Cattura</h3>

                    <div style="background: rgba(0,0,0,0.3); border-radius: 8px; padding: 12px; margin-bottom: 16px;">
                        <div style="font-size: 1.1rem; color: #7dd3fc; font-weight: 600; margin-bottom: 6px;">
                            <i class="fas fa-map-marker-alt"></i> ${formatCoordDDM(catchData.location.lat, catchData.location.lng)}
                            <span style="font-size: 0.85rem; color: #94a3b8; font-weight: 400;">(${catchData.location.source === 'gps' ? 'GPS' : 'Mappa'})</span>
                        </div>
                        <div style="font-size: 1rem; color: #e2e8f0;">
                            <i class="fas fa-clock"></i> ${new Date(catchData.timestamp).toLocaleString('it-IT')}
                        </div>
                    </div>

                    <div class="catch-form-group">
                        <label>Tipo Evento</label>
                        <div class="catch-type-grid" id="catchTypeGrid">
                            ${Object.entries(CATCH_TYPES).map(([key, val]) => `
                                <div class="catch-type-btn" data-type="${key}" onclick="selectCatchType('${key}')" style="--type-color: ${val.color}">
                                    <i class="fas ${val.icon}"></i>
                                    ${val.label}
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <div class="catch-form-group">
                        <label>Specie</label>
                        <select id="catchSpecies" onchange="handleSpeciesChange(this.value)">
                            <option value="">-- Seleziona --</option>
                            ${getAllSpecies().map(s => `<option value="${s.id}" ${catchData.species === s.id ? 'selected' : ''}>${s.label}</option>`).join('')}
                        </select>
                        <div id="customSpeciesGroup" style="display: none; margin-top: 8px;">
                            <input type="text" id="customSpeciesInput" placeholder="Nome specie..." style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #475569; background: #1e293b; color: #e2e8f0;">
                        </div>
                    </div>

                    <div class="catch-form-row">
                        <div class="catch-form-group" id="weightGroup" style="display: ${catchData.type === 'weighed_catch' ? 'block' : 'none'};">
                            <label>Peso (kg)</label>
                            <input type="number" id="catchWeight" step="0.1" min="0" placeholder="es. 45.5" value="${catchData.weight?.value || ''}">
                        </div>
                        <div class="catch-form-group">
                            <label>Profondita (m)</label>
                            <input type="number" id="catchDepth" step="1" min="0" placeholder="es. 120" value="${catchData.depth?.value || ''}">
                        </div>
                    </div>

                    <div class="catch-form-row">
                        <div class="catch-form-group">
                            <label>Esca</label>
                            <select id="catchBait">
                                <option value="">-- Seleziona --</option>
                                ${BAIT_TYPES.map(b => `<option value="${b.id}" ${catchData.bait === b.id ? 'selected' : ''}>${b.label}</option>`).join('')}
                            </select>
                        </div>
                        <div class="catch-form-group">
                            <label>Meteo</label>
                            <select id="catchWeather">
                                <option value="">-- Seleziona --</option>
                                ${WEATHER_OPTIONS.map(w => `<option value="${w.id}" ${catchData.weather === w.id ? 'selected' : ''}>${w.label}</option>`).join('')}
                            </select>
                        </div>
                    </div>

                    <div class="catch-form-group">
                        <label>Note</label>
                        <textarea id="catchNotes" rows="2" placeholder="Note aggiuntive...">${catchData.notes || ''}</textarea>
                    </div>

                    <div class="catch-form-group">
                        <label>Foto</label>
                        <div class="photo-upload-area ${catchData.photo ? 'has-photo' : ''}" id="photoUploadArea" onclick="document.getElementById('catchPhotoInput').click()">
                            ${catchData.photo
                                ? `<img src="${catchData.photo}" alt="Foto cattura">`
                                : `<i class="fas fa-camera"></i><p>Clicca per aggiungere foto</p>`
                            }
                        </div>
                        <input type="file" id="catchPhotoInput" accept="image/*" style="display: none;" onchange="handlePhotoUpload(event)">
                    </div>

                    <div class="catch-dialog-actions">
                        <button class="btn-cancel" onclick="closeCatchDialog()">Annulla</button>
                        <button class="btn-save" onclick="saveEditedCatch()">Salva</button>
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);

            // Rendi il dialog spostabile
            const dialogCD = document.getElementById('catchDialog');
            const headerCD = document.getElementById('catchDialogHeader');
            if (dialogCD && headerCD) {
                makeDraggable(dialogCD, headerCD);
            }

            // Pre-seleziona foto esistente
            if (catchData.photo) {
                pendingCatchPhoto = catchData.photo;
            }

            // Pre-seleziona tipo se presente
            if (catchData.type) {
                setTimeout(() => selectCatchType(catchData.type), 50);
            }
        }

        // Chiudi dialog
        function closeCatchDialog() {
            const overlay = document.getElementById('catchDialogOverlay');
            if (overlay) overlay.remove();
            editingCatchId = null;
            pendingCatchPhoto = null;
        }

        // Seleziona tipo cattura
        function selectCatchType(type) {
            document.querySelectorAll('.catch-type-btn').forEach(btn => {
                btn.classList.remove('selected');
                if (btn.dataset.type === type) {
                    btn.classList.add('selected');
                    btn.style.borderColor = CATCH_TYPES[type].color;
                    btn.style.background = `${CATCH_TYPES[type].color}33`;
                } else {
                    btn.style.borderColor = '#334155';
                    btn.style.background = 'rgba(30, 41, 59, 0.5)';
                }
            });
            // Mostra/nascondi campo peso
            const weightGroup = document.getElementById('weightGroup');
            if (weightGroup) {
                weightGroup.style.display = type === 'weighed_catch' ? 'block' : 'none';
            }
        }

        // Gestione selezione specie (mostra/nasconde input custom)
        function handleSpeciesChange(value) {
            const customGroup = document.getElementById('customSpeciesGroup');
            if (customGroup) {
                customGroup.style.display = value === '_custom_' ? 'block' : 'none';
                if (value === '_custom_') {
                    document.getElementById('customSpeciesInput').focus();
                }
            }
        }

        // Upload foto
        function handlePhotoUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                pendingCatchPhoto = e.target.result;
                const area = document.getElementById('photoUploadArea');
                area.classList.add('has-photo');
                area.innerHTML = `<img src="${pendingCatchPhoto}" alt="Foto cattura">`;
            };
            reader.readAsDataURL(file);
        }

        // Salva modifiche cattura
        function saveEditedCatch() {
            if (!editingCatchId) return;

            const catchIndex = catches.findIndex(c => c.id === editingCatchId);
            if (catchIndex === -1) return;

            const selectedType = document.querySelector('.catch-type-btn.selected');
            const type = selectedType ? selectedType.dataset.type : null;

            // Gestione specie (incluso custom)
            let species = document.getElementById('catchSpecies').value || null;
            if (species === '_custom_') {
                const customName = document.getElementById('customSpeciesInput').value.trim();
                if (!customName) {
                    showToast('Errore', 'Inserisci il nome della specie', 'error', 3000);
                    return;
                }
                // Salva la nuova specie personalizzata
                addCustomSpecies(customName);
                species = 'custom_' + customName.toLowerCase().replace(/\s+/g, '_');
            }

            const depth = document.getElementById('catchDepth').value;
            const bait = document.getElementById('catchBait').value || null;
            const weather = document.getElementById('catchWeather').value || null;
            const notes = document.getElementById('catchNotes').value;
            const weight = document.getElementById('catchWeight').value;

            // Aggiorna dati
            catches[catchIndex].type = type;
            catches[catchIndex].species = species;
            catches[catchIndex].weight = type === 'weighed_catch' && weight ? { value: parseFloat(weight), unit: 'kg' } : null;
            catches[catchIndex].depth = depth ? { value: parseInt(depth), unit: 'm' } : null;
            catches[catchIndex].bait = bait;
            catches[catchIndex].weather = weather;
            catches[catchIndex].notes = notes;
            catches[catchIndex].photo = pendingCatchPhoto;

            saveCatchesToStorage();
            closeCatchDialog();

            populateSpeciesFilter(); // Aggiorna filtro se nuova specie custom
            renderCatchList();
            renderCatchMarkers();
            updateCatchStats();

            showToast('Salvato!', 'Cattura aggiornata', 'info', 2000);
        }

        // Crea icona marker per cattura
        function createCatchMarkerIcon(type) {
            // Marker grigio per punti non ancora classificati
            if (!type) {
                return L.divIcon({
                    className: 'catch-marker-wrapper',
                    html: `<div class="catch-marker-icon new" style="background: #64748b;"><i class="fas fa-question"></i></div>`,
                    iconSize: [28, 28],
                    iconAnchor: [14, 14],
                    popupAnchor: [0, -14]
                });
            }
            const config = CATCH_TYPES[type] || CATCH_TYPES.strike;
            return L.divIcon({
                className: 'catch-marker-wrapper',
                html: `<div class="catch-marker-icon ${type}"><i class="fas ${config.icon}"></i></div>`,
                iconSize: [28, 28],
                iconAnchor: [14, 14],
                popupAnchor: [0, -14]
            });
        }

        // Render marker sulla mappa
        function renderCatchMarkers() {
            // Rimuovi marker esistenti
            catchMarkers.forEach(m => map.removeLayer(m));
            catchMarkers = [];

            // Applica filtri
            const filterType = document.getElementById('catchFilterType')?.value || 'all';
            const filterSpecies = document.getElementById('catchFilterSpecies')?.value || 'all';

            catches.forEach(c => {
                if (filterType !== 'all' && c.type !== filterType) return;
                if (filterSpecies !== 'all' && c.species !== filterSpecies) return;

                const marker = L.marker([c.location.lat, c.location.lng], {
                    icon: createCatchMarkerIcon(c.type)
                });

                const isIncomplete = !c.type || !c.species;

                if (isIncomplete) {
                    // Punto incompleto: click apre dialog modifica
                    const time = new Date(c.timestamp).toLocaleString('it-IT', { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' });
                    marker.bindPopup(`<strong>Punto da completare</strong><br><small>${time}</small><br><button onclick="editCatch('${c.id}')" style="margin-top:8px;padding:6px 12px;background:#f59e0b;color:#000;border:none;border-radius:4px;cursor:pointer;font-weight:600;">Completa dati</button>`);
                    marker.on('click', function(e) {
                        // Apri direttamente il dialog senza popup
                        editCatch(c.id);
                        L.DomEvent.stopPropagation(e);
                    });
                } else {
                    // Punto completo: mostra popup con dettagli
                    const speciesLabel = getSpeciesLabel(c.species) || c.species;
                    const typeLabel = CATCH_TYPES[c.type]?.label || c.type;
                    const time = new Date(c.timestamp).toLocaleString('it-IT', { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' });

                    let popupContent = `
                        <strong>${typeLabel}</strong><br>
                        <b>Specie:</b> ${speciesLabel}<br>
                        <b>Ora:</b> ${time}<br>
                    `;
                    if (c.weight) popupContent += `<b>Peso:</b> ${c.weight.value} ${c.weight.unit}<br>`;
                    if (c.depth) popupContent += `<b>Profondita:</b> ${c.depth.value} ${c.depth.unit}<br>`;
                    if (c.bait) popupContent += `<b>Esca:</b> ${BAIT_TYPES.find(b => b.id === c.bait)?.label || c.bait}<br>`;
                    if (c.notes) popupContent += `<b>Note:</b> ${c.notes}<br>`;
                    popupContent += `<button onclick="editCatch('${c.id}')" style="margin-top:8px;padding:4px 8px;background:#3b82f6;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:0.8rem;">Modifica</button>`;

                    marker.bindPopup(popupContent);
                }

                marker.addTo(map);
                catchMarkers.push(marker);
            });
        }

        // Render lista catture nella sidebar
        function renderCatchList() {
            const container = document.getElementById('catchListContainer');
            if (!container) return;

            const filterType = document.getElementById('catchFilterType')?.value || 'all';
            const filterSpecies = document.getElementById('catchFilterSpecies')?.value || 'all';

            const filtered = catches.filter(c => {
                if (filterType !== 'all' && c.type !== filterType) return false;
                if (filterSpecies !== 'all' && c.species !== filterSpecies) return false;
                return true;
            });

            if (filtered.length === 0) {
                container.innerHTML = `
                    <div class="catch-list-empty">
                        <i class="fas fa-fish"></i>
                        <p>Nessun punto registrato</p>
                        <small>Clicca "Segna" o "GPS" per iniziare</small>
                    </div>
                `;
                return;
            }

            // Ordina per data decrescente
            filtered.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

            container.innerHTML = filtered.map(c => {
                // Se non classificato: mostra "Da completare"
                const isComplete = c.type && c.species;
                const speciesLabel = c.species
                    ? (getSpeciesLabel(c.species) || c.species)
                    : 'Da completare';
                const typeConfig = c.type ? CATCH_TYPES[c.type] : null;
                const iconColor = typeConfig ? typeConfig.color : '#64748b';
                const iconClass = typeConfig ? typeConfig.icon : 'fa-question';
                const typeLabel = typeConfig ? typeConfig.label : 'Nuovo punto';
                const time = new Date(c.timestamp).toLocaleString('it-IT', { hour: '2-digit', minute: '2-digit' });
                const date = new Date(c.timestamp).toLocaleString('it-IT', { day: '2-digit', month: '2-digit' });

                return `
                    <div class="catch-list-item ${!isComplete ? 'incomplete' : ''}" onclick="editCatch('${c.id}')" title="Clicca per ${isComplete ? 'modificare' : 'completare'}">
                        <div class="catch-icon" style="background: ${iconColor}">
                            <i class="fas ${iconClass}"></i>
                        </div>
                        <div class="catch-info">
                            <div class="catch-species">${speciesLabel}</div>
                            <div class="catch-meta">${typeLabel} - ${date} ${time}</div>
                        </div>
                        <button class="catch-delete" onclick="event.stopPropagation(); deleteCatch('${c.id}')" title="Elimina">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;
            }).join('');
        }

        // Vai a cattura sulla mappa
        function goToCatch(catchId) {
            const c = catches.find(x => x.id === catchId);
            if (c) {
                map.setView([c.location.lat, c.location.lng], 14);
                // Apri popup del marker
                const marker = catchMarkers.find(m => {
                    const pos = m.getLatLng();
                    return Math.abs(pos.lat - c.location.lat) < 0.0001 && Math.abs(pos.lng - c.location.lng) < 0.0001;
                });
                if (marker) marker.openPopup();
            }
        }

        // Elimina cattura
        function deleteCatch(catchId) {
            if (!confirm('Eliminare questa cattura?')) return;
            catches = catches.filter(c => c.id !== catchId);
            saveCatchesToStorage();
            renderCatchList();
            renderCatchMarkers();
            updateCatchStats();
            showToast('Cattura eliminata', '', 'info', 2000);
        }

        // Applica filtri
        function applyCatchFilters() {
            renderCatchList();
            renderCatchMarkers();
        }

        // Aggiorna statistiche
        function updateCatchStats() {
            const today = new Date().toDateString();
            const todayCount = catches.filter(c => new Date(c.timestamp).toDateString() === today).length;
            const totalCount = catches.length;

            const todayEl = document.getElementById('todayCount');
            const totalEl = document.getElementById('totalCount');
            if (todayEl) todayEl.textContent = todayCount;
            if (totalEl) totalEl.textContent = totalCount;
        }

        // Export JSON
        function exportCatchesJSON() {
            if (catches.length === 0) {
                showToast('Nessun dato', 'Non ci sono catture da esportare', 'warning', 3000);
                return;
            }
            const dataStr = JSON.stringify(catches, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `catches_${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showToast('Export completato', `${catches.length} catture esportate`, 'info', 3000);
        }

        // Export CSV
        function exportCatchesCSV() {
            if (catches.length === 0) {
                showToast('Nessun dato', 'Non ci sono catture da esportare', 'warning', 3000);
                return;
            }
            const headers = ['ID', 'Tipo', 'Data/Ora', 'Lat', 'Lng', 'Specie', 'Peso (kg)', 'Profondita (m)', 'Esca', 'Meteo', 'Note'];
            const rows = catches.map(c => [
                c.id,
                CATCH_TYPES[c.type]?.label || c.type,
                new Date(c.timestamp).toLocaleString('it-IT'),
                c.location.lat.toFixed(6),
                c.location.lng.toFixed(6),
                getSpeciesLabel(c.species) || c.species,
                c.weight ? c.weight.value : '',
                c.depth ? c.depth.value : '',
                BAIT_TYPES.find(b => b.id === c.bait)?.label || c.bait,
                WEATHER_OPTIONS.find(w => w.id === c.weather)?.label || c.weather,
                c.notes ? `"${c.notes.replace(/"/g, '""')}"` : ''
            ]);

            const csv = [headers.join(';'), ...rows.map(r => r.join(';'))].join('\n');
            const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `catches_${new Date().toISOString().slice(0, 10)}.csv`;
            a.click();
            URL.revokeObjectURL(url);
            showToast('Export completato', `${catches.length} catture esportate`, 'info', 3000);
        }

        // ============================================
        // TOURNAMENT MODE SYSTEM
        // ============================================

        var tournamentTimerInterval = null;
        var tournamentZonePolygon = null;      // Poligono zona torneo sulla mappa
        var proximityWatchId = null;           // ID watch GPS per prossimita
        var proximityAlertActive = false;      // Stato allarme attivo
        const PROXIMITY_THRESHOLD_NM = 0.5;    // Soglia allarme in miglia nautiche (0.5nm = ~926m)

        // Toggle modalita torneo
        function toggleTournamentMode(enabled) {
            if (enabled) {
                showStartTournamentDialog();
            } else {
                if (activeTournament && activeTournament.catches.length > 0) {
                    endTournament();
                } else {
                    deactivateTournamentMode();
                }
            }
        }

        // Mostra dialog avvio torneo
        function showStartTournamentDialog() {
            // Trova zone disponibili
            const zones = typeof ZONES_DATA !== 'undefined' ? ZONES_DATA : [];
            const userZones = JSON.parse(localStorage.getItem('bathyExplorerUserZones') || '[]');
            const allZones = [...zones, ...userZones];

            const zoneOptions = allZones.map(z => `<option value="${z.id}">${z.name} - ${z.tournament}</option>`).join('');

            const dialogHTML = `
                <div id="startTournamentOverlay" style="position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000;">
                    <div style="background: linear-gradient(145deg, #1e293b 0%, #0f172a 100%); border-radius: 16px; padding: 24px; width: 90%; max-width: 400px; border: 1px solid rgba(239,68,68,0.3); box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
                        <h3 style="color: #fbbf24; margin: 0 0 20px 0; font-size: 1.2rem;">
                            <i class="fas fa-trophy"></i> Inizia Gara
                        </h3>

                        <div style="margin-bottom: 16px;">
                            <label style="color: #94a3b8; font-size: 0.85rem; display: block; margin-bottom: 6px;">Nome Gara *</label>
                            <input type="text" id="tournamentNameInput" placeholder="Es: Memorial Big Game 2026" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; font-size: 0.95rem; box-sizing: border-box;">
                        </div>

                        <div style="margin-bottom: 16px;">
                            <label style="color: #94a3b8; font-size: 0.85rem; display: block; margin-bottom: 6px;">Campo di Gara *</label>
                            <select id="tournamentZoneSelect" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; font-size: 0.95rem;">
                                <option value="">-- Seleziona campo --</option>
                                ${zoneOptions}
                            </select>
                            <div style="color: #64748b; font-size: 0.75rem; margin-top: 4px;">
                                Crea un campo in "Campi di Gara" se non ne hai
                            </div>
                        </div>

                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button onclick="cancelStartTournament()" style="flex: 1; padding: 12px; background: rgba(100,116,139,0.3); border: 1px solid rgba(100,116,139,0.5); border-radius: 8px; color: #94a3b8; cursor: pointer; font-size: 0.95rem;">
                                Annulla
                            </button>
                            <button onclick="confirmStartTournament()" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); border: none; border-radius: 8px; color: white; cursor: pointer; font-size: 0.95rem; font-weight: 600;">
                                <i class="fas fa-flag"></i> Inizia
                            </button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', dialogHTML);
            document.getElementById('tournamentNameInput').focus();
        }

        function cancelStartTournament() {
            document.getElementById('startTournamentOverlay')?.remove();
        }

        function confirmStartTournament() {
            const name = document.getElementById('tournamentNameInput').value.trim();
            if (!name) {
                showToast('Nome richiesto', 'Inserisci un nome per la gara', 'warning', 2000);
                return;
            }

            const zoneId = document.getElementById('tournamentZoneSelect').value;
            if (!zoneId) {
                showToast('Campo richiesto', 'Seleziona un campo di gara', 'warning', 2000);
                return;
            }

            // Trova dati zona
            const zones = typeof ZONES_DATA !== 'undefined' ? ZONES_DATA : [];
            const userZones = JSON.parse(localStorage.getItem('bathyExplorerUserZones') || '[]');
            const allZones = [...zones, ...userZones];
            const selectedZone = allZones.find(z => z.id === zoneId);

            activeTournament = {
                id: 'tournament_' + Date.now(),
                name: name,
                zoneId: zoneId,
                zoneName: selectedZone ? selectedZone.name : '',
                startDate: new Date().toISOString(),
                startTime: Date.now(),
                catches: []
            };

            tournamentMode = true;
            document.getElementById('startTournamentOverlay')?.remove();

            // Nascondi info e pulsante avvia, mostra pannello torneo
            document.getElementById('tournamentInfo').style.display = 'none';
            document.getElementById('startTournamentBtn').style.display = 'none';
            document.getElementById('tournamentPanel').style.display = 'block';
            document.getElementById('tournamentName').innerHTML = `<i class="fas fa-trophy"></i> ${name}`;
            document.getElementById('tournamentZoneName').textContent = selectedZone ? selectedZone.name : '';

            // Mostra zona sulla mappa
            if (selectedZone && selectedZone.vertices) {
                displayTournamentZone(selectedZone);
            }

            // Avvia monitoraggio prossimita
            startProximityMonitoring(selectedZone);

            // Avvia timer
            startTournamentTimer();

            updateTournamentUI();
            showToast('Gara Iniziata', `"${name}" - Buona fortuna!`, 'success', 3000);
        }

        function deactivateTournamentMode() {
            tournamentMode = false;
            activeTournament = null;

            // Ripristina UI sezione Gare
            document.getElementById('tournamentPanel').style.display = 'none';
            document.getElementById('tournamentInfo').style.display = 'block';
            document.getElementById('startTournamentBtn').style.display = 'flex';

            // Pulisci timer
            if (tournamentTimerInterval) {
                clearInterval(tournamentTimerInterval);
                tournamentTimerInterval = null;
            }

            // Rimuovi zona torneo dalla mappa
            if (tournamentZonePolygon) {
                if (tournamentZonePolygon.gatheringMarker) {
                    map.removeLayer(tournamentZonePolygon.gatheringMarker);
                }
                map.removeLayer(tournamentZonePolygon);
                tournamentZonePolygon = null;
            }

            // Ferma monitoraggio prossimita
            stopProximityMonitoring();
        }

        function startTournamentTimer() {
            if (tournamentTimerInterval) clearInterval(tournamentTimerInterval);
            tournamentTimerInterval = setInterval(() => {
                if (!activeTournament) return;
                const elapsed = Date.now() - activeTournament.startTime;
                const hours = Math.floor(elapsed / 3600000);
                const minutes = Math.floor((elapsed % 3600000) / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                document.getElementById('tournamentTimer').textContent =
                    `${hours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
            }, 1000);
        }

        // Mostra zona torneo sulla mappa con bordo evidenziato
        function displayTournamentZone(zone) {
            // Rimuovi eventuale zona precedente
            if (tournamentZonePolygon) {
                map.removeLayer(tournamentZonePolygon);
            }

            const latlngs = zone.vertices.map(v => [v.lat, v.lng]);

            // Crea poligono con stile evidenziato per gara
            tournamentZonePolygon = L.polygon(latlngs, {
                color: '#ef4444',           // Rosso bordo
                weight: 4,
                opacity: 1,
                fillColor: zone.color || '#ef4444',
                fillOpacity: 0.15,
                dashArray: '10, 5',         // Bordo tratteggiato
                className: 'tournament-zone'
            }).addTo(map);

            // Popup con info zona
            tournamentZonePolygon.bindPopup(`
                <div style="text-align: center;">
                    <strong style="color: #ef4444;">${zone.name}</strong><br>
                    <small>${zone.tournament || ''}</small><br>
                    <span style="color: #f59e0b;">ZONA GARA ATTIVA</span>
                </div>
            `);

            // Zoom per mostrare tutta la zona
            map.fitBounds(tournamentZonePolygon.getBounds(), { padding: [50, 50] });

            // Aggiungi marker punto raduno se presente
            if (zone.gatheringPoint) {
                const gatheringMarker = L.marker([zone.gatheringPoint.lat, zone.gatheringPoint.lng], {
                    icon: L.divIcon({
                        className: 'gathering-marker',
                        html: `<div style="background: #22c55e; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 16px; border: 3px solid white; box-shadow: 0 2px 10px rgba(0,0,0,0.4);">
                                <i class="fas fa-flag"></i>
                              </div>`,
                        iconSize: [32, 32],
                        iconAnchor: [16, 16]
                    })
                }).addTo(map);
                gatheringMarker.bindPopup(`<strong>Punto Raduno</strong><br>${zone.gatheringPoint.name || ''}`);

                // Salva riferimento per pulizia
                tournamentZonePolygon.gatheringMarker = gatheringMarker;
            }
        }

        // Avvia monitoraggio prossimita al limite zona
        function startProximityMonitoring(zone) {
            if (!zone || !zone.vertices || !navigator.geolocation) return;

            // Salva vertici zona per calcoli
            activeTournament.zoneVertices = zone.vertices;

            // Mostra indicatore prossimita nel panel
            updateProximityIndicator('ok', 'GPS attivo');

            // Avvia watch position
            proximityWatchId = navigator.geolocation.watchPosition(
                (pos) => {
                    checkProximityToZoneBoundary(pos.coords.latitude, pos.coords.longitude);
                },
                (err) => {
                    updateProximityIndicator('warning', 'GPS non disponibile');
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 5000
                }
            );
        }

        // Ferma monitoraggio prossimita
        function stopProximityMonitoring() {
            if (proximityWatchId) {
                navigator.geolocation.clearWatch(proximityWatchId);
                proximityWatchId = null;
            }
            proximityAlertActive = false;
            hideProximityAlert();
        }

        // Controlla distanza dal bordo zona
        function checkProximityToZoneBoundary(lat, lng) {
            if (!activeTournament || !activeTournament.zoneVertices) return;

            const vertices = activeTournament.zoneVertices;
            let minDistance = Infinity;

            // Calcola distanza minima da ogni lato del poligono
            for (let i = 0; i < vertices.length; i++) {
                const v1 = vertices[i];
                const v2 = vertices[(i + 1) % vertices.length];

                const dist = distanceToSegment(lat, lng, v1.lat, v1.lng, v2.lat, v2.lng);
                if (dist < minDistance) {
                    minDistance = dist;
                }
            }

            // Converti in miglia nautiche
            const distanceNm = minDistance / 1.852;

            // Verifica se dentro o fuori zona
            const isInside = isPointInPolygon(lat, lng, vertices);

            if (!isInside) {
                // FUORI dalla zona - allarme critico!
                showProximityAlert('critical', `FUORI ZONA! Rientra subito!`, 0);
                updateProximityIndicator('critical', 'FUORI ZONA');
            } else if (distanceNm <= PROXIMITY_THRESHOLD_NM) {
                // Vicino al bordo - warning
                const distMeters = Math.round(distanceNm * 1852);
                showProximityAlert('warning', `Attenzione: ${distMeters}m dal limite`, distanceNm);
                updateProximityIndicator('warning', `${distMeters}m dal limite`);
            } else {
                // OK - dentro zona con margine
                hideProximityAlert();
                const distMeters = Math.round(distanceNm * 1852);
                updateProximityIndicator('ok', `${distMeters}m dal limite`);
            }
        }

        // Calcola distanza punto-segmento in km
        function distanceToSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;

            if (lenSq !== 0) param = dot / lenSq;

            let xx, yy;

            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            // Calcola distanza in km usando Haversine
            return haversineDistance(px, py, xx, yy);
        }

        // Verifica se punto e dentro poligono (ray casting)
        function isPointInPolygon(lat, lng, vertices) {
            let inside = false;
            for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                const xi = vertices[i].lat, yi = vertices[i].lng;
                const xj = vertices[j].lat, yj = vertices[j].lng;

                if (((yi > lng) !== (yj > lng)) &&
                    (lat < (xj - xi) * (lng - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        // Mostra allarme prossimita visivo
        function showProximityAlert(level, message, distance) {
            let alertEl = document.getElementById('proximityAlert');

            if (!alertEl) {
                // Crea elemento allarme
                alertEl = document.createElement('div');
                alertEl.id = 'proximityAlert';
                alertEl.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    padding: 16px 32px;
                    border-radius: 12px;
                    font-size: 1.1rem;
                    font-weight: bold;
                    z-index: 10001;
                    display: flex;
                    align-items: center;
                    gap: 12px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
                    animation: pulse 1s infinite;
                `;
                document.body.appendChild(alertEl);

                // Aggiungi animazione CSS
                if (!document.getElementById('proximityAlertStyle')) {
                    const style = document.createElement('style');
                    style.id = 'proximityAlertStyle';
                    style.textContent = `
                        @keyframes pulse {
                            0%, 100% { transform: translateX(-50%) scale(1); }
                            50% { transform: translateX(-50%) scale(1.02); }
                        }
                        @keyframes flash {
                            0%, 50%, 100% { opacity: 1; }
                            25%, 75% { opacity: 0.7; }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }

            if (level === 'critical') {
                alertEl.style.background = 'linear-gradient(135deg, #dc2626 0%, #991b1b 100%)';
                alertEl.style.border = '3px solid #fca5a5';
                alertEl.style.color = 'white';
                alertEl.style.animation = 'flash 0.5s infinite';
                alertEl.innerHTML = `<i class="fas fa-exclamation-triangle"></i> ${message}`;
            } else {
                alertEl.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
                alertEl.style.border = '2px solid #fcd34d';
                alertEl.style.color = 'white';
                alertEl.style.animation = 'pulse 1s infinite';
                alertEl.innerHTML = `<i class="fas fa-bell"></i> ${message}`;
            }

            alertEl.style.display = 'flex';
            proximityAlertActive = true;
        }

        // Nascondi allarme prossimita
        function hideProximityAlert() {
            const alertEl = document.getElementById('proximityAlert');
            if (alertEl) {
                alertEl.style.display = 'none';
            }
            proximityAlertActive = false;
        }

        // Aggiorna indicatore prossimita nel panel torneo
        function updateProximityIndicator(status, text) {
            let indicator = document.getElementById('proximityIndicator');
            if (!indicator) return;

            const colors = {
                ok: '#22c55e',
                warning: '#f59e0b',
                critical: '#ef4444'
            };

            const icons = {
                ok: 'fa-check-circle',
                warning: 'fa-exclamation-circle',
                critical: 'fa-times-circle'
            };

            indicator.innerHTML = `<i class="fas ${icons[status]}" style="color: ${colors[status]};"></i> ${text}`;
            indicator.style.color = colors[status];
        }

        // Registra strike rapido (solo posizione e ora)
        function registerQuickStrike() {
            if (!activeTournament) return;

            // Effetto visivo pulsante
            const btn = document.getElementById('strikeBtn');
            btn.style.transform = 'scale(0.95)';
            setTimeout(() => btn.style.transform = 'scale(1)', 100);

            // Usa GPS se disponibile
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        addTournamentStrike(pos.coords.latitude, pos.coords.longitude);
                    },
                    (err) => {
                        // Fallback: usa centro mappa
                        const center = map.getCenter();
                        addTournamentStrike(center.lat, center.lng);
                        showToast('GPS non disponibile', 'Usata posizione mappa', 'warning', 2000);
                    },
                    { enableHighAccuracy: true, timeout: 5000 }
                );
            } else {
                const center = map.getCenter();
                addTournamentStrike(center.lat, center.lng);
            }
        }

        function addTournamentStrike(lat, lng) {
            const strike = {
                id: 'strike_' + Date.now(),
                type: 'strike',
                timestamp: new Date().toISOString(),
                location: { lat, lng },
                species: null,
                video: null,
                notes: null
            };

            activeTournament.catches.push(strike);

            // Aggiungi marker sulla mappa
            const marker = L.marker([lat, lng], {
                icon: L.divIcon({
                    className: 'catch-marker',
                    html: `<div style="background: #f59e0b; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 14px; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3); cursor: pointer;">
                            <i class="fas fa-bolt"></i>
                          </div>`,
                    iconSize: [28, 28],
                    iconAnchor: [14, 14]
                })
            }).addTo(map);

            marker.catchId = strike.id;
            marker.on('click', () => openStrikeDialog(strike.id));
            catchMarkers.push(marker);

            updateTournamentUI();
            showToast('Strike!', `${new Date().toLocaleTimeString('it-IT')} - ${formatCoordDDM(lat, lng)}`, 'success', 2000);
        }

        function updateTournamentUI() {
            if (!activeTournament) return;

            const strikes = activeTournament.catches.filter(c => c.type === 'strike').length;
            const releases = activeTournament.catches.filter(c => c.type === 'release').length;

            document.getElementById('tournamentStrikes').textContent = strikes;
            document.getElementById('tournamentReleases').textContent = releases;

            // Aggiorna lista
            const container = document.getElementById('tournamentCatchList');
            if (activeTournament.catches.length === 0) {
                container.innerHTML = `<div style="color: #64748b; font-size: 0.8rem; text-align: center; padding: 10px;">
                    Premi STRIKE! per registrare
                </div>`;
                return;
            }

            container.innerHTML = activeTournament.catches.slice().reverse().map(c => {
                const time = new Date(c.timestamp).toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });
                const isStrike = c.type === 'strike';
                const icon = isStrike ? 'fa-bolt' : 'fa-fish';
                const color = isStrike ? '#f59e0b' : '#22c55e';
                const species = c.species ? getSpeciesLabel(c.species) : 'Da completare';

                return `
                    <div onclick="openStrikeDialog('${c.id}')" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 6px; margin-bottom: 6px; cursor: pointer; border-left: 3px solid ${color};">
                        <i class="fas ${icon}" style="color: ${color};"></i>
                        <div style="flex: 1;">
                            <div style="color: #e2e8f0; font-size: 0.85rem;">${time}</div>
                            <div style="color: ${isStrike ? '#fbbf24' : '#94a3b8'}; font-size: 0.75rem;">${species}</div>
                        </div>
                        ${isStrike ? '<i class="fas fa-chevron-right" style="color: #64748b; font-size: 0.7rem;"></i>' : ''}
                    </div>
                `;
            }).join('');
        }

        // Dialog per completare/convertire strike
        function openStrikeDialog(catchId) {
            const catchData = activeTournament?.catches.find(c => c.id === catchId);
            if (!catchData) return;

            const isStrike = catchData.type === 'strike';
            const speciesOptions = getAllSpecies().map(s =>
                `<option value="${s.id}" ${catchData.species === s.id ? 'selected' : ''}>${s.label}</option>`
            ).join('');

            const dialogHTML = `
                <div id="strikeDialogOverlay" style="position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000;">
                    <div style="background: linear-gradient(145deg, #1e293b 0%, #0f172a 100%); border-radius: 16px; padding: 24px; width: 90%; max-width: 400px; border: 1px solid rgba(139,92,246,0.3); box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
                        <h3 style="color: ${isStrike ? '#fbbf24' : '#22c55e'}; margin: 0 0 16px 0; font-size: 1.1rem;">
                            <i class="fas ${isStrike ? 'fa-bolt' : 'fa-fish'}"></i>
                            ${isStrike ? 'Completa Strike' : 'Dettagli Rilascio'}
                        </h3>

                        <div style="color: #94a3b8; font-size: 0.8rem; margin-bottom: 16px;">
                            <i class="fas fa-clock"></i> ${new Date(catchData.timestamp).toLocaleString('it-IT')}<br>
                            <i class="fas fa-map-marker-alt"></i> ${formatCoordDDM(catchData.location.lat, catchData.location.lng)}
                        </div>

                        ${isStrike ? `
                        <div style="margin-bottom: 16px;">
                            <label style="color: #94a3b8; font-size: 0.85rem; display: block; margin-bottom: 6px;">Specie</label>
                            <select id="strikeSpecies" style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; font-size: 0.95rem;">
                                <option value="">-- Seleziona specie --</option>
                                ${speciesOptions}
                            </select>
                        </div>

                        <div style="margin-bottom: 16px;">
                            <label style="color: #94a3b8; font-size: 0.85rem; display: block; margin-bottom: 6px;">Video Rilascio</label>
                            <input type="file" id="strikeVideo" accept="video/*" style="width: 100%; padding: 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; font-size: 0.85rem; box-sizing: border-box;">
                        </div>

                        <div style="margin-bottom: 16px;">
                            <label style="color: #94a3b8; font-size: 0.85rem; display: block; margin-bottom: 6px;">Note</label>
                            <textarea id="strikeNotes" rows="2" placeholder="Osservazioni..." style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; font-size: 0.9rem; resize: none; box-sizing: border-box;">${catchData.notes || ''}</textarea>
                        </div>
                        ` : `
                        <div style="color: #e2e8f0; margin-bottom: 16px;">
                            <p><strong>Specie:</strong> ${getSpeciesLabel(catchData.species) || 'N/D'}</p>
                            ${catchData.video ? '<p><i class="fas fa-video" style="color: #22c55e;"></i> Video allegato</p>' : ''}
                            ${catchData.notes ? `<p><strong>Note:</strong> ${catchData.notes}</p>` : ''}
                        </div>
                        `}

                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button onclick="closeStrikeDialog()" style="flex: 1; padding: 12px; background: rgba(100,116,139,0.3); border: 1px solid rgba(100,116,139,0.5); border-radius: 8px; color: #94a3b8; cursor: pointer;">
                                ${isStrike ? 'Annulla' : 'Chiudi'}
                            </button>
                            ${isStrike ? `
                            <button onclick="convertToRelease('${catchId}')" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); border: none; border-radius: 8px; color: white; cursor: pointer; font-weight: 600;">
                                <i class="fas fa-fish"></i> Rilascio
                            </button>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', dialogHTML);
        }

        function closeStrikeDialog() {
            document.getElementById('strikeDialogOverlay')?.remove();
        }

        function convertToRelease(catchId) {
            const catchData = activeTournament?.catches.find(c => c.id === catchId);
            if (!catchData) return;

            const species = document.getElementById('strikeSpecies').value;
            const videoInput = document.getElementById('strikeVideo');
            const notes = document.getElementById('strikeNotes').value.trim();

            if (!species) {
                showToast('Specie richiesta', 'Seleziona la specie per il rilascio', 'warning', 2000);
                return;
            }

            // Aggiorna dati
            catchData.type = 'release';
            catchData.species = species;
            catchData.notes = notes || null;

            // Gestisci video
            if (videoInput.files && videoInput.files[0]) {
                const file = videoInput.files[0];
                catchData.videoName = file.name;
                catchData.videoSize = file.size;
                // Per ora salviamo solo i metadati, non il blob (localStorage ha limiti)
                catchData.video = true;
            }

            // Aggiorna marker
            const marker = catchMarkers.find(m => m.catchId === catchId);
            if (marker) {
                marker.setIcon(L.divIcon({
                    className: 'catch-marker',
                    html: `<div style="background: #22c55e; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 14px; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
                            <i class="fas fa-fish"></i>
                          </div>`,
                    iconSize: [28, 28],
                    iconAnchor: [14, 14]
                }));
            }

            closeStrikeDialog();
            updateTournamentUI();
            showToast('Rilascio Registrato', `${getSpeciesLabel(species)}`, 'success', 2000);
        }

        // Termina torneo
        function endTournament() {
            if (!activeTournament) {
                deactivateTournamentMode();
                return;
            }

            const strikes = activeTournament.catches.filter(c => c.type === 'strike').length;
            const releases = activeTournament.catches.filter(c => c.type === 'release').length;

            const dialogHTML = `
                <div id="endTournamentOverlay" style="position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000;">
                    <div style="background: linear-gradient(145deg, #1e293b 0%, #0f172a 100%); border-radius: 16px; padding: 24px; width: 90%; max-width: 400px; border: 1px solid rgba(251,191,36,0.3); box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
                        <h3 style="color: #fbbf24; margin: 0 0 16px 0; font-size: 1.2rem;">
                            <i class="fas fa-flag-checkered"></i> Fine Gara
                        </h3>

                        <div style="text-align: center; padding: 16px; background: rgba(0,0,0,0.2); border-radius: 10px; margin-bottom: 20px;">
                            <div style="color: #e2e8f0; font-size: 1.1rem; font-weight: 600; margin-bottom: 8px;">${activeTournament.name}</div>
                            <div style="display: flex; justify-content: center; gap: 30px;">
                                <div>
                                    <div style="font-size: 2rem; font-weight: bold; color: #f59e0b;">${strikes}</div>
                                    <div style="font-size: 0.8rem; color: #94a3b8;">Strike</div>
                                </div>
                                <div>
                                    <div style="font-size: 2rem; font-weight: bold; color: #22c55e;">${releases}</div>
                                    <div style="font-size: 0.8rem; color: #94a3b8;">Rilasci</div>
                                </div>
                            </div>
                        </div>

                        <p style="color: #94a3b8; font-size: 0.9rem; text-align: center; margin-bottom: 20px;">
                            Cosa vuoi fare con i dati della gara?
                        </p>

                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <button onclick="saveTournamentToCatches()" style="padding: 12px; background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); border: none; border-radius: 8px; color: white; cursor: pointer; font-size: 0.95rem;">
                                <i class="fas fa-save"></i> Salva nel Catch Log
                            </button>
                            <button onclick="exportAndCloseTournament()" style="padding: 12px; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); border: none; border-radius: 8px; color: white; cursor: pointer; font-size: 0.95rem;">
                                <i class="fas fa-download"></i> Esporta JSON e Chiudi
                            </button>
                            <button onclick="discardTournament()" style="padding: 12px; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); border: none; border-radius: 8px; color: white; cursor: pointer; font-size: 0.95rem;">
                                <i class="fas fa-trash"></i> Cancella Tutto
                            </button>
                            <button onclick="document.getElementById('endTournamentOverlay').remove()" style="padding: 10px; background: transparent; border: 1px solid rgba(100,116,139,0.5); border-radius: 8px; color: #94a3b8; cursor: pointer; font-size: 0.85rem;">
                                Continua Gara
                            </button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', dialogHTML);
        }

        function saveTournamentToCatches() {
            if (!activeTournament) return;

            // Aggiungi catches del torneo al catch log principale
            activeTournament.catches.forEach(c => {
                c.tournamentId = activeTournament.id;
                c.tournamentName = activeTournament.name;
                catches.push(c);
            });

            saveCatchesToStorage();
            renderCatchList();
            updateCatchStats();

            document.getElementById('endTournamentOverlay')?.remove();
            showToast('Dati Salvati', `${activeTournament.catches.length} registrazioni salvate nel Catch Log`, 'success', 3000);
            deactivateTournamentMode();
        }

        function exportAndCloseTournament() {
            if (!activeTournament) return;

            const exportData = {
                tournament: {
                    id: activeTournament.id,
                    name: activeTournament.name,
                    startDate: activeTournament.startDate,
                    endDate: new Date().toISOString(),
                    zoneId: activeTournament.zoneId
                },
                catches: activeTournament.catches,
                summary: {
                    totalStrikes: activeTournament.catches.filter(c => c.type === 'strike').length,
                    totalReleases: activeTournament.catches.filter(c => c.type === 'release').length
                }
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${activeTournament.name.replace(/\s+/g, '_')}_${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);

            // Rimuovi marker dalla mappa
            activeTournament.catches.forEach(c => {
                const marker = catchMarkers.find(m => m.catchId === c.id);
                if (marker) {
                    map.removeLayer(marker);
                    catchMarkers = catchMarkers.filter(m => m.catchId !== c.id);
                }
            });

            document.getElementById('endTournamentOverlay')?.remove();
            showToast('Export Completato', 'Dati gara esportati', 'success', 3000);
            deactivateTournamentMode();
        }

        function discardTournament() {
            if (!activeTournament) return;

            if (!confirm('Sei sicuro di voler cancellare tutti i dati della gara?')) return;

            // Rimuovi marker dalla mappa
            activeTournament.catches.forEach(c => {
                const marker = catchMarkers.find(m => m.catchId === c.id);
                if (marker) {
                    map.removeLayer(marker);
                    catchMarkers = catchMarkers.filter(m => m.catchId !== c.id);
                }
            });

            document.getElementById('endTournamentOverlay')?.remove();
            showToast('Dati Cancellati', 'I dati della gara sono stati eliminati', 'info', 3000);
            deactivateTournamentMode();
        }

        // Inizializza Catch Log quando DOM pronto
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(initCatchLog, 200);
        } else {
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(initCatchLog, 200);
            });
        }

        // ============================================
        // GPS TRACKING SYSTEM
        // ============================================

        // Variabili globali GPS Tracking
        var gpsWatchId = null;              // ID watchPosition per cleanup
        var gpsTrackingActive = false;      // Stato tracking attivo
        var gpsTrackingPaused = false;      // Stato pausa
        var gpsTrackPoints = [];            // Array punti tracciati {lat, lng, timestamp, speed, heading}
        var gpsBoatMarker = null;           // Marker barca sulla mappa
        var gpsTrackLine = null;            // Polyline percorso
        var gpsStartTime = null;            // Timestamp inizio tracking
        var gpsTotalDistance = 0;           // Distanza totale percorsa (nm)
        var gpsLastPosition = null;         // Ultima posizione nota
        var gpsSavedRoutes = [];            // Rotte salvate
        var gpsTrackColor = '#22c55e';      // Colore traccia (default verde)
        var boatAutoFollow = false;          // Auto-follow barca disattivato di default

        // ============================================
        // MIRINO CENTRALE - Visibilità su movimento mappa
        // ============================================
        var crosshairTimeout = null;

        function initCrosshair() {
            const crosshair = document.getElementById('mapCrosshair');
            if (!crosshair) return;

            // Mostra mirino quando si muove la mappa
            map.on('movestart', function() {
                crosshair.classList.add('active');
                if (crosshairTimeout) clearTimeout(crosshairTimeout);
            });

            map.on('move', function() {
                crosshair.classList.add('active');
                if (crosshairTimeout) clearTimeout(crosshairTimeout);
            });

            // Nascondi mirino quando la mappa si ferma (dopo 300ms)
            map.on('moveend', function() {
                if (crosshairTimeout) clearTimeout(crosshairTimeout);
                crosshairTimeout = setTimeout(function() {
                    crosshair.classList.remove('active');
                }, 300);
            });
        }

        // ============================================
        // ROSA DEI VENTI - Reset Nord in alto
        // ============================================
        function resetMapNorth() {
            // Leaflet di default ha sempre Nord in alto
            // Questa funzione può essere estesa per mappe rotabili
            showToast('Nord', 'La mappa è già orientata con il Nord in alto', 'info', 1500);
        }

        // ============================================
        // BOAT TRACKING - Auto-center quando esce dalla mappa
        // ============================================
        function isBoatInView() {
            if (!gpsBoatMarker) return true;
            const boatLatLng = gpsBoatMarker.getLatLng();
            const bounds = map.getBounds();
            return bounds.contains(boatLatLng);
        }

        function centerOnBoat() {
            if (!gpsBoatMarker) {
                showToast('GPS non attivo', 'Attiva il tracking GPS per vedere la barca', 'warning', 2000);
                return;
            }
            const boatLatLng = gpsBoatMarker.getLatLng();
            map.setView(boatLatLng, map.getZoom());
            showToast('Centrato', 'Mappa centrata sulla barca', 'info', 1000);
        }

        function checkBoatVisibility() {
            if (!gpsTrackingActive || !gpsBoatMarker) return;

            // Se la barca è fuori dalla vista, ricentralla
            if (!isBoatInView()) {
                centerOnBoat();
            }
        }

        // Carica rotte salvate da localStorage (o demo se vuoto)
        function loadSavedRoutes() {
            const saved = localStorage.getItem('bathyExplorerRoutes');
            if (saved) {
                gpsSavedRoutes = JSON.parse(saved);
                // Reset stato visibile (polyline non persistono tra sessioni)
                gpsSavedRoutes.forEach(route => {
                    route.visible = false;
                });
            }
            // Se nessuna rotta salvata, carica le demo
            if (gpsSavedRoutes.length === 0) {
                loadDemoRoutes();
            } else {
                renderRouteList();
            }
        }

        // Carica rotte demo - traversate da Forio
        function loadDemoRoutes() {
            // Se esistono già rotte, non sovrascrivere
            if (gpsSavedRoutes.length > 0) {
                showToast('Rotte esistenti', 'Hai già delle rotte salvate. Cancellale per caricare le demo.', 'info', 3000);
                return;
            }

            const demoRoutes = [
                // 1. Forio → Napoli via Procida (~25nm) - BLU
                // Rotta: Porto Forio → nord Ischia (mare aperto) → tra Ischia e Procida → nord Procida → Napoli
                {
                    id: 'demo-forio-napoli',
                    name: 'Forio → Napoli via Procida',
                    color: '#3b82f6',
                    distance: 25.3,
                    duration: 3 * 60 * 60 * 1000, // 3 ore
                    avgSpeed: 8.4,
                    date: new Date(Date.now() - 86400000).toISOString(),
                    visible: false,
                    points: [
                        // Partenza Porto Forio
                        {lat: 40.7353, lng: 13.8533, timestamp: 0},
                        // Uscita nord-ovest (mare aperto)
                        {lat: 40.7450, lng: 13.8400, timestamp: 1},
                        // Nord Ischia (al largo di Lacco Ameno)
                        {lat: 40.7650, lng: 13.8700, timestamp: 2},
                        // Nord-est Ischia (al largo di Casamicciola)
                        {lat: 40.7700, lng: 13.9100, timestamp: 3},
                        // Passaggio Ischia-Procida (canale)
                        {lat: 40.7680, lng: 13.9500, timestamp: 4},
                        // Nord Procida (al largo)
                        {lat: 40.7750, lng: 13.9900, timestamp: 5},
                        // Est Procida
                        {lat: 40.7700, lng: 14.0300, timestamp: 6},
                        // Traversata verso Napoli
                        {lat: 40.7800, lng: 14.0800, timestamp: 7},
                        {lat: 40.7950, lng: 14.1300, timestamp: 8},
                        {lat: 40.8100, lng: 14.1800, timestamp: 9},
                        {lat: 40.8250, lng: 14.2200, timestamp: 10},
                        // Arrivo Porto Napoli (Molo Beverello)
                        {lat: 40.8380, lng: 14.2550, timestamp: 11}
                    ]
                },
                // 2. Forio → Ponza via Ventotene (~48nm) - VERDE
                // Rotta: Porto Forio → sud-ovest mare aperto → Ventotene → Ponza
                {
                    id: 'demo-forio-ponza',
                    name: 'Forio → Ponza via Ventotene',
                    color: '#22c55e',
                    distance: 48.2,
                    duration: 5.5 * 60 * 60 * 1000, // 5h 30m
                    avgSpeed: 8.8,
                    date: new Date(Date.now() - 172800000).toISOString(),
                    visible: false,
                    points: [
                        // Partenza Porto Forio
                        {lat: 40.7353, lng: 13.8533, timestamp: 0},
                        // Uscita ovest (Punta Imperatore al largo)
                        {lat: 40.7200, lng: 13.8100, timestamp: 1},
                        // Sud-ovest mare aperto
                        {lat: 40.7100, lng: 13.7500, timestamp: 2},
                        {lat: 40.7150, lng: 13.6800, timestamp: 3},
                        // Rotta verso Ventotene
                        {lat: 40.7300, lng: 13.6000, timestamp: 4},
                        {lat: 40.7500, lng: 13.5200, timestamp: 5},
                        // Arrivo Ventotene (porto romano)
                        {lat: 40.7970, lng: 13.4330, timestamp: 6},
                        // Ripartenza Ventotene → Ponza
                        {lat: 40.8100, lng: 13.3800, timestamp: 7},
                        {lat: 40.8300, lng: 13.2800, timestamp: 8},
                        {lat: 40.8500, lng: 13.1800, timestamp: 9},
                        {lat: 40.8700, lng: 13.0800, timestamp: 10},
                        // Arrivo Ponza (porto)
                        {lat: 40.8950, lng: 12.9580, timestamp: 11}
                    ]
                },
                // 3. Forio → Sabaudia/Circeo (~58nm) - ARANCIONE
                // Rotta: Porto Forio → nord-ovest mare aperto → lungo costa laziale → Circeo
                {
                    id: 'demo-forio-sabaudia',
                    name: 'Forio → Sabaudia (Circeo)',
                    color: '#f97316',
                    distance: 58.5,
                    duration: 6.5 * 60 * 60 * 1000, // 6h 30m
                    avgSpeed: 9.0,
                    date: new Date(Date.now() - 259200000).toISOString(),
                    visible: false,
                    points: [
                        // Partenza Porto Forio
                        {lat: 40.7353, lng: 13.8533, timestamp: 0},
                        // Uscita nord-ovest (al largo Monte Vico)
                        {lat: 40.7600, lng: 13.8300, timestamp: 1},
                        // Nord-ovest mare aperto
                        {lat: 40.8000, lng: 13.7500, timestamp: 2},
                        {lat: 40.8500, lng: 13.6500, timestamp: 3},
                        // Traversata golfo di Gaeta
                        {lat: 40.9000, lng: 13.5500, timestamp: 4},
                        {lat: 40.9500, lng: 13.4500, timestamp: 5},
                        {lat: 41.0000, lng: 13.3500, timestamp: 6},
                        // Avvicinamento costa laziale
                        {lat: 41.0500, lng: 13.2500, timestamp: 7},
                        {lat: 41.1000, lng: 13.1800, timestamp: 8},
                        {lat: 41.1500, lng: 13.1200, timestamp: 9},
                        // Promontorio del Circeo
                        {lat: 41.2000, lng: 13.0800, timestamp: 10},
                        // Arrivo Sabaudia/Porto Badino
                        {lat: 41.2280, lng: 13.0500, timestamp: 11}
                    ]
                }
            ];

            gpsSavedRoutes = demoRoutes;
            saveSavedRoutes();
            renderRouteList();

            showToast('Rotte Caricate', `3 traversate da Forio pronte`, 'success', 3000);
        }

        // Formatta durata in HH:MM:SS
        function formatRouteDuration(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            }
            return `${minutes}m ${seconds}s`;
        }

        // Salva rotte nel localStorage
        function saveSavedRoutes() {
            localStorage.setItem('bathyExplorerRoutes', JSON.stringify(gpsSavedRoutes));
        }

        // Cambia colore traccia
        function changeTrackColor(color) {
            gpsTrackColor = color;
            // Aggiorna polyline attiva se esiste
            if (gpsTrackLine) {
                gpsTrackLine.setStyle({ color: color });
            }
        }

        // Toggle sezione collapsible generica
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.classList.toggle('collapsed');
            }
        }

        // ============================================
        // HELP POPUP SYSTEM
        // ============================================
        const helpContent = {
            // === SEZIONI PRINCIPALI ===
            search: {
                title: 'Cerca Posizione',
                content: `
                    <h4>Ricerca per Nome</h4>
                    <p>Digita il nome di un luogo nel campo di testo e clicca la lente di ricerca.</p>
                    <ul>
                        <li>Puoi cercare: citta, porti, isole, baie, promontori</li>
                        <li>I risultati appaiono sotto il campo - clicca per selezionare</li>
                        <li>La mappa si centra automaticamente sul luogo scelto</li>
                    </ul>
                    <h4>Ricerca per Coordinate GPS</h4>
                    <p>Inserisci le coordinate nei due campi separati:</p>
                    <ul>
                        <li><strong>Latitudine:</strong> Valore tra -90 e +90 (es. 40.7128)</li>
                        <li><strong>Longitudine:</strong> Valore tra -180 e +180 (es. 13.9500)</li>
                        <li>Clicca "Vai alle coordinate" per centrare la mappa</li>
                    </ul>
                    <h4>Salva nei Preferiti</h4>
                    <p>Clicca il pulsante stella per salvare la posizione corrente. Ti verra chiesto un nome per il luogo.</p>
                    <div class="tip">
                        <div class="tip-title">Formati coordinate accettati</div>
                        Decimale: 40.7128 | Gradi minuti: 40° 42.768' N
                    </div>
                `
            },
            favorites: {
                title: 'Luoghi Interessanti',
                content: `
                    <h4>I tuoi Preferiti</h4>
                    <p>Lista dei luoghi che hai salvato. I preferiti sono memorizzati nel browser.</p>
                    <h4>Come usarli</h4>
                    <ul>
                        <li><strong>Vai al luogo:</strong> Clicca sul nome per centrare la mappa</li>
                        <li><strong>Elimina:</strong> Clicca la X rossa accanto al nome</li>
                        <li><strong>Aggiungi:</strong> Usa il pulsante stella in "Cerca Posizione"</li>
                    </ul>
                    <h4>Persistenza</h4>
                    <p>I preferiti sono salvati in localStorage del browser:</p>
                    <ul>
                        <li>Rimangono anche chiudendo il browser</li>
                        <li>Funzionano offline</li>
                        <li>NON si sincronizzano tra dispositivi diversi</li>
                    </ul>
                    <div class="tip">
                        <div class="tip-title">Backup</div>
                        Per non perderli, esporta periodicamente i dati in JSON dalla sezione apposita!
                    </div>
                `
            },
            bathymetry: {
                title: 'Batimetria',
                content: `
                    <h4>Layer Profondita Disponibili</h4>
                    <p>Attiva/disattiva i layer con le checkbox:</p>
                    <ul>
                        <li><strong>EMODnet Batimetria:</strong> Layer europeo, ottima risoluzione nel Mediterraneo</li>
                        <li><strong>Alta Risoluzione (HR):</strong> Dettaglio maggiore dove disponibile</li>
                        <li><strong>GEBCO 2024:</strong> Dati globali ufficiali - usa questo fuori dall'Europa</li>
                        <li><strong>NOAA BlueTopo:</strong> Precisione navale per coste USA</li>
                        <li><strong>Esri Ocean Base:</strong> Vista globale consigliata come base</li>
                        <li><strong>Etichette Profondita:</strong> Nomi e annotazioni oceaniche</li>
                        <li><strong>Isobate:</strong> Linee di uguale profondita</li>
                    </ul>
                    <h4>Badge Copertura</h4>
                    <ul>
                        <li><span style="color:#22c55e">Europa</span> = solo mari europei</li>
                        <li><span style="color:#3b82f6">Globale</span> = tutto il mondo</li>
                        <li><span style="color:#f59e0b">USA</span> = solo coste americane</li>
                    </ul>
                    <div class="tip">
                        <div class="tip-title">Per la pesca Big Game</div>
                        Attiva le Isobate e cerca dove le linee sono molto ravvicinate: indica scarpate ripide dove i pelagici cacciano!
                    </div>
                `
            },
            fishing: {
                title: 'Layer Pesca Sportiva',
                content: `
                    <h4>Dati Oceanografici in Tempo Reale</h4>
                    <p>Questi layer mostrano condizioni aggiornate del mare:</p>

                    <h4>Temperatura Mare (SST)</h4>
                    <p>Fondamentale per localizzare i pelagici:</p>
                    <ul>
                        <li>Tonno rosso: 18-24°C</li>
                        <li>Tonno pinna gialla: 20-28°C</li>
                        <li>Pesce spada: 13-25°C (preferisce acque piu fresche)</li>
                    </ul>

                    <h4>Clorofilla</h4>
                    <p>Indica la produttivita biologica:</p>
                    <ul>
                        <li>Alta clorofilla = molto plancton = pesce foraggio = predatori!</li>
                        <li>Cerca le zone di transizione (fronti)</li>
                    </ul>

                    <h4>Correnti Marine</h4>
                    <p>I pesci si concentrano dove le correnti si incontrano o cambiano direzione.</p>

                    <h4>Onde e Vento</h4>
                    <p>Per pianificare l'uscita in sicurezza e scegliere la tecnica.</p>

                    <div class="tip">
                        <div class="tip-title">Strategia Professionale</div>
                        Sovrapponi SST + Clorofilla + Batimetria: dove una scarpata incontra una break termica con alta clorofilla hai lo spot perfetto!
                    </div>
                `
            },
            baseLayers: {
                title: 'Layer Base',
                content: `
                    <h4>Informazioni Nautiche</h4>

                    <h4>Segnali Nautici (OpenSeaMap)</h4>
                    <p>Mostra tutti i segnali marittimi:</p>
                    <ul>
                        <li>Boe cardinali e laterali</li>
                        <li>Fari e fanali</li>
                        <li>Canali di navigazione</li>
                        <li>Zone di ancoraggio</li>
                    </ul>

                    <h4>Porti e Marine</h4>
                    <p>Punti utili per:</p>
                    <ul>
                        <li>Rifornimento carburante</li>
                        <li>Ormeggio</li>
                        <li>Servizi nautici</li>
                    </ul>

                    <h4>Vista Satellite</h4>
                    <p>Immagini aeree reali - utile per vedere la conformazione della costa.</p>

                    <h4>Aree Marine Protette (AMP)</h4>
                    <p>IMPORTANTE: Mostra le zone con restrizioni di pesca in Europa.</p>
                    <ul>
                        <li>Zone A: divieto totale</li>
                        <li>Zone B: pesca regolamentata</li>
                        <li>Zone C: limitazioni minori</li>
                    </ul>

                    <div class="tip">
                        <div class="tip-title">Attenzione</div>
                        Verifica SEMPRE le AMP prima di pescare - le sanzioni vanno da 1.000 a 50.000 euro!
                    </div>
                `
            },
            display: {
                title: 'Controlli Display',
                content: `
                    <h4>Regolazione Visualizzazione</h4>

                    <h4>Opacita Batimetria (0-100%)</h4>
                    <p>Controlla la trasparenza dei layer di profondita:</p>
                    <ul>
                        <li><strong>0%:</strong> Layer completamente trasparente (invisibile)</li>
                        <li><strong>40%:</strong> Valore consigliato - vedi batimetria e mappa base</li>
                        <li><strong>100%:</strong> Layer completamente opaco</li>
                    </ul>
                    <p>Trascina lo slider o clicca per regolare.</p>

                    <h4>Luminosita Mappa (50-200%)</h4>
                    <p>Schiarisci o scurisci la mappa base:</p>
                    <ul>
                        <li><strong>50%:</strong> Mappa molto scura</li>
                        <li><strong>100%:</strong> Luminosita normale</li>
                        <li><strong>200%:</strong> Mappa molto chiara</li>
                    </ul>

                    <div class="tip">
                        <div class="tip-title">Uso pratico</div>
                        Abbassa l'opacita al 20-30% quando vuoi vedere bene i segnali nautici sotto la batimetria.
                    </div>
                `
            },
            ruler: {
                title: 'Righello',
                content: `
                    <h4>Strumento di Misurazione</h4>

                    <h4>Pulsante "Misura"</h4>
                    <p>Attiva la modalita misurazione:</p>
                    <ol>
                        <li>Clicca "Misura" (diventa verde)</li>
                        <li>Clicca sulla mappa per aggiungere punti</li>
                        <li>La distanza totale appare in tempo reale</li>
                        <li>Clicca di nuovo "Misura" per disattivare</li>
                    </ol>

                    <h4>Pulsante "Modifica"</h4>
                    <p>Appare dopo aver creato punti:</p>
                    <ul>
                        <li>Trascina i marker per spostare i punti</li>
                        <li>La distanza si aggiorna in tempo reale</li>
                    </ul>

                    <h4>Chiusura Poligono</h4>
                    <p>Per calcolare un'area:</p>
                    <ol>
                        <li>Crea almeno 3 punti</li>
                        <li>Clicca sul PRIMO punto per chiudere</li>
                        <li>Viene mostrata la superficie in nm² e km²</li>
                    </ol>

                    <h4>Pulsante "Pulisci"</h4>
                    <p>Rimuove tutti i punti e ricomincia da zero.</p>

                    <div class="tip">
                        <div class="tip-title">Conversione</div>
                        1 miglio nautico (nm) = 1.852 km = 1852 metri
                    </div>
                `
            },
            zones: {
                title: 'Campi di Gara',
                content: `
                    <h4>Gestione Zone Torneo</h4>

                    <h4>Seleziona Campo</h4>
                    <p>Usa il menu a tendina per scegliere tra i campi disponibili (predefiniti + tuoi).</p>

                    <h4>Pulsanti Azione</h4>
                    <ul>
                        <li><strong>Vai:</strong> Centra la mappa sul campo selezionato</li>
                        <li><strong>Modifica:</strong> Apre l'editor del campo</li>
                        <li><strong>Elimina:</strong> Rimuove il campo (solo campi utente)</li>
                        <li><strong>Esporta:</strong> Scarica tutti i campi in JSON</li>
                    </ul>

                    <h4>Mostra Zona Gara</h4>
                    <p>Checkbox per visualizzare/nascondere il perimetro sulla mappa.</p>

                    <h4>Sposta Centro</h4>
                    <p>Per campi creati con centro+raggio: apre un dialog per modificare posizione e raggio.</p>

                    <h4>Nuovo Campo (Centro + Raggio)</h4>
                    <p>Crea un nuovo campo di gara - vedi guida dedicata (?) sul pulsante.</p>

                    <div class="tip">
                        <div class="tip-title">Editing Rapido</div>
                        Clicca sulla bandiera verde del punto raduno per entrare in modalita editing diretto!
                    </div>
                `
            },
            tournament: {
                title: 'Modalita Gara',
                content: `
                    <h4>Sistema Competizione per Tornei</h4>
                    <p>Modalita speciale per gare di pesca sportiva con registrazione rapida e monitoraggio zona.</p>

                    <h4>Avvio Gara</h4>
                    <ol>
                        <li>Clicca "Avvia Gara"</li>
                        <li>Inserisci nome torneo</li>
                        <li><strong>Seleziona campo di gara</strong> (obbligatorio)</li>
                        <li>La mappa zooma sul campo selezionato</li>
                    </ol>

                    <h4>Pulsante STRIKE</h4>
                    <p>Registrazione istantanea di un evento di pesca:</p>
                    <ul>
                        <li><strong>1 click:</strong> Registra strike con GPS e timestamp</li>
                        <li>Marker giallo con fulmine sulla mappa</li>
                        <li>Click sul marker per convertire in rilascio</li>
                    </ul>

                    <h4>Conversione Strike → Rilascio</h4>
                    <ul>
                        <li>Seleziona specie dalla lista</li>
                        <li>Aggiungi video (opzionale)</li>
                        <li>Il marker diventa verde con pesce</li>
                    </ul>

                    <h4>Allarme Prossimita</h4>
                    <p>Se usi GPS, il sistema ti avvisa:</p>
                    <ul>
                        <li><strong>Giallo:</strong> Entro 0.5 nm dal confine</li>
                        <li><strong>Rosso:</strong> FUORI ZONA - rientra!</li>
                    </ul>

                    <h4>Fine Gara</h4>
                    <p>Tre opzioni disponibili:</p>
                    <ul>
                        <li><strong>Salva nel Catch Log:</strong> Integra nel registro principale</li>
                        <li><strong>Esporta JSON:</strong> Scarica file con tutti i dati</li>
                        <li><strong>Cancella:</strong> Elimina senza salvare</li>
                    </ul>

                    <div class="tip">
                        <div class="tip-title">Statistiche Live</div>
                        Timer, contatori Strike/Rilasci e lista catture aggiornati in tempo reale!
                    </div>
                `
            },
            catchLog: {
                title: 'Catch Log',
                content: `
                    <h4>Registro Catture - Sistema in 2 Passi</h4>

                    <h4>PASSO 1: Segna il Punto</h4>
                    <p>Due modalita disponibili:</p>
                    <ul>
                        <li><strong>Segna:</strong> Clicca il pulsante, poi clicca sulla mappa</li>
                        <li><strong>GPS:</strong> Usa la posizione attuale dello smartphone</li>
                    </ul>
                    <p>Il punto viene salvato SUBITO con coordinate e timestamp.</p>

                    <h4>PASSO 2: Completa i Dettagli</h4>
                    <p>Clicca sul punto (marker o lista) per aggiungere:</p>
                    <ul>
                        <li><strong>Tipo:</strong> Strike, Rilascio, Avvistamento, Cattura Pesata</li>
                        <li><strong>Specie:</strong> 18 specie italiane + custom</li>
                        <li><strong>Dati:</strong> Peso, profondita, esca, meteo, note</li>
                    </ul>

                    <h4>Filtri</h4>
                    <p>Usa i dropdown per filtrare la lista per tipo o specie.</p>

                    <h4>Statistiche</h4>
                    <p>Mostra il conteggio catture di oggi e totale.</p>

                    <h4>Export</h4>
                    <ul>
                        <li><strong>JSON:</strong> Per backup o import in altre app</li>
                        <li><strong>CSV:</strong> Per aprire in Excel/Fogli Google</li>
                    </ul>

                    <div class="tip">
                        <div class="tip-title">Punti incompleti</div>
                        I punti non ancora completati hanno marker grigio con "?" e bordo arancione nella lista.
                    </div>
                `
            },
            gpsTracking: {
                title: 'GPS Tracking',
                content: `
                    <h4>Tracciamento Rotta di Navigazione</h4>

                    <h4>Attivare il Tracking</h4>
                    <ol>
                        <li>Attiva lo switch "Tracking Attivo"</li>
                        <li>Consenti l'accesso GPS quando richiesto</li>
                        <li>Un'icona barca appare sulla tua posizione</li>
                    </ol>

                    <h4>Durante la Navigazione</h4>
                    <p>Vedi in tempo reale:</p>
                    <ul>
                        <li><strong>Velocita:</strong> In nodi (kn)</li>
                        <li><strong>Direzione:</strong> Bussola (N, NE, E, ecc.)</li>
                        <li><strong>Distanza:</strong> Miglia nautiche percorse</li>
                        <li><strong>Durata:</strong> Tempo di navigazione</li>
                    </ul>

                    <h4>Controlli</h4>
                    <ul>
                        <li><strong>Colore traccia:</strong> Clicca il quadratino colorato</li>
                        <li><strong>Pausa:</strong> Sospende senza perdere dati</li>
                        <li><strong>Cancella:</strong> Elimina la traccia corrente</li>
                        <li><strong>Salva Rotta:</strong> Memorizza con nome (max 10)</li>
                    </ul>

                    <h4>Rotte Salvate</h4>
                    <ul>
                        <li><strong>Occhio:</strong> Mostra/nascondi sulla mappa</li>
                        <li><strong>Download:</strong> Esporta in GPX</li>
                        <li><strong>Cestino:</strong> Elimina la rotta</li>
                    </ul>

                    <h4>Export Globale</h4>
                    <p>I pulsanti GPX/GeoJSON esportano TUTTE le rotte insieme.</p>

                    <div class="tip">
                        <div class="tip-title">Demo</div>
                        Usa "Demo: Forio -> Campo Gara" per testare senza GPS reale!
                    </div>
                `
            },
            legend: {
                title: 'Legende',
                content: `
                    <h4>Interpretazione Colori dei Layer</h4>

                    <h4>Profondita (Batimetria)</h4>
                    <table style="width:100%; font-size:0.85rem;">
                        <tr><td style="background:#f8e0e0; color:#000; padding:4px;">Rosa</td><td>0-50m (sottocosta)</td></tr>
                        <tr><td style="background:#cef4f2; color:#000; padding:4px;">Celeste</td><td>50-100m</td></tr>
                        <tr><td style="background:#7bc8c4; color:#000; padding:4px;">Verde acqua</td><td>200-500m</td></tr>
                        <tr><td style="background:#3d8a85; color:#fff; padding:4px;">Verde scuro</td><td>1000-2000m</td></tr>
                        <tr><td style="background:#1a4d4a; color:#fff; padding:4px;">Verde molto scuro</td><td>>4000m (abissi)</td></tr>
                    </table>

                    <h4>Temperatura Mare (SST)</h4>
                    <table style="width:100%; font-size:0.85rem; margin-top:8px;">
                        <tr><td style="background:#313695; color:#fff; padding:4px;">Blu scuro</td><td>&lt;18°C (freddo)</td></tr>
                        <tr><td style="background:#74add1; color:#000; padding:4px;">Azzurro</td><td>20-22°C</td></tr>
                        <tr><td style="background:#fee090; color:#000; padding:4px;">Giallo</td><td>24-26°C (ideale tonni)</td></tr>
                        <tr><td style="background:#d73027; color:#fff; padding:4px;">Rosso</td><td>>30°C (tropicale)</td></tr>
                    </table>

                    <h4>Clorofilla</h4>
                    <ul>
                        <li><span style="color:#440154">Viola scuro:</span> Bassa produttivita</li>
                        <li><span style="color:#35b779">Verde:</span> Media produttivita</li>
                        <li><span style="color:#fde725">Giallo:</span> Alta produttivita (ottimo!)</li>
                    </ul>

                    <div class="tip">
                        <div class="tip-title">Per la pesca</div>
                        Le zone di transizione (fronti) dove i colori cambiano bruscamente sono i migliori spot!
                    </div>
                `
            },
            position: {
                title: 'Posizione Corrente',
                content: `
                    <h4>Informazioni sulla Vista Mappa</h4>

                    <h4>Centro</h4>
                    <p>Mostra le coordinate (latitudine, longitudine) del centro attuale della mappa in formato decimale.</p>

                    <h4>Zoom</h4>
                    <p>Livello di ingrandimento corrente:</p>
                    <ul>
                        <li><strong>1-5:</strong> Vista continente/nazione</li>
                        <li><strong>6-10:</strong> Vista regionale</li>
                        <li><strong>11-14:</strong> Vista locale (porto, baia)</li>
                        <li><strong>15-18:</strong> Dettaglio massimo</li>
                    </ul>

                    <h4>Luogo</h4>
                    <p>Nome del luogo rilevato automaticamente tramite geocoding inverso.</p>

                    <div class="tip">
                        <div class="tip-title">Copia coordinate</div>
                        Seleziona il testo delle coordinate con il mouse per copiarle negli appunti!
                    </div>
                `
            },

            offline: {
                title: 'Mappe Offline',
                content: `
                    <h4>Navigazione Senza Internet</h4>
                    <p>Scarica le mappe prima di uscire in mare per usarle senza connessione.</p>

                    <h4>Come Funziona</h4>
                    <ol>
                        <li><strong>Seleziona il campo di gara</strong> dal menu</li>
                        <li><strong>Clicca "Scarica"</strong> per salvare le mappe</li>
                        <li>Le mappe coprono: porto → campo gara + 10nm di tolleranza</li>
                    </ol>

                    <h4>Cosa Viene Salvato</h4>
                    <ul>
                        <li>Mappe base OpenStreetMap</li>
                        <li>Layer batimetrici (se attivi)</li>
                        <li>Zoom dal livello 8 al 14</li>
                    </ul>

                    <h4>Prima della Gara</h4>
                    <p>Esegui il download quando sei ancora in WiFi alla Marina. Il download puo richiedere 5-15 minuti.</p>

                    <div class="tip">
                        <div class="tip-title">Importante</div>
                        SST e Correnti NON sono disponibili offline perche cambiano ogni ora.
                        Consulta i dati meteo prima di partire!
                    </div>
                `
            },

            // === FUNZIONI SPECIFICHE ===
            createZone: {
                title: 'Nuovo Campo (Centro + Raggio)',
                content: `
                    <h4>Creazione Campo di Gara</h4>
                    <p>Crea un nuovo campo partendo da un punto centrale e un raggio.</p>

                    <h4>Compilazione Form</h4>
                    <ol>
                        <li><strong>Nome Campo:</strong> Identificativo (es. "Big Game Ischia 2026")</li>
                        <li><strong>Nome Torneo:</strong> Competizione associata</li>
                        <li><strong>Latitudine/Longitudine:</strong> Centro del campo
                            <ul>
                                <li>Inserisci manualmente</li>
                                <li>Oppure clicca "Seleziona da mappa"</li>
                            </ul>
                        </li>
                        <li><strong>Raggio:</strong> Distanza dal centro al bordo</li>
                        <li><strong>Unita:</strong> Miglia nautiche (nm) o chilometri (km)</li>
                        <li><strong>Tipo Zona:</strong>
                            <ul>
                                <li>Cerchio completo (360°)</li>
                                <li>Semicerchio (180°) - varie orientazioni</li>
                                <li>Quadrato, Rettangolo</li>
                                <li>Triangolo</li>
                            </ul>
                        </li>
                        <li><strong>Colore:</strong> Per distinguere il campo sulla mappa</li>
                    </ol>

                    <h4>Dopo la Creazione</h4>
                    <p>Il campo appare nel dropdown e puo essere:</p>
                    <ul>
                        <li>Visualizzato con "Mostra Zona"</li>
                        <li>Modificato con "Sposta Centro"</li>
                        <li>Eliminato (solo campi utente)</li>
                    </ul>

                    <div class="tip">
                        <div class="tip-title">Vertici</div>
                        Il sistema genera automaticamente un poligono con 21-36 vertici. Puoi modificarli dopo con l'editing.
                    </div>
                `
            },
            editCenter: {
                title: 'Sposta Centro',
                content: `
                    <h4>Modifica Campo Esistente</h4>
                    <p>Permette di spostare il centro e modificare il raggio di un campo creato con centro+raggio.</p>

                    <h4>Come Usarlo</h4>
                    <ol>
                        <li>Seleziona un campo dal dropdown</li>
                        <li>Clicca "Sposta Centro"</li>
                        <li>Si apre un dialog con:
                            <ul>
                                <li>Coordinate centro (modificabili)</li>
                                <li>Raggio (modificabile)</li>
                                <li>Marker viola trascinabile sulla mappa</li>
                            </ul>
                        </li>
                        <li>Trascina il marker VIOLA per spostare il centro</li>
                        <li>Il poligono si aggiorna in tempo reale</li>
                        <li>Clicca "Applica" per confermare o "Annulla"</li>
                    </ol>

                    <h4>Editing Vertici</h4>
                    <p>Durante la modifica compaiono anche i pallini sui vertici:</p>
                    <ul>
                        <li><strong>Trascina:</strong> Sposta un singolo vertice</li>
                        <li><strong>Doppio-click:</strong> Elimina il vertice (minimo 3)</li>
                    </ul>

                    <div class="tip">
                        <div class="tip-title">Metodo Rapido</div>
                        Clicca direttamente sulla BANDIERA VERDE del punto raduno per entrare in editing senza aprire il dialog!
                    </div>
                `
            },
            catchMark: {
                title: 'Segna Punto Cattura',
                content: `
                    <h4>Registrazione Rapida</h4>
                    <p>Il pulsante "Segna" attiva la modalita registrazione cattura.</p>

                    <h4>Come Funziona</h4>
                    <ol>
                        <li>Clicca "Segna" - il pulsante diventa verde</li>
                        <li>Clicca sulla mappa nel punto esatto</li>
                        <li>Il punto viene salvato IMMEDIATAMENTE con:
                            <ul>
                                <li>Coordinate precise</li>
                                <li>Data e ora esatta</li>
                                <li>Stato "da completare"</li>
                            </ul>
                        </li>
                        <li>La modalita si disattiva automaticamente</li>
                    </ol>

                    <h4>Alternativa: Pulsante GPS</h4>
                    <p>Su smartphone, usa "GPS" per registrare la tua posizione attuale senza cliccare sulla mappa.</p>

                    <h4>Dopo il Salvataggio</h4>
                    <p>Il punto appare:</p>
                    <ul>
                        <li>Sulla mappa come marker grigio con "?"</li>
                        <li>Nella lista con bordo arancione pulsante</li>
                    </ul>
                    <p>Clicca sul punto per completare i dettagli quando hai tempo.</p>

                    <div class="tip">
                        <div class="tip-title">In Azione</div>
                        Al momento dello strike, clicca velocemente Segna+Mappa. Completerai i dettagli dopo!
                    </div>
                `
            },
            routeSave: {
                title: 'Salva Rotta',
                content: `
                    <h4>Salvataggio Percorso GPS</h4>
                    <p>Memorizza la rotta corrente per rivederla in futuro.</p>

                    <h4>Quando Salvare</h4>
                    <p>Il pulsante "Salva Rotta" appare quando:</p>
                    <ul>
                        <li>Il tracking GPS e attivo</li>
                        <li>Hai registrato almeno alcuni punti</li>
                    </ul>

                    <h4>Procedura</h4>
                    <ol>
                        <li>Clicca "Salva Rotta"</li>
                        <li>Si apre un dialog con preview:
                            <ul>
                                <li>Colore della traccia (quello impostato)</li>
                                <li>Distanza totale percorsa</li>
                                <li>Numero di punti registrati</li>
                            </ul>
                        </li>
                        <li>Inserisci un nome descrittivo</li>
                        <li>Clicca "Salva"</li>
                    </ol>

                    <h4>Limite</h4>
                    <p>Puoi salvare massimo <strong>10 rotte</strong>. Il contatore mostra "X/10".</p>
                    <p>Per salvarne altre, elimina prima quelle vecchie.</p>

                    <h4>Cosa Viene Salvato</h4>
                    <ul>
                        <li>Tutti i punti GPS (coordinate + timestamp)</li>
                        <li>Colore della traccia</li>
                        <li>Statistiche (distanza, durata)</li>
                    </ul>

                    <div class="tip">
                        <div class="tip-title">Persistenza</div>
                        Le rotte sono salvate in localStorage e rimangono anche chiudendo il browser.
                    </div>
                `
            },
            routeExport: {
                title: 'Export Rotte',
                content: `
                    <h4>Formati di Esportazione</h4>

                    <h4>GPX (GPS Exchange Format)</h4>
                    <p>Standard universale per GPS:</p>
                    <ul>
                        <li>Compatibile con: Garmin, Navionics, OpenCPN, Locus Map</li>
                        <li>Contiene: punti, tracce, waypoint</li>
                        <li>Include estensione colore (gpx_style)</li>
                    </ul>

                    <h4>GeoJSON</h4>
                    <p>Formato per applicazioni web e GIS:</p>
                    <ul>
                        <li>Compatibile con: QGIS, ArcGIS, Leaflet, Mapbox</li>
                        <li>Struttura JSON leggibile</li>
                        <li>Include proprieta stroke per colore</li>
                    </ul>

                    <h4>Export Singola Rotta</h4>
                    <p>Clicca l'icona download accanto alla rotta nella lista.</p>

                    <h4>Export Tutte le Rotte</h4>
                    <p>Usa i pulsanti GPX/GeoJSON in fondo alla sezione per esportare tutto insieme.</p>

                    <div class="tip">
                        <div class="tip-title">Backup</div>
                        Esporta periodicamente in GeoJSON per avere un backup delle tue rotte preferite!
                    </div>
                `
            }
        };

        function showHelp(section) {
            const content = helpContent[section];
            if (!content) return;

            document.getElementById('helpPopupTitle').textContent = content.title;
            document.getElementById('helpPopupContent').innerHTML = content.content;
            document.getElementById('helpPopupOverlay').classList.add('show');
        }

        function closeHelp() {
            document.getElementById('helpPopupOverlay').classList.remove('show');
        }

        // Chiudi help con Escape
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeHelp();
            }
        });

        // Toggle GPS Tracking on/off
        function toggleGpsTracking(enabled) {
            if (enabled) {
                startGpsTracking();
            } else {
                stopGpsTracking();
            }
        }

        // Avvia GPS Tracking
        function startGpsTracking() {
            if (!navigator.geolocation) {
                showToast('Non supportato', 'Il tuo browser non supporta la geolocalizzazione', 'danger', 3000);
                document.getElementById('gpsTrackingSwitch').checked = false;
                return;
            }

            // Reset dati
            gpsTrackPoints = [];
            gpsTotalDistance = 0;
            gpsLastPosition = null;
            gpsStartTime = Date.now();
            gpsTrackingActive = true;
            gpsTrackingPaused = false;

            // Mostra stats e controlli
            document.getElementById('gpsStats').style.display = 'grid';
            document.getElementById('trackingControls').style.display = 'block';
            updatePauseButton();

            // Crea marker barca
            createBoatMarker();

            // Crea polyline percorso
            gpsTrackLine = L.polyline([], {
                color: gpsTrackColor,
                weight: 2,
                opacity: 0.9,
                dashArray: null
            }).addTo(map);

            // Avvia watchPosition
            gpsWatchId = navigator.geolocation.watchPosition(
                onGpsPositionUpdate,
                onGpsError,
                {
                    enableHighAccuracy: true,
                    maximumAge: 5000,
                    timeout: 15000
                }
            );

            showToast('Tracking avviato', 'GPS attivo - segui la tua rotta', 'success', 2000);
        }

        // Stop GPS Tracking (senza cancellare dati)
        function stopGpsTracking() {
            if (gpsWatchId !== null) {
                navigator.geolocation.clearWatch(gpsWatchId);
                gpsWatchId = null;
            }
            gpsTrackingActive = false;

            // Nascondi controlli ma mantieni stats visibili se ci sono dati
            document.getElementById('trackingControls').style.display = 'none';

            if (gpsTrackPoints.length === 0) {
                document.getElementById('gpsStats').style.display = 'none';
            }

            // Rimuovi marker barca
            if (gpsBoatMarker) {
                map.removeLayer(gpsBoatMarker);
                gpsBoatMarker = null;
            }
        }

        // Stop e cancella tutto
        function stopAndClearTracking() {
            if (!confirm('Vuoi cancellare il percorso corrente?\nI dati non salvati andranno persi.')) {
                return;
            }

            stopGpsTracking();

            // Rimuovi polyline
            if (gpsTrackLine) {
                map.removeLayer(gpsTrackLine);
                gpsTrackLine = null;
            }

            // Reset dati
            gpsTrackPoints = [];
            gpsTotalDistance = 0;
            gpsLastPosition = null;
            gpsStartTime = null;

            // Nascondi stats
            document.getElementById('gpsStats').style.display = 'none';

            // Reset switch
            document.getElementById('gpsTrackingSwitch').checked = false;

            showToast('Percorso cancellato', 'Dati GPS rimossi', 'info', 2000);
        }

        // Pausa/Riprendi tracking
        function togglePauseTracking() {
            gpsTrackingPaused = !gpsTrackingPaused;
            updatePauseButton();

            if (gpsTrackingPaused) {
                showToast('Tracking in pausa', 'Clicca Riprendi per continuare', 'warning', 2000);
            } else {
                showToast('Tracking ripreso', 'Registrazione posizioni attiva', 'success', 2000);
            }
        }

        // Aggiorna bottone pausa
        function updatePauseButton() {
            const btn = document.getElementById('pauseTrackingBtn');
            if (gpsTrackingPaused) {
                btn.innerHTML = '<i class="fas fa-play"></i> Riprendi';
                btn.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)';
            } else {
                btn.innerHTML = '<i class="fas fa-pause"></i> Pausa';
                btn.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
            }
        }

        // Crea marker barca
        function createBoatMarker() {
            if (gpsBoatMarker) {
                map.removeLayer(gpsBoatMarker);
            }

            const boatIcon = L.divIcon({
                className: 'boat-marker',
                html: `<div id="boatIconRotate" style="
                    width: 32px;
                    height: 20px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    transition: transform 0.2s ease;
                "><svg id="boatSvg" viewBox="0 0 48 28" width="32" height="20" style="filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.5));">
                    <!-- Barca di PROFILO - prua a destra -->
                    <!-- Scafo -->
                    <path d="M4 20 L8 24 L40 24 L46 20 L44 18 L6 18 Z" fill="#1e293b"/>
                    <!-- Linea acqua -->
                    <path d="M6 22 L42 22" stroke="#334155" stroke-width="1"/>
                    <!-- Cabina/Console -->
                    <rect x="18" y="12" width="10" height="8" rx="1" fill="#334155"/>
                    <!-- Parabrezza -->
                    <path d="M28 12 L30 14 L30 18 L28 20" fill="#64748b"/>
                    <!-- T-top -->
                    <rect x="16" y="6" width="14" height="2" rx="1" fill="#475569"/>
                    <line x1="18" y1="12" x2="17" y2="8" stroke="#475569" stroke-width="1.5"/>
                    <line x1="28" y1="12" x2="29" y2="8" stroke="#475569" stroke-width="1.5"/>
                    <!-- Motore fuoribordo -->
                    <rect x="2" y="16" width="4" height="6" fill="#475569"/>
                    <rect x="1" y="22" width="3" height="4" fill="#334155"/>
                    <!-- Canna da pesca verso poppa -->
                    <line x1="20" y1="6" x2="6" y2="1" stroke="#64748b" stroke-width="1.2"/>
                    <!-- Prua affilata -->
                    <path d="M44 18 L48 19 L46 20 L44 20" fill="#0f172a"/>
                </svg></div>`,
                iconSize: [32, 20],
                iconAnchor: [6, 10]  // Ancorato verso poppa (motore)
            });

            gpsBoatMarker = L.marker([0, 0], {
                icon: boatIcon,
                zIndexOffset: 1000
            }).addTo(map);

            gpsBoatMarker.bindTooltip('La tua barca (click per centrare)', {
                permanent: false,
                direction: 'top',
                offset: [0, -20]
            });

            // Click sulla barca = centra mappa sulla barca
            gpsBoatMarker.on('click', function() {
                centerOnBoat();
            });
        }

        // Callback posizione GPS
        function onGpsPositionUpdate(position) {
            if (!gpsTrackingActive || gpsTrackingPaused) return;

            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            const speed = position.coords.speed; // m/s
            const heading = position.coords.heading; // gradi
            const timestamp = position.timestamp;

            // Calcola distanza dal punto precedente
            if (gpsLastPosition) {
                const dist = calculateDistanceNm(
                    gpsLastPosition.lat, gpsLastPosition.lng,
                    lat, lng
                );
                // Aggiungi solo se distanza significativa (>5m = ~0.0027nm)
                if (dist > 0.0027) {
                    gpsTotalDistance += dist;
                }
            }

            // Aggiungi punto al track
            const point = {
                lat: lat,
                lng: lng,
                timestamp: timestamp,
                speed: speed,
                heading: heading
            };
            gpsTrackPoints.push(point);
            gpsLastPosition = { lat, lng };

            // Aggiorna marker barca
            if (gpsBoatMarker) {
                gpsBoatMarker.setLatLng([lat, lng]);

                // Gira icona barca (profilo) in base alla direzione
                if (heading !== null && !isNaN(heading)) {
                    const rotateDiv = document.getElementById('boatIconRotate');
                    if (rotateDiv) {
                        // Barca di profilo: flip orizzontale se va verso ovest (90°-270° inclusi)
                        const goingWest = heading >= 90 && heading <= 270;
                        rotateDiv.style.transform = goingWest ? 'scaleX(-1)' : 'scaleX(1)';
                    }
                }

                // Verifica se barca è uscita dalla mappa - ricentralla se necessario
                checkBoatVisibility();
            }

            // Aggiorna polyline
            if (gpsTrackLine) {
                gpsTrackLine.addLatLng([lat, lng]);
            }

            // Aggiorna stats UI
            updateGpsStats(lat, lng, speed, heading);
        }

        // Calcola distanza in miglia nautiche
        function calculateDistanceNm(lat1, lng1, lat2, lng2) {
            const R = 3440.065; // Raggio terra in nm
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Aggiorna statistiche GPS nella UI
        function updateGpsStats(lat, lng, speed, heading) {
            // Velocità in nodi (1 m/s = 1.94384 kn)
            const speedKn = speed ? (speed * 1.94384).toFixed(1) : '0.0';
            document.getElementById('gpsSpeed').textContent = speedKn;

            // Direzione
            const headingStr = heading !== null && !isNaN(heading)
                ? `${Math.round(heading)}°`
                : '--';
            document.getElementById('gpsHeading').textContent = headingStr;

            // Distanza
            document.getElementById('gpsDistance').textContent = gpsTotalDistance.toFixed(2);

            // Durata
            if (gpsStartTime) {
                const elapsed = Date.now() - gpsStartTime;
                const mins = Math.floor(elapsed / 60000);
                const secs = Math.floor((elapsed % 60000) / 1000);
                document.getElementById('gpsDuration').textContent =
                    `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            // Coordinate
            document.getElementById('gpsCoords').textContent =
                `${lat.toFixed(5)}, ${lng.toFixed(5)}`;
        }

        // Errore GPS
        function onGpsError(error) {
            let msg = 'Errore GPS';
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    msg = 'Permesso GPS negato';
                    break;
                case error.POSITION_UNAVAILABLE:
                    msg = 'Posizione non disponibile';
                    break;
                case error.TIMEOUT:
                    msg = 'Timeout GPS';
                    break;
            }
            showToast('Errore GPS', msg, 'danger', 3000);
            console.error('GPS Error:', error);
        }

        // Mostra dialog salvataggio rotta
        function showSaveRouteDialog() {
            if (gpsTrackPoints.length < 2) {
                showToast('Nessun percorso', 'Registra almeno 2 punti prima di salvare', 'warning', 3000);
                return;
            }

            // Crea overlay
            const overlay = document.createElement('div');
            overlay.id = 'saveRouteOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;

            const duration = gpsStartTime ? Math.round((Date.now() - gpsStartTime) / 60000) : 0;

            overlay.innerHTML = `
                <div style="
                    background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
                    border-radius: 16px;
                    padding: 24px;
                    max-width: 400px;
                    width: 90%;
                    color: white;
                    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
                ">
                    <h3 style="margin: 0 0 20px 0; display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-route" style="color: #22c55e;"></i>
                        Salva Rotta
                    </h3>

                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 6px; color: #94a3b8; font-size: 0.85rem;">Nome Rotta</label>
                        <input type="text" id="routeNameInput" value="Rotta ${new Date().toLocaleDateString('it-IT')}" style="
                            width: 100%;
                            padding: 10px 12px;
                            border: 1px solid rgba(255,255,255,0.1);
                            border-radius: 8px;
                            background: rgba(0,0,0,0.3);
                            color: white;
                            font-size: 1rem;
                            box-sizing: border-box;
                        ">
                    </div>

                    <div style="
                        background: rgba(0,0,0,0.2);
                        border-radius: 8px;
                        padding: 12px;
                        margin-bottom: 20px;
                    ">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span style="color: #94a3b8;">Punti:</span>
                            <span style="color: #22d3ee;">${gpsTrackPoints.length}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span style="color: #94a3b8;">Distanza:</span>
                            <span style="color: #22d3ee;">${gpsTotalDistance.toFixed(2)} nm</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span style="color: #94a3b8;">Durata:</span>
                            <span style="color: #22d3ee;">${duration} min</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="color: #94a3b8;">Colore:</span>
                            <span style="display: flex; align-items: center; gap: 6px;">
                                <span style="display:inline-block;width:16px;height:16px;background:${gpsTrackColor};border-radius:4px;border:1px solid rgba(255,255,255,0.3);"></span>
                                <span style="color: #22d3ee;">${gpsTrackColor}</span>
                            </span>
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px;">
                        <button onclick="document.getElementById('saveRouteOverlay').remove()" style="
                            flex: 1;
                            padding: 12px;
                            background: #475569;
                            color: #e2e8f0;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: 600;
                        ">Annulla</button>
                        <button onclick="confirmSaveRoute()" style="
                            flex: 1;
                            padding: 12px;
                            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
                            color: white;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: 600;
                        "><i class="fas fa-save"></i> Salva</button>
                    </div>
                </div>
            `;

            document.body.appendChild(overlay);
            document.getElementById('routeNameInput').focus();
            document.getElementById('routeNameInput').select();
        }

        // Conferma salvataggio rotta
        const MAX_SAVED_ROUTES = 10;

        function confirmSaveRoute() {
            const name = document.getElementById('routeNameInput').value.trim();
            if (!name) {
                showToast('Nome richiesto', 'Inserisci un nome per la rotta', 'warning', 2000);
                return;
            }

            // Verifica limite massimo rotte
            if (gpsSavedRoutes.length >= MAX_SAVED_ROUTES) {
                showToast('Limite raggiunto', `Massimo ${MAX_SAVED_ROUTES} rotte salvabili. Elimina una rotta esistente.`, 'danger', 3000);
                return;
            }

            // Crea oggetto rotta con colore corrente
            const route = {
                id: 'route-' + Date.now().toString(36),
                name: name,
                date: new Date().toISOString(),
                points: [...gpsTrackPoints],
                distance: gpsTotalDistance,
                duration: gpsStartTime ? Math.round((Date.now() - gpsStartTime) / 1000) : 0,
                color: gpsTrackColor,  // Usa colore corrente selezionato
                visible: false         // Stato visibilità sulla mappa
            };

            // Aggiungi a array e salva
            gpsSavedRoutes.push(route);
            saveSavedRoutes();
            renderRouteList();

            // Chiudi dialog
            document.getElementById('saveRouteOverlay').remove();

            showToast('Rotta salvata', `"${name}" salvata con successo`, 'success', 2000);
        }

        // Render lista rotte salvate
        function renderRouteList() {
            const container = document.getElementById('routeList');
            const countEl = document.getElementById('routeCount');

            // Mostra conteggio con limite
            countEl.textContent = `${gpsSavedRoutes.length}/${MAX_SAVED_ROUTES} rotte`;
            countEl.style.color = gpsSavedRoutes.length >= MAX_SAVED_ROUTES ? '#ef4444' : '#64748b';

            if (gpsSavedRoutes.length === 0) {
                container.innerHTML = `
                    <div style="color: #64748b; font-size: 0.8rem; text-align: center; padding: 10px;">
                        Nessuna rotta salvata
                    </div>
                `;
                return;
            }

            container.innerHTML = gpsSavedRoutes.map(route => {
                const date = new Date(route.date || route.createdAt || Date.now()).toLocaleDateString('it-IT');
                const dist = route.distance.toFixed(2);
                const isVisible = route.visible || displayedRouteLines[route.id];
                const eyeIcon = isVisible ? 'fa-eye' : 'fa-eye-slash';
                const eyeColor = isVisible ? '#22c55e' : '#64748b';
                const routeColor = route.color || '#8b5cf6';

                return `
                    <div class="route-item" data-route-id="${route.id}" style="${isVisible ? 'background: rgba(34,197,94,0.1); border-left: 3px solid ' + routeColor + ';' : ''}">
                        <div class="route-item-info">
                            <div class="route-item-name" style="display: flex; align-items: center; gap: 6px;">
                                <span style="display:inline-block;width:10px;height:10px;background:${routeColor};border-radius:50%;flex-shrink:0;"></span>
                                ${route.name}
                            </div>
                            <div class="route-item-meta">${date} - ${dist} nm - ${route.points.length} pt</div>
                        </div>
                        <div class="route-item-actions">
                            <button onclick="toggleRouteOnMap('${route.id}')" title="${isVisible ? 'Nascondi' : 'Mostra'} su mappa" style="color: ${eyeColor};">
                                <i class="fas ${eyeIcon}"></i>
                            </button>
                            <button onclick="exportSingleRouteGPX('${route.id}')" title="Esporta GPX">
                                <i class="fas fa-download"></i>
                            </button>
                            <button class="delete" onclick="deleteRoute('${route.id}')" title="Elimina">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Mostra/nascondi rotte sulla mappa (supporta multiple)
        var displayedRouteLines = {};  // { routeId: L.polyline }

        function toggleRouteOnMap(routeId) {
            const route = gpsSavedRoutes.find(r => r.id === routeId);
            if (!route) return;

            // Se già visualizzata, rimuovila
            if (displayedRouteLines[routeId]) {
                map.removeLayer(displayedRouteLines[routeId]);
                delete displayedRouteLines[routeId];
                route.visible = false;
                saveSavedRoutes();
                renderRouteList();
                showToast('Rotta nascosta', `"${route.name}" rimossa dalla mappa`, 'info', 2000);
                return;
            }

            // Altrimenti aggiungila
            const latlngs = route.points.map(p => [p.lat, p.lng]);
            const polyline = L.polyline(latlngs, {
                color: route.color || '#8b5cf6',
                weight: 4,
                opacity: 0.9,
                dashArray: null // Linea continua per miglior visibilità
            }).addTo(map);

            // Calcola statistiche
            const distanceKm = (route.distance * 1.852).toFixed(2);
            const duration = route.duration ? formatRouteDuration(route.duration) : 'N/D';
            const avgSpeed = route.avgSpeed ? route.avgSpeed.toFixed(1) : (route.duration ? (route.distance / (route.duration / 3600000)).toFixed(1) : 'N/D');
            const maxSpeed = route.maxSpeed ? route.maxSpeed.toFixed(1) : (parseFloat(avgSpeed) * 1.3).toFixed(1);

            // Popup click - dettagli completi
            polyline.bindPopup(`
                <div style="min-width: 200px;">
                    <strong style="font-size: 1.1em; color: ${route.color || '#8b5cf6'};">
                        <i class="fas fa-route"></i> ${route.name}
                    </strong>
                    <hr style="margin: 8px 0; border-color: rgba(255,255,255,0.2);">
                    <table style="width: 100%; font-size: 0.9em;">
                        <tr><td><i class="fas fa-road"></i> Distanza:</td><td style="text-align:right;"><strong>${route.distance.toFixed(2)} nm</strong> (${distanceKm} km)</td></tr>
                        <tr><td><i class="fas fa-clock"></i> Durata:</td><td style="text-align:right;"><strong>${duration}</strong></td></tr>
                        <tr><td><i class="fas fa-tachometer-alt"></i> Vel. Media:</td><td style="text-align:right;"><strong>${avgSpeed} nodi</strong></td></tr>
                        <tr><td><i class="fas fa-bolt"></i> Vel. Max:</td><td style="text-align:right;"><strong>${maxSpeed} nodi</strong></td></tr>
                        <tr><td><i class="fas fa-map-marker-alt"></i> Punti GPS:</td><td style="text-align:right;">${route.points.length}</td></tr>
                    </table>
                </div>
            `, {className: 'route-popup'});

            // Tooltip hover - statistiche rapide
            polyline.bindTooltip(`
                <div style="text-align: center; padding: 2px;">
                    <strong style="color: ${route.color || '#8b5cf6'};">${route.name}</strong><br>
                    <span style="font-size: 0.95em;">
                        <i class="fas fa-road"></i> ${route.distance.toFixed(2)} nm &nbsp;|&nbsp;
                        <i class="fas fa-clock"></i> ${duration} &nbsp;|&nbsp;
                        <i class="fas fa-tachometer-alt"></i> ${avgSpeed} kn
                    </span>
                </div>
            `, {
                permanent: false,
                sticky: true,
                direction: 'top',
                offset: [0, -10],
                className: 'route-tooltip'
            });

            // Effetto hover - evidenzia rotta
            polyline.on('mouseover', function() {
                this.setStyle({ weight: 6, opacity: 1 });
            });
            polyline.on('mouseout', function() {
                this.setStyle({ weight: 4, opacity: 0.9 });
            });

            displayedRouteLines[routeId] = polyline;
            route.visible = true;
            saveSavedRoutes();
            renderRouteList();

            // Centra mappa su tutte le rotte visibili
            fitMapToVisibleRoutes();

            showToast('Rotta visualizzata', `"${route.name}" mostrata sulla mappa`, 'info', 2000);
        }

        // Centra la mappa su tutte le rotte visibili
        function fitMapToVisibleRoutes() {
            const visibleIds = Object.keys(displayedRouteLines);
            if (visibleIds.length === 0) return;

            const bounds = L.latLngBounds();
            visibleIds.forEach(id => {
                bounds.extend(displayedRouteLines[id].getBounds());
            });
            map.fitBounds(bounds, { padding: [50, 50] });
        }

        // Compatibilità con vecchio codice
        function showRouteOnMap(routeId) {
            toggleRouteOnMap(routeId);
        }

        // Mostra tutte le rotte sulla mappa
        function showAllRoutes() {
            if (gpsSavedRoutes.length === 0) {
                showToast('Nessuna rotta', 'Non ci sono rotte salvate da visualizzare', 'info', 2000);
                return;
            }

            let addedCount = 0;
            gpsSavedRoutes.forEach(route => {
                // Aggiungi solo se non già visualizzata
                if (!displayedRouteLines[route.id]) {
                    // Crea polyline
                    const latlngs = route.points.map(p => [p.lat, p.lng]);
                    const polyline = L.polyline(latlngs, {
                        color: route.color || '#8b5cf6',
                        weight: 4,
                        opacity: 0.9
                    }).addTo(map);

                    // Statistiche
                    const distanceKm = (route.distance * 1.852).toFixed(2);
                    const duration = route.duration ? formatRouteDuration(route.duration) : 'N/D';
                    const avgSpeed = route.avgSpeed ? route.avgSpeed.toFixed(1) : 'N/D';

                    // Tooltip hover
                    polyline.bindTooltip(`
                        <div style="text-align: center; padding: 2px;">
                            <strong style="color: ${route.color || '#8b5cf6'};">${route.name}</strong><br>
                            <span style="font-size: 0.95em;">
                                <i class="fas fa-road"></i> ${route.distance.toFixed(2)} nm |
                                <i class="fas fa-clock"></i> ${duration} |
                                <i class="fas fa-tachometer-alt"></i> ${avgSpeed} kn
                            </span>
                        </div>
                    `, { permanent: false, sticky: true, direction: 'top', offset: [0, -10], className: 'route-tooltip' });

                    // Popup click
                    polyline.bindPopup(`
                        <div style="min-width: 180px;">
                            <strong style="color: ${route.color || '#8b5cf6'};">${route.name}</strong>
                            <hr style="margin: 6px 0;">
                            <div><i class="fas fa-road"></i> ${route.distance.toFixed(2)} nm (${distanceKm} km)</div>
                            <div><i class="fas fa-clock"></i> ${duration}</div>
                            <div><i class="fas fa-tachometer-alt"></i> ${avgSpeed} nodi</div>
                        </div>
                    `, {className: 'route-popup'});

                    // Hover effect
                    polyline.on('mouseover', function() { this.setStyle({ weight: 6, opacity: 1 }); });
                    polyline.on('mouseout', function() { this.setStyle({ weight: 4, opacity: 0.9 }); });

                    displayedRouteLines[route.id] = polyline;
                    route.visible = true;
                    addedCount++;
                }
            });

            saveSavedRoutes();
            renderRouteList();
            fitMapToVisibleRoutes();
            showToast('Rotte visualizzate', `${addedCount} rotte mostrate sulla mappa`, 'success', 2000);
        }

        // Nascondi tutte le rotte dalla mappa
        function hideAllRoutes() {
            const count = Object.keys(displayedRouteLines).length;
            if (count === 0) {
                showToast('Nessuna rotta', 'Non ci sono rotte visualizzate da nascondere', 'info', 2000);
                return;
            }

            // Rimuovi tutte le polyline
            Object.keys(displayedRouteLines).forEach(routeId => {
                map.removeLayer(displayedRouteLines[routeId]);
                delete displayedRouteLines[routeId];
                const route = gpsSavedRoutes.find(r => r.id === routeId);
                if (route) route.visible = false;
            });

            saveSavedRoutes();
            renderRouteList();
            showToast('Rotte nascoste', `${count} rotte rimosse dalla mappa`, 'info', 2000);
        }

        // Elimina rotta
        function deleteRoute(routeId) {
            const route = gpsSavedRoutes.find(r => r.id === routeId);
            if (!route) return;

            if (!confirm(`Eliminare la rotta "${route.name}"?`)) return;

            // Rimuovi dalla mappa se visualizzata
            if (displayedRouteLines[routeId]) {
                map.removeLayer(displayedRouteLines[routeId]);
                delete displayedRouteLines[routeId];
            }

            gpsSavedRoutes = gpsSavedRoutes.filter(r => r.id !== routeId);
            saveSavedRoutes();
            renderRouteList();

            showToast('Rotta eliminata', `"${route.name}" rimossa`, 'info', 2000);
        }

        // Export singola rotta GPX
        function exportSingleRouteGPX(routeId) {
            const route = gpsSavedRoutes.find(r => r.id === routeId);
            if (!route) return;

            const gpx = generateGPX([route]);
            downloadFile(gpx, `${route.name.replace(/[^a-zA-Z0-9]/g, '_')}.gpx`, 'application/gpx+xml');
            showToast('Export completato', `Rotta "${route.name}" esportata`, 'success', 2000);
        }

        // Export tutte le rotte GPX
        function exportAllRoutesGPX() {
            if (gpsSavedRoutes.length === 0) {
                showToast('Nessuna rotta', 'Non ci sono rotte da esportare', 'warning', 2000);
                return;
            }

            const gpx = generateGPX(gpsSavedRoutes);
            downloadFile(gpx, `rotte_${new Date().toISOString().split('T')[0]}.gpx`, 'application/gpx+xml');
            showToast('Export completato', `${gpsSavedRoutes.length} rotte esportate in GPX`, 'success', 2000);
        }

        // Export tutte le rotte GeoJSON
        function exportAllRoutesGeoJSON() {
            if (gpsSavedRoutes.length === 0) {
                showToast('Nessuna rotta', 'Non ci sono rotte da esportare', 'warning', 2000);
                return;
            }

            const geojson = generateGeoJSON(gpsSavedRoutes);
            downloadFile(JSON.stringify(geojson, null, 2), `rotte_${new Date().toISOString().split('T')[0]}.geojson`, 'application/geo+json');
            showToast('Export completato', `${gpsSavedRoutes.length} rotte esportate in GeoJSON`, 'success', 2000);
        }

        // Genera GPX con supporto colore (estensione gpx_style)
        function generateGPX(routes) {
            let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="BathymetryExplorer"
     xmlns="http://www.topografix.com/GPX/1/1"
     xmlns:gpx_style="http://www.topografix.com/GPX/gpx_style/0/2"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
  <metadata>
    <name>Rotte BathymetryExplorer</name>
    <time>${new Date().toISOString()}</time>
  </metadata>
`;

            routes.forEach(route => {
                const color = route.color || '#22c55e';
                // Converti colore hex in RGB per GPX
                const r = parseInt(color.slice(1,3), 16);
                const g = parseInt(color.slice(3,5), 16);
                const b = parseInt(color.slice(5,7), 16);

                gpx += `  <trk>
    <name>${route.name}</name>
    <desc>Distanza: ${route.distance.toFixed(2)} nm | Colore: ${color}</desc>
    <extensions>
      <gpx_style:line>
        <gpx_style:color>${color.replace('#','')}</gpx_style:color>
        <gpx_style:opacity>0.85</gpx_style:opacity>
        <gpx_style:width>3</gpx_style:width>
      </gpx_style:line>
    </extensions>
    <trkseg>
`;
                route.points.forEach(pt => {
                    const time = new Date(pt.timestamp).toISOString();
                    gpx += `      <trkpt lat="${pt.lat}" lon="${pt.lng}">
        <time>${time}</time>
        ${pt.speed ? `<speed>${pt.speed}</speed>` : ''}
        ${pt.heading ? `<course>${pt.heading}</course>` : ''}
      </trkpt>
`;
                });
                gpx += `    </trkseg>
  </trk>
`;
            });

            gpx += `</gpx>`;
            return gpx;
        }

        // Genera GeoJSON con colore e stile
        function generateGeoJSON(routes) {
            return {
                type: 'FeatureCollection',
                features: routes.map(route => ({
                    type: 'Feature',
                    properties: {
                        name: route.name,
                        date: route.date,
                        distance_nm: route.distance,
                        duration_sec: route.duration,
                        points_count: route.points.length,
                        // Stile per visualizzazione
                        stroke: route.color || '#22c55e',
                        'stroke-width': 3,
                        'stroke-opacity': 0.85
                    },
                    geometry: {
                        type: 'LineString',
                        coordinates: route.points.map(pt => [pt.lng, pt.lat])
                    }
                }))
            };
        }

        // Download file helper
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ============================================
        // DEMO NAVIGATION - Simulazione Forio → Campo Gara
        // ============================================

        var demoNavigationActive = false;
        var demoIntervalId = null;

        function startDemoNavigation() {
            // Se demo gia' attiva, fermala
            if (demoNavigationActive) {
                stopDemoNavigation();
                return;
            }

            // Ferma tracking reale se attivo
            if (gpsTrackingActive) {
                stopGpsTracking();
                document.getElementById('gpsTrackingSwitch').checked = false;
            }

            // Coordinate rotta: Forio porto → al largo verso campo gara Big Game
            const startPoint = { lat: 40.7373, lng: 13.8576 };  // Porto di Forio
            const endPoint = { lat: 40.7248, lng: 13.6985 };    // Campo Gara Big Game

            // Genera 30 punti intermedi con curva naturale
            const demoPoints = [];
            const totalPoints = 30;
            for (let i = 0; i <= totalPoints; i++) {
                const t = i / totalPoints;
                // Interpolazione con leggera curva verso sud inizialmente
                const curveFactor = Math.sin(t * Math.PI) * 0.015;
                const lat = startPoint.lat + (endPoint.lat - startPoint.lat) * t - curveFactor;
                const lng = startPoint.lng + (endPoint.lng - startPoint.lng) * t;
                demoPoints.push({ lat, lng });
            }

            // Reset tracking state
            gpsTrackPoints = [];
            gpsTotalDistance = 0;
            gpsLastPosition = null;
            gpsStartTime = Date.now();
            demoNavigationActive = true;

            // Mostra UI
            document.getElementById('gpsStats').style.display = 'grid';
            document.getElementById('trackingControls').style.display = 'block';

            // Cambia bottone demo
            const demoBtn = document.getElementById('demoNavigationBtn');
            demoBtn.innerHTML = '<i class="fas fa-stop-circle"></i> Ferma Demo';
            demoBtn.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';

            // Crea marker barca
            createBoatMarker();

            // Crea polyline percorso
            if (gpsTrackLine) {
                map.removeLayer(gpsTrackLine);
            }
            gpsTrackLine = L.polyline([], {
                color: gpsTrackColor,
                weight: 2,
                opacity: 0.9,
                dashArray: null
            }).addTo(map);

            // Centra mappa sul percorso
            map.setView([40.73, 13.78], 12);

            showToast('Demo Navigazione', 'Simulazione Forio → Campo Gara Big Game', 'info', 3000);

            // Animazione: un punto ogni 500ms
            let pointIndex = 0;
            const speed = 8.5;  // ~8.5 nodi costanti
            const speedMs = speed / 1.94384;  // m/s

            // Prima posizione
            const firstPoint = demoPoints[0];
            if (gpsBoatMarker) {
                gpsBoatMarker.setLatLng([firstPoint.lat, firstPoint.lng]);
            }

            demoIntervalId = setInterval(() => {
                if (pointIndex >= demoPoints.length) {
                    // Demo completata
                    clearInterval(demoIntervalId);
                    demoIntervalId = null;
                    demoNavigationActive = false;

                    // Ripristina bottone
                    const btn = document.getElementById('demoNavigationBtn');
                    btn.innerHTML = '<i class="fas fa-play-circle"></i> Demo: Forio → Campo Gara';
                    btn.style.background = 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)';

                    showToast('Demo completata!', 'Rotta simulata completata - puoi salvarla', 'success', 3000);
                    return;
                }

                const pt = demoPoints[pointIndex];

                // Demo: direzione fissa verso ovest (da Forio a Campo Gara)
                // Usiamo bearing fisso per evitare flip durante la curva
                const heading = 256; // WSW - direzione media del percorso

                // Calcola distanza dal punto precedente
                if (gpsLastPosition) {
                    const dist = calculateDistanceNm(
                        gpsLastPosition.lat, gpsLastPosition.lng,
                        pt.lat, pt.lng
                    );
                    gpsTotalDistance += dist;
                }

                // Registra punto
                const trackPoint = {
                    lat: pt.lat,
                    lng: pt.lng,
                    timestamp: Date.now(),
                    speed: speedMs,
                    heading: heading
                };
                gpsTrackPoints.push(trackPoint);
                gpsLastPosition = { lat: pt.lat, lng: pt.lng };

                // Aggiorna marker barca
                if (gpsBoatMarker) {
                    gpsBoatMarker.setLatLng([pt.lat, pt.lng]);

                    // Gira icona barca (profilo) in base alla direzione
                    const rotateDiv = document.getElementById('boatIconRotate');
                    if (rotateDiv) {
                        // Barca di profilo: flip orizzontale se va verso ovest (90°-270° inclusi)
                        const goingWest = heading >= 90 && heading <= 270;
                        rotateDiv.style.transform = goingWest ? 'scaleX(-1)' : 'scaleX(1)';
                    }
                }

                // Aggiorna polyline
                if (gpsTrackLine) {
                    gpsTrackLine.addLatLng([pt.lat, pt.lng]);
                }

                // Aggiorna stats UI
                updateGpsStats(pt.lat, pt.lng, speedMs, heading);

                // Centro mappa segue la barca
                map.panTo([pt.lat, pt.lng], { animate: true, duration: 0.4 });

                pointIndex++;
            }, 500);  // Ogni 500ms = ~15 secondi per completare
        }

        // Ferma demo navigation
        function stopDemoNavigation() {
            if (demoIntervalId) {
                clearInterval(demoIntervalId);
                demoIntervalId = null;
            }
            demoNavigationActive = false;

            // Ripristina bottone
            const demoBtn = document.getElementById('demoNavigationBtn');
            demoBtn.innerHTML = '<i class="fas fa-play-circle"></i> Demo: Forio → Campo Gara';
            demoBtn.style.background = 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)';

            showToast('Demo fermata', 'Navigazione simulata interrotta', 'info', 2000);
        }

        // Calcola bearing tra due punti (gradi)
        function calculateBearing(lat1, lng1, lat2, lng2) {
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const lat1Rad = lat1 * Math.PI / 180;
            const lat2Rad = lat2 * Math.PI / 180;

            const y = Math.sin(dLng) * Math.cos(lat2Rad);
            const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -
                      Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLng);

            let bearing = Math.atan2(y, x) * 180 / Math.PI;
            bearing = (bearing + 360) % 360;
            return bearing;
        }

        // Inizializza GPS Tracking
        function initGpsTracking() {
            loadSavedRoutes();
        }

        // Inizializza GPS Tracking quando DOM pronto
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(initGpsTracking, 300);
        } else {
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(initGpsTracking, 300);
            });
        }
    </script>

    <!-- Service Worker Registration -->
    <script>
        // Registra Service Worker per PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('./sw.js')
                    .then(function(registration) {
                        console.log('[PWA] Service Worker registrato:', registration.scope);

                        // Listener per messaggi dal SW
                        navigator.serviceWorker.addEventListener('message', function(event) {
                            if (event.data.type === 'downloadProgress') {
                                updateOfflineProgress(event.data.downloaded, event.data.total);
                            }
                            if (event.data.type === 'downloadComplete') {
                                offlineDownloadComplete(event.data.downloaded, event.data.total);
                            }
                        });
                    })
                    .catch(function(error) {
                        console.log('[PWA] Service Worker registrazione fallita:', error);
                    });
            });
        }

        // Aggiorna progresso download offline
        function updateOfflineProgress(downloaded, total) {
            const percent = Math.round((downloaded / total) * 100);
            const progressEl = document.getElementById('offlineProgress');
            if (progressEl) {
                progressEl.style.width = percent + '%';
                document.getElementById('offlineProgressText').textContent =
                    `Scaricamento: ${downloaded}/${total} tile (${percent}%)`;
            }
        }

        // Download offline completato
        function offlineDownloadComplete(downloaded, total) {
            showToast('Download Completato',
                `${downloaded} tile salvate per uso offline`, 'success', 3000);
            const btn = document.getElementById('downloadOfflineBtn');
            if (btn) {
                btn.disabled = false;
                btn.innerHTML = '<i class="fas fa-download"></i> Scarica Area';
            }
            document.getElementById('offlineProgressContainer').style.display = 'none';
        }

        // Helper: ottieni SW attivo
        async function getActiveServiceWorker() {
            // Service Worker non funziona con file://
            if (window.location.protocol === 'file:') {
                showToast('Errore', 'Il download offline non funziona con file://. Usa http://localhost o GitHub Pages.', 'error', 5000);
                return null;
            }
            if (!('serviceWorker' in navigator)) {
                showToast('Errore', 'Service Worker non supportato dal browser.', 'error', 3000);
                return null;
            }
            try {
                const registration = await navigator.serviceWorker.ready;
                return registration.active;
            } catch (e) {
                console.error('[SW] Errore:', e);
                return null;
            }
        }

        // Scarica area corrente per uso offline
        async function downloadAreaForOffline() {
            const sw = await getActiveServiceWorker();
            if (!sw) {
                showToast('Errore', 'Service Worker non attivo. Ricarica la pagina.', 'error', 3000);
                return;
            }

            const bounds = map.getBounds();
            const zoom = Math.min(map.getZoom() + 2, 14); // Max zoom 14 per non scaricare troppo

            const area = {
                north: bounds.getNorth(),
                south: bounds.getSouth(),
                east: bounds.getEast(),
                west: bounds.getWest()
            };

            // Mostra progresso
            document.getElementById('offlineProgressContainer').style.display = 'block';
            document.getElementById('offlineProgress').style.width = '0%';
            document.getElementById('offlineProgressText').textContent = 'Avvio download...';

            const btn = document.getElementById('downloadOfflineBtn');
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Scaricando...';

            // Invia messaggio al Service Worker
            sw.postMessage({
                action: 'downloadArea',
                bounds: area,
                zoom: zoom
            });

            showToast('Download Avviato',
                `Scaricamento mappe per zoom 8-${zoom}. Potrebbe richiedere alcuni minuti.`,
                'info', 5000);
        }

        // Ottieni dimensione cache
        async function getOfflineCacheSize() {
            const sw = await getActiveServiceWorker();
            if (!sw) return;

            const messageChannel = new MessageChannel();
            messageChannel.port1.onmessage = function(event) {
                const sizeMB = (event.data.size / (1024 * 1024)).toFixed(2);
                document.getElementById('cacheSize').textContent = sizeMB + ' MB';
            };

            sw.postMessage(
                { action: 'getCacheSize' },
                [messageChannel.port2]
            );
        }

        // Pulisci cache tile
        async function clearOfflineCache() {
            const sw = await getActiveServiceWorker();
            if (!sw) return;

            if (!confirm('Eliminare tutte le mappe offline salvate?')) return;

            const messageChannel = new MessageChannel();
            messageChannel.port1.onmessage = function(event) {
                if (event.data.success) {
                    showToast('Cache Pulita', 'Mappe offline eliminate', 'success', 2000);
                    document.getElementById('cacheSize').textContent = '0 MB';
                }
            };

            sw.postMessage(
                { action: 'clearTilesCache' },
                [messageChannel.port2]
            );
        }

        // Aggiorna dimensione cache periodicamente
        setInterval(getOfflineCacheSize, 30000);
        setTimeout(getOfflineCacheSize, 3000); // Aspetta che SW sia pronto

        // =============================================
        // OFFLINE ZONE DOWNLOAD - Porto → Campo Gara
        // =============================================

        // Popola dropdown zone per download offline
        function populateOfflineZones() {
            const select = document.getElementById('offlineZoneSelect');
            if (!select) return;

            // Pulisci opzioni esistenti
            select.innerHTML = '<option value="">-- Seleziona campo --</option>';

            // Raccogli tutte le zone
            const zones = typeof ZONES_DATA !== 'undefined' ? ZONES_DATA : [];
            const userZones = JSON.parse(localStorage.getItem('bathyExplorerUserZones') || '[]');
            const allZones = [...zones, ...userZones];

            // Aggiungi opzioni
            allZones.forEach(zone => {
                if (zone.gatheringPoint) {  // Solo zone con punto raduno
                    const option = document.createElement('option');
                    option.value = zone.id;
                    option.textContent = `${zone.name} (${zone.year || 'N/A'})`;
                    select.appendChild(option);
                }
            });

            // Listener per cambio selezione
            select.onchange = function() {
                onOfflineZoneSelected(this.value);
            };
        }

        // Gestisci selezione zona per offline
        function onOfflineZoneSelected(zoneId) {
            const infoPanel = document.getElementById('offlineAreaInfo');
            const detailsEl = document.getElementById('offlineAreaDetails');
            const downloadBtn = document.getElementById('downloadOfflineBtn');

            if (!zoneId) {
                infoPanel.style.display = 'none';
                downloadBtn.disabled = true;
                return;
            }

            // Trova la zona
            const zones = typeof ZONES_DATA !== 'undefined' ? ZONES_DATA : [];
            const userZones = JSON.parse(localStorage.getItem('bathyExplorerUserZones') || '[]');
            const allZones = [...zones, ...userZones];
            const zone = allZones.find(z => z.id === zoneId);

            if (!zone || !zone.gatheringPoint) {
                showToast('Errore', 'Zona non valida o senza punto raduno', 'error', 2000);
                return;
            }

            // Calcola bounds dal porto ai vertici + buffer
            const bounds = calculateZoneDownloadBounds(zone);

            // Stima tile da scaricare (approssimativa)
            const estimatedTiles = estimateTileCount(bounds, 14);

            // Mostra info
            detailsEl.innerHTML = `
                <div><strong>Porto:</strong> ${zone.gatheringPoint.name || 'Punto Raduno'}</div>
                <div><strong>Campo:</strong> ${zone.name}</div>
                <div><strong>Buffer:</strong> 10 nm</div>
                <div><strong>Tile stimate:</strong> ~${estimatedTiles}</div>
                <div><strong>Tempo:</strong> ~${Math.ceil(estimatedTiles / 50)} min</div>
            `;
            infoPanel.style.display = 'block';
            downloadBtn.disabled = false;
        }

        // Calcola bounds dal porto al campo gara + 10nm buffer
        function calculateZoneDownloadBounds(zone) {
            const bufferNm = 10;  // 10 miglia nautiche
            const bufferDeg = bufferNm / 60;  // 1 nm = 1 arcmin = 1/60 grado

            let north = -90, south = 90, east = -180, west = 180;

            // Includi punto raduno (porto)
            if (zone.gatheringPoint) {
                north = Math.max(north, zone.gatheringPoint.lat);
                south = Math.min(south, zone.gatheringPoint.lat);
                east = Math.max(east, zone.gatheringPoint.lng);
                west = Math.min(west, zone.gatheringPoint.lng);
            }

            // Includi tutti i vertici della zona
            if (zone.vertices && zone.vertices.length > 0) {
                zone.vertices.forEach(v => {
                    north = Math.max(north, v.lat);
                    south = Math.min(south, v.lat);
                    east = Math.max(east, v.lng);
                    west = Math.min(west, v.lng);
                });
            }

            // Aggiungi buffer
            return {
                north: north + bufferDeg,
                south: south - bufferDeg,
                east: east + bufferDeg,
                west: west - bufferDeg
            };
        }

        // Stima numero tile da scaricare
        function estimateTileCount(bounds, maxZoom) {
            let total = 0;
            for (let z = 8; z <= maxZoom; z++) {
                const n = Math.pow(2, z);
                const xMin = Math.floor((bounds.west + 180) / 360 * n);
                const xMax = Math.floor((bounds.east + 180) / 360 * n);
                const yMinLat = Math.log(Math.tan(bounds.north * Math.PI / 180) + 1 / Math.cos(bounds.north * Math.PI / 180));
                const yMaxLat = Math.log(Math.tan(bounds.south * Math.PI / 180) + 1 / Math.cos(bounds.south * Math.PI / 180));
                const yMin = Math.floor((1 - yMinLat / Math.PI) / 2 * n);
                const yMax = Math.floor((1 - yMaxLat / Math.PI) / 2 * n);
                total += (xMax - xMin + 1) * (yMax - yMin + 1);
            }
            return total;
        }

        // Scarica mappe per zona selezionata (Porto → Campo Gara)
        async function downloadZoneForOffline() {
            const select = document.getElementById('offlineZoneSelect');
            const zoneId = select ? select.value : null;

            if (!zoneId) {
                showToast('Attenzione', 'Seleziona un campo di gara', 'warning', 2000);
                return;
            }

            const sw = await getActiveServiceWorker();
            if (!sw) {
                showToast('Errore', 'Service Worker non attivo. Ricarica la pagina.', 'error', 3000);
                return;
            }

            // Trova la zona
            const zones = typeof ZONES_DATA !== 'undefined' ? ZONES_DATA : [];
            const userZones = JSON.parse(localStorage.getItem('bathyExplorerUserZones') || '[]');
            const allZones = [...zones, ...userZones];
            const zone = allZones.find(z => z.id === zoneId);

            if (!zone) {
                showToast('Errore', 'Zona non trovata', 'error', 2000);
                return;
            }

            // Calcola bounds
            const bounds = calculateZoneDownloadBounds(zone);
            const maxZoom = 14;  // Max zoom per offline

            // Mostra progresso
            document.getElementById('offlineProgressContainer').style.display = 'block';
            document.getElementById('offlineProgress').style.width = '0%';
            document.getElementById('offlineProgressText').textContent = 'Avvio download...';

            const btn = document.getElementById('downloadOfflineBtn');
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Scaricando...';

            // Invia al Service Worker
            sw.postMessage({
                action: 'downloadArea',
                bounds: bounds,
                zoom: maxZoom
            });

            showToast('Download Avviato',
                `Scaricamento mappe: ${zone.gatheringPoint.name} → ${zone.name}`,
                'info', 5000);
        }

        // Inizializza dropdown zone offline quando DOM pronto
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(populateOfflineZones, 500);
        } else {
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(populateOfflineZones, 500);
            });
        }
    </script>
</body>
</html>
